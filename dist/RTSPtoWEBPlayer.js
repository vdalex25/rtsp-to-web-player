/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var RTSPtoWEBPlayer;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/hls.js/dist/hls.light.min.js":
/*!***************************************************!*\
  !*** ./node_modules/hls.js/dist/hls.light.min.js ***!
  \***************************************************/
/***/ (function(module) {

eval("\"undefined\" != typeof window && function (t, e) {\n   true ? module.exports = e() : 0;\n}(this, function () {\n  return function (t) {\n    var e = {};\n\n    function r(i) {\n      if (e[i]) return e[i].exports;\n      var a = e[i] = {\n        i: i,\n        l: !1,\n        exports: {}\n      };\n      return t[i].call(a.exports, a, a.exports, r), a.l = !0, a.exports;\n    }\n\n    return r.m = t, r.c = e, r.d = function (t, e, i) {\n      r.o(t, e) || Object.defineProperty(t, e, {\n        enumerable: !0,\n        get: i\n      });\n    }, r.r = function (t) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      });\n    }, r.t = function (t, e) {\n      if (1 & e && (t = r(t)), 8 & e) return t;\n      if (4 & e && \"object\" == typeof t && t && t.__esModule) return t;\n      var i = Object.create(null);\n      if (r.r(i), Object.defineProperty(i, \"default\", {\n        enumerable: !0,\n        value: t\n      }), 2 & e && \"string\" != typeof t) for (var a in t) r.d(i, a, function (e) {\n        return t[e];\n      }.bind(null, a));\n      return i;\n    }, r.n = function (t) {\n      var e = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };\n      return r.d(e, \"a\", e), e;\n    }, r.o = function (t, e) {\n      return Object.prototype.hasOwnProperty.call(t, e);\n    }, r.p = \"/dist/\", r(r.s = 19);\n  }([function (t, e, r) {\n    \"use strict\";\n\n    var i;\n    r.d(e, \"a\", function () {\n      return i;\n    }), function (t) {\n      t.MEDIA_ATTACHING = \"hlsMediaAttaching\", t.MEDIA_ATTACHED = \"hlsMediaAttached\", t.MEDIA_DETACHING = \"hlsMediaDetaching\", t.MEDIA_DETACHED = \"hlsMediaDetached\", t.BUFFER_RESET = \"hlsBufferReset\", t.BUFFER_CODECS = \"hlsBufferCodecs\", t.BUFFER_CREATED = \"hlsBufferCreated\", t.BUFFER_APPENDING = \"hlsBufferAppending\", t.BUFFER_APPENDED = \"hlsBufferAppended\", t.BUFFER_EOS = \"hlsBufferEos\", t.BUFFER_FLUSHING = \"hlsBufferFlushing\", t.BUFFER_FLUSHED = \"hlsBufferFlushed\", t.MANIFEST_LOADING = \"hlsManifestLoading\", t.MANIFEST_LOADED = \"hlsManifestLoaded\", t.MANIFEST_PARSED = \"hlsManifestParsed\", t.LEVEL_SWITCHING = \"hlsLevelSwitching\", t.LEVEL_SWITCHED = \"hlsLevelSwitched\", t.LEVEL_LOADING = \"hlsLevelLoading\", t.LEVEL_LOADED = \"hlsLevelLoaded\", t.LEVEL_UPDATED = \"hlsLevelUpdated\", t.LEVEL_PTS_UPDATED = \"hlsLevelPtsUpdated\", t.LEVELS_UPDATED = \"hlsLevelsUpdated\", t.AUDIO_TRACKS_UPDATED = \"hlsAudioTracksUpdated\", t.AUDIO_TRACK_SWITCHING = \"hlsAudioTrackSwitching\", t.AUDIO_TRACK_SWITCHED = \"hlsAudioTrackSwitched\", t.AUDIO_TRACK_LOADING = \"hlsAudioTrackLoading\", t.AUDIO_TRACK_LOADED = \"hlsAudioTrackLoaded\", t.SUBTITLE_TRACKS_UPDATED = \"hlsSubtitleTracksUpdated\", t.SUBTITLE_TRACKS_CLEARED = \"hlsSubtitleTracksCleared\", t.SUBTITLE_TRACK_SWITCH = \"hlsSubtitleTrackSwitch\", t.SUBTITLE_TRACK_LOADING = \"hlsSubtitleTrackLoading\", t.SUBTITLE_TRACK_LOADED = \"hlsSubtitleTrackLoaded\", t.SUBTITLE_FRAG_PROCESSED = \"hlsSubtitleFragProcessed\", t.CUES_PARSED = \"hlsCuesParsed\", t.NON_NATIVE_TEXT_TRACKS_FOUND = \"hlsNonNativeTextTracksFound\", t.INIT_PTS_FOUND = \"hlsInitPtsFound\", t.FRAG_LOADING = \"hlsFragLoading\", t.FRAG_LOAD_EMERGENCY_ABORTED = \"hlsFragLoadEmergencyAborted\", t.FRAG_LOADED = \"hlsFragLoaded\", t.FRAG_DECRYPTED = \"hlsFragDecrypted\", t.FRAG_PARSING_INIT_SEGMENT = \"hlsFragParsingInitSegment\", t.FRAG_PARSING_USERDATA = \"hlsFragParsingUserdata\", t.FRAG_PARSING_METADATA = \"hlsFragParsingMetadata\", t.FRAG_PARSED = \"hlsFragParsed\", t.FRAG_BUFFERED = \"hlsFragBuffered\", t.FRAG_CHANGED = \"hlsFragChanged\", t.FPS_DROP = \"hlsFpsDrop\", t.FPS_DROP_LEVEL_CAPPING = \"hlsFpsDropLevelCapping\", t.ERROR = \"hlsError\", t.DESTROYING = \"hlsDestroying\", t.KEY_LOADING = \"hlsKeyLoading\", t.KEY_LOADED = \"hlsKeyLoaded\", t.LIVE_BACK_BUFFER_REACHED = \"hlsLiveBackBufferReached\", t.BACK_BUFFER_REACHED = \"hlsBackBufferReached\";\n    }(i || (i = {}));\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"a\", function () {\n      return o;\n    }), r.d(e, \"b\", function () {\n      return l;\n    });\n\n    var i = function () {},\n        a = {\n      trace: i,\n      debug: i,\n      log: i,\n      warn: i,\n      info: i,\n      error: i\n    },\n        n = a;\n\n    function s(t) {\n      var e = self.console[t];\n      return e ? e.bind(self.console, \"[\" + t + \"] >\") : i;\n    }\n\n    function o(t) {\n      if (self.console && !0 === t || \"object\" == typeof t) {\n        !function (t) {\n          for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) r[i - 1] = arguments[i];\n\n          r.forEach(function (e) {\n            n[e] = t[e] ? t[e].bind(t) : s(e);\n          });\n        }(t, \"debug\", \"log\", \"info\", \"warn\", \"error\");\n\n        try {\n          n.log();\n        } catch (t) {\n          n = a;\n        }\n      } else n = a;\n    }\n\n    var l = a;\n  }, function (t, e, r) {\n    \"use strict\";\n\n    var i, a;\n    r.d(e, \"b\", function () {\n      return i;\n    }), r.d(e, \"a\", function () {\n      return a;\n    }), function (t) {\n      t.NETWORK_ERROR = \"networkError\", t.MEDIA_ERROR = \"mediaError\", t.KEY_SYSTEM_ERROR = \"keySystemError\", t.MUX_ERROR = \"muxError\", t.OTHER_ERROR = \"otherError\";\n    }(i || (i = {})), function (t) {\n      t.KEY_SYSTEM_NO_KEYS = \"keySystemNoKeys\", t.KEY_SYSTEM_NO_ACCESS = \"keySystemNoAccess\", t.KEY_SYSTEM_NO_SESSION = \"keySystemNoSession\", t.KEY_SYSTEM_LICENSE_REQUEST_FAILED = \"keySystemLicenseRequestFailed\", t.KEY_SYSTEM_NO_INIT_DATA = \"keySystemNoInitData\", t.MANIFEST_LOAD_ERROR = \"manifestLoadError\", t.MANIFEST_LOAD_TIMEOUT = \"manifestLoadTimeOut\", t.MANIFEST_PARSING_ERROR = \"manifestParsingError\", t.MANIFEST_INCOMPATIBLE_CODECS_ERROR = \"manifestIncompatibleCodecsError\", t.LEVEL_EMPTY_ERROR = \"levelEmptyError\", t.LEVEL_LOAD_ERROR = \"levelLoadError\", t.LEVEL_LOAD_TIMEOUT = \"levelLoadTimeOut\", t.LEVEL_SWITCH_ERROR = \"levelSwitchError\", t.AUDIO_TRACK_LOAD_ERROR = \"audioTrackLoadError\", t.AUDIO_TRACK_LOAD_TIMEOUT = \"audioTrackLoadTimeOut\", t.SUBTITLE_LOAD_ERROR = \"subtitleTrackLoadError\", t.SUBTITLE_TRACK_LOAD_TIMEOUT = \"subtitleTrackLoadTimeOut\", t.FRAG_LOAD_ERROR = \"fragLoadError\", t.FRAG_LOAD_TIMEOUT = \"fragLoadTimeOut\", t.FRAG_DECRYPT_ERROR = \"fragDecryptError\", t.FRAG_PARSING_ERROR = \"fragParsingError\", t.REMUX_ALLOC_ERROR = \"remuxAllocError\", t.KEY_LOAD_ERROR = \"keyLoadError\", t.KEY_LOAD_TIMEOUT = \"keyLoadTimeOut\", t.BUFFER_ADD_CODEC_ERROR = \"bufferAddCodecError\", t.BUFFER_INCOMPATIBLE_CODECS_ERROR = \"bufferIncompatibleCodecsError\", t.BUFFER_APPEND_ERROR = \"bufferAppendError\", t.BUFFER_APPENDING_ERROR = \"bufferAppendingError\", t.BUFFER_STALLED_ERROR = \"bufferStalledError\", t.BUFFER_FULL_ERROR = \"bufferFullError\", t.BUFFER_SEEK_OVER_HOLE = \"bufferSeekOverHole\", t.BUFFER_NUDGE_ON_STALL = \"bufferNudgeOnStall\", t.INTERNAL_EXCEPTION = \"internalException\", t.INTERNAL_ABORTED = \"aborted\", t.UNKNOWN = \"unknown\";\n    }(a || (a = {}));\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"a\", function () {\n      return i;\n    });\n\n    var i = Number.isFinite || function (t) {\n      return \"number\" == typeof t && isFinite(t);\n    };\n\n    Number.MAX_SAFE_INTEGER;\n  }, function (t, e, r) {\n    \"use strict\";\n\n    var i, a;\n    r.d(e, \"a\", function () {\n      return i;\n    }), r.d(e, \"b\", function () {\n      return a;\n    }), function (t) {\n      t.MANIFEST = \"manifest\", t.LEVEL = \"level\", t.AUDIO_TRACK = \"audioTrack\", t.SUBTITLE_TRACK = \"subtitleTrack\";\n    }(i || (i = {})), function (t) {\n      t.MAIN = \"main\", t.AUDIO = \"audio\", t.SUBTITLE = \"subtitle\";\n    }(a || (a = {}));\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"a\", function () {\n      return i;\n    }), r.d(e, \"b\", function () {\n      return v;\n    }), r.d(e, \"c\", function () {\n      return g;\n    });\n    var i,\n        a = r(3),\n        n = r(11),\n        s = r(1),\n        o = r(15),\n        l = r(12);\n\n    function u(t, e) {\n      t.prototype = Object.create(e.prototype), t.prototype.constructor = t, d(t, e);\n    }\n\n    function d(t, e) {\n      return (d = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    function h(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    function f(t, e, r) {\n      return e && h(t.prototype, e), r && h(t, r), t;\n    }\n\n    !function (t) {\n      t.AUDIO = \"audio\", t.VIDEO = \"video\", t.AUDIOVIDEO = \"audiovideo\";\n    }(i || (i = {}));\n\n    var c = function () {\n      function t(t) {\n        var e;\n        this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = ((e = {})[i.AUDIO] = null, e[i.VIDEO] = null, e[i.AUDIOVIDEO] = null, e), this.baseurl = t;\n      }\n\n      return t.prototype.setByteRange = function (t, e) {\n        var r = t.split(\"@\", 2),\n            i = [];\n        1 === r.length ? i[0] = e ? e.byteRangeEndOffset : 0 : i[0] = parseInt(r[1]), i[1] = parseInt(r[0]) + i[0], this._byteRange = i;\n      }, f(t, [{\n        key: \"byteRange\",\n        get: function () {\n          return this._byteRange ? this._byteRange : [];\n        }\n      }, {\n        key: \"byteRangeStartOffset\",\n        get: function () {\n          return this.byteRange[0];\n        }\n      }, {\n        key: \"byteRangeEndOffset\",\n        get: function () {\n          return this.byteRange[1];\n        }\n      }, {\n        key: \"url\",\n        get: function () {\n          return !this._url && this.baseurl && this.relurl && (this._url = Object(n.buildAbsoluteURL)(this.baseurl, this.relurl, {\n            alwaysNormalize: !0\n          })), this._url || \"\";\n        },\n        set: function (t) {\n          this._url = t;\n        }\n      }]), t;\n    }(),\n        v = function (t) {\n      function e(e, r) {\n        var i;\n        return (i = t.call(this, r) || this)._decryptdata = null, i.rawProgramDateTime = null, i.programDateTime = null, i.tagList = [], i.duration = 0, i.sn = 0, i.levelkey = void 0, i.type = void 0, i.loader = null, i.level = -1, i.cc = 0, i.startPTS = void 0, i.endPTS = void 0, i.appendedPTS = void 0, i.startDTS = void 0, i.endDTS = void 0, i.start = 0, i.deltaPTS = void 0, i.maxStartPTS = void 0, i.minEndPTS = void 0, i.stats = new l.a(), i.urlId = 0, i.data = void 0, i.bitrateTest = !1, i.title = null, i.initSegment = null, i.type = e, i;\n      }\n\n      u(e, t);\n      var r = e.prototype;\n      return r.createInitializationVector = function (t) {\n        for (var e = new Uint8Array(16), r = 12; r < 16; r++) e[r] = t >> 8 * (15 - r) & 255;\n\n        return e;\n      }, r.setDecryptDataFromLevelKey = function (t, e) {\n        var r = t;\n        return \"AES-128\" === (null == t ? void 0 : t.method) && t.uri && !t.iv && ((r = o.a.fromURI(t.uri)).method = t.method, r.iv = this.createInitializationVector(e), r.keyFormat = \"identity\"), r;\n      }, r.setElementaryStreamInfo = function (t, e, r, i, a, n) {\n        void 0 === n && (n = !1);\n        var s = this.elementaryStreams,\n            o = s[t];\n        o ? (o.startPTS = Math.min(o.startPTS, e), o.endPTS = Math.max(o.endPTS, r), o.startDTS = Math.min(o.startDTS, i), o.endDTS = Math.max(o.endDTS, a)) : s[t] = {\n          startPTS: e,\n          endPTS: r,\n          startDTS: i,\n          endDTS: a,\n          partial: n\n        };\n      }, r.clearElementaryStreamInfo = function () {\n        var t = this.elementaryStreams;\n        t[i.AUDIO] = null, t[i.VIDEO] = null, t[i.AUDIOVIDEO] = null;\n      }, f(e, [{\n        key: \"decryptdata\",\n        get: function () {\n          if (!this.levelkey && !this._decryptdata) return null;\n\n          if (!this._decryptdata && this.levelkey) {\n            var t = this.sn;\n            \"number\" != typeof t && (this.levelkey && \"AES-128\" === this.levelkey.method && !this.levelkey.iv && s.b.warn('missing IV for initialization segment with method=\"' + this.levelkey.method + '\" - compliance issue'), t = 0), this._decryptdata = this.setDecryptDataFromLevelKey(this.levelkey, t);\n          }\n\n          return this._decryptdata;\n        }\n      }, {\n        key: \"end\",\n        get: function () {\n          return this.start + this.duration;\n        }\n      }, {\n        key: \"endProgramDateTime\",\n        get: function () {\n          if (null === this.programDateTime) return null;\n          if (!Object(a.a)(this.programDateTime)) return null;\n          var t = Object(a.a)(this.duration) ? this.duration : 0;\n          return this.programDateTime + 1e3 * t;\n        }\n      }, {\n        key: \"encrypted\",\n        get: function () {\n          var t;\n          return !(null === (t = this.decryptdata) || void 0 === t || !t.keyFormat || !this.decryptdata.uri);\n        }\n      }]), e;\n    }(c),\n        g = function (t) {\n      function e(e, r, i, a, n) {\n        var s;\n        (s = t.call(this, i) || this).fragOffset = 0, s.duration = 0, s.gap = !1, s.independent = !1, s.relurl = void 0, s.fragment = void 0, s.index = void 0, s.stats = new l.a(), s.duration = e.decimalFloatingPoint(\"DURATION\"), s.gap = e.bool(\"GAP\"), s.independent = e.bool(\"INDEPENDENT\"), s.relurl = e.enumeratedString(\"URI\"), s.fragment = r, s.index = a;\n        var o = e.enumeratedString(\"BYTERANGE\");\n        return o && s.setByteRange(o, n), n && (s.fragOffset = n.fragOffset + n.duration), s;\n      }\n\n      return u(e, t), f(e, [{\n        key: \"start\",\n        get: function () {\n          return this.fragment.start + this.fragOffset;\n        }\n      }, {\n        key: \"end\",\n        get: function () {\n          return this.start + this.duration;\n        }\n      }, {\n        key: \"loaded\",\n        get: function () {\n          var t = this.elementaryStreams;\n          return !!(t.audio || t.video || t.audiovideo);\n        }\n      }]), e;\n    }(c);\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"b\", function () {\n      return d;\n    }), r.d(e, \"g\", function () {\n      return h;\n    }), r.d(e, \"f\", function () {\n      return f;\n    }), r.d(e, \"d\", function () {\n      return c;\n    }), r.d(e, \"c\", function () {\n      return v;\n    }), r.d(e, \"e\", function () {\n      return p;\n    }), r.d(e, \"h\", function () {\n      return m;\n    }), r.d(e, \"a\", function () {\n      return y;\n    });\n    var i = r(8),\n        a = r(5),\n        n = Math.pow(2, 32) - 1,\n        s = [].push;\n\n    function o(t) {\n      return String.fromCharCode.apply(null, t);\n    }\n\n    function l(t, e) {\n      \"data\" in t && (e += t.start, t = t.data);\n      var r = t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3];\n      return r < 0 ? 4294967296 + r : r;\n    }\n\n    function u(t, e, r) {\n      \"data\" in t && (e += t.start, t = t.data), t[e] = r >> 24, t[e + 1] = r >> 16 & 255, t[e + 2] = r >> 8 & 255, t[e + 3] = 255 & r;\n    }\n\n    function d(t, e) {\n      var r,\n          i,\n          a,\n          n = [];\n      if (!e.length) return n;\n      \"data\" in t ? (r = t.data, i = t.start, a = t.end) : (i = 0, a = (r = t).byteLength);\n\n      for (var u = i; u < a;) {\n        var h = l(r, u),\n            f = h > 1 ? u + h : a;\n        if (o(r.subarray(u + 4, u + 8)) === e[0]) if (1 === e.length) n.push({\n          data: r,\n          start: u + 8,\n          end: f\n        });else {\n          var c = d({\n            data: r,\n            start: u + 8,\n            end: f\n          }, e.slice(1));\n          c.length && s.apply(n, c);\n        }\n        u = f;\n      }\n\n      return n;\n    }\n\n    function h(t) {\n      var e = d(t, [\"moov\"])[0],\n          r = e ? e.end : null,\n          i = d(t, [\"sidx\"]);\n      if (!i || !i[0]) return null;\n      var a = [],\n          n = i[0],\n          s = n.data[0],\n          o = 0 === s ? 8 : 16,\n          u = l(n, o);\n      o += 4;\n      o += 0 === s ? 8 : 16, o += 2;\n\n      var h = n.end + 0,\n          f = function (t, e) {\n        \"data\" in t && (e += t.start, t = t.data);\n        var r = t[e] << 8 | t[e + 1];\n        return r < 0 ? 65536 + r : r;\n      }(n, o);\n\n      o += 2;\n\n      for (var c = 0; c < f; c++) {\n        var v = o,\n            g = l(n, v);\n        v += 4;\n        var p = 2147483647 & g;\n        if (1 === (2147483648 & g) >>> 31) return console.warn(\"SIDX has hierarchical references (not supported)\"), null;\n        var m = l(n, v);\n        v += 4, a.push({\n          referenceSize: p,\n          subsegmentDuration: m,\n          info: {\n            duration: m / u,\n            start: h,\n            end: h + p - 1\n          }\n        }), h += p, o = v += 4;\n      }\n\n      return {\n        earliestPresentationTime: 0,\n        timescale: u,\n        version: s,\n        referencesCount: f,\n        references: a,\n        moovEndOffset: r\n      };\n    }\n\n    function f(t) {\n      for (var e = [], r = d(t, [\"moov\", \"trak\"]), i = 0; i < r.length; i++) {\n        var n = r[i],\n            s = d(n, [\"tkhd\"])[0];\n\n        if (s) {\n          var u = s.data[s.start],\n              h = 0 === u ? 12 : 20,\n              f = l(s, h),\n              c = d(n, [\"mdia\", \"mdhd\"])[0];\n\n          if (c) {\n            var v = l(c, h = 0 === (u = c.data[c.start]) ? 12 : 20),\n                g = d(n, [\"mdia\", \"hdlr\"])[0];\n\n            if (g) {\n              var p = o(g.data.subarray(g.start + 8, g.start + 12)),\n                  m = {\n                soun: a.a.AUDIO,\n                vide: a.a.VIDEO\n              }[p];\n\n              if (m) {\n                var y = d(n, [\"mdia\", \"minf\", \"stbl\", \"stsd\"])[0],\n                    b = void 0;\n                y && (b = o(y.data.subarray(y.start + 12, y.start + 16))), e[f] = {\n                  timescale: v,\n                  type: m\n                }, e[m] = {\n                  timescale: v,\n                  id: f,\n                  codec: b\n                };\n              }\n            }\n          }\n        }\n      }\n\n      return d(t, [\"moov\", \"mvex\", \"trex\"]).forEach(function (t) {\n        var r = l(t, 4),\n            i = e[r];\n        i && (i.default = {\n          duration: l(t, 12),\n          flags: l(t, 20)\n        });\n      }), e;\n    }\n\n    function c(t, e) {\n      return d(e, [\"moof\", \"traf\"]).reduce(function (e, r) {\n        var i = d(r, [\"tfdt\"])[0],\n            a = i.data[i.start],\n            n = d(r, [\"tfhd\"]).reduce(function (e, r) {\n          var n = l(r, 4),\n              s = t[n];\n\n          if (s) {\n            var o = l(i, 4);\n            1 === a && (o *= Math.pow(2, 32), o += l(i, 8));\n            var u = o / (s.timescale || 9e4);\n            if (isFinite(u) && (null === e || u < e)) return u;\n          }\n\n          return e;\n        }, null);\n        return null !== n && isFinite(n) && (null === e || n < e) ? n : e;\n      }, null) || 0;\n    }\n\n    function v(t, e) {\n      for (var r = 0, i = 0, n = 0, s = d(t, [\"moof\", \"traf\"]), o = 0; o < s.length; o++) {\n        var u = s[o],\n            f = d(u, [\"tfhd\"])[0],\n            c = e[l(f, 4)];\n\n        if (c) {\n          var v = c.default,\n              p = l(f, 0) | (null == v ? void 0 : v.flags),\n              m = null == v ? void 0 : v.duration;\n          8 & p && (m = l(f, 2 & p ? 12 : 8));\n\n          for (var y = c.timescale || 9e4, b = d(u, [\"trun\"]), T = 0; T < b.length; T++) {\n            if (!(r = g(b[T])) && m) r = m * l(b[T], 4);\n            c.type === a.a.VIDEO ? i += r / y : c.type === a.a.AUDIO && (n += r / y);\n          }\n        }\n      }\n\n      if (0 === i && 0 === n) {\n        var E = h(t);\n        if (null != E && E.references) return E.references.reduce(function (t, e) {\n          return t + e.info.duration || 0;\n        }, 0);\n      }\n\n      return i || n;\n    }\n\n    function g(t) {\n      var e = l(t, 0),\n          r = 8;\n      1 & e && (r += 4), 4 & e && (r += 4);\n\n      for (var i = 0, a = l(t, 4), n = 0; n < a; n++) {\n        if (256 & e) i += l(t, r), r += 4;\n        512 & e && (r += 4), 1024 & e && (r += 4), 2048 & e && (r += 4);\n      }\n\n      return i;\n    }\n\n    function p(t, e, r) {\n      d(e, [\"moof\", \"traf\"]).forEach(function (e) {\n        d(e, [\"tfhd\"]).forEach(function (i) {\n          var a = l(i, 4),\n              s = t[a];\n\n          if (s) {\n            var o = s.timescale || 9e4;\n            d(e, [\"tfdt\"]).forEach(function (t) {\n              var e = t.data[t.start],\n                  i = l(t, 4);\n              if (0 === e) u(t, 4, i - r * o);else {\n                i *= Math.pow(2, 32), i += l(t, 8), i -= r * o, i = Math.max(i, 0);\n                var a = Math.floor(i / (n + 1)),\n                    s = Math.floor(i % (n + 1));\n                u(t, 4, a), u(t, 8, s);\n              }\n            });\n          }\n        });\n      });\n    }\n\n    function m(t) {\n      var e = {\n        valid: null,\n        remainder: null\n      },\n          r = d(t, [\"moof\"]);\n      if (!r) return e;\n      if (r.length < 2) return e.remainder = t, e;\n      var a = r[r.length - 1];\n      return e.valid = Object(i.a)(t, 0, a.start - 8), e.remainder = Object(i.a)(t, a.start - 8), e;\n    }\n\n    function y(t, e) {\n      var r = new Uint8Array(t.length + e.length);\n      return r.set(t), r.set(e, t.length), r;\n    }\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"b\", function () {\n      return s;\n    }), r.d(e, \"a\", function () {\n      return l;\n    }), r.d(e, \"d\", function () {\n      return u;\n    }), r.d(e, \"e\", function () {\n      return d;\n    }), r.d(e, \"c\", function () {\n      return f;\n    }), r.d(e, \"f\", function () {\n      return y;\n    });\n\n    var i,\n        a = function (t, e) {\n      return e + 10 <= t.length && 73 === t[e] && 68 === t[e + 1] && 51 === t[e + 2] && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128;\n    },\n        n = function (t, e) {\n      return e + 10 <= t.length && 51 === t[e] && 68 === t[e + 1] && 73 === t[e + 2] && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128;\n    },\n        s = function (t, e) {\n      for (var r = e, i = 0; a(t, e);) {\n        i += 10, i += o(t, e + 6), n(t, e + 10) && (i += 10), e += i;\n      }\n\n      if (i > 0) return t.subarray(r, r + i);\n    },\n        o = function (t, e) {\n      var r = 0;\n      return r = (127 & t[e]) << 21, r |= (127 & t[e + 1]) << 14, r |= (127 & t[e + 2]) << 7, r |= 127 & t[e + 3];\n    },\n        l = function (t, e) {\n      return a(t, e) && o(t, e + 6) + 10 <= t.length - e;\n    },\n        u = function (t) {\n      for (var e = f(t), r = 0; r < e.length; r++) {\n        var i = e[r];\n        if (d(i)) return m(i);\n      }\n    },\n        d = function (t) {\n      return t && \"PRIV\" === t.key && \"com.apple.streaming.transportStreamTimestamp\" === t.info;\n    },\n        h = function (t) {\n      var e = String.fromCharCode(t[0], t[1], t[2], t[3]),\n          r = o(t, 4);\n      return {\n        type: e,\n        size: r,\n        data: t.subarray(10, 10 + r)\n      };\n    },\n        f = function (t) {\n      for (var e = 0, r = []; a(t, e);) {\n        for (var i = o(t, e + 6), s = (e += 10) + i; e + 8 < s;) {\n          var l = h(t.subarray(e)),\n              u = c(l);\n          u && r.push(u), e += l.size + 10;\n        }\n\n        n(t, e) && (e += 10);\n      }\n\n      return r;\n    },\n        c = function (t) {\n      return \"PRIV\" === t.type ? v(t) : \"W\" === t.type[0] ? p(t) : g(t);\n    },\n        v = function (t) {\n      if (!(t.size < 2)) {\n        var e = y(t.data, !0),\n            r = new Uint8Array(t.data.subarray(e.length + 1));\n        return {\n          key: t.type,\n          info: e,\n          data: r.buffer\n        };\n      }\n    },\n        g = function (t) {\n      if (!(t.size < 2)) {\n        if (\"TXXX\" === t.type) {\n          var e = 1,\n              r = y(t.data.subarray(e), !0);\n          e += r.length + 1;\n          var i = y(t.data.subarray(e));\n          return {\n            key: t.type,\n            info: r,\n            data: i\n          };\n        }\n\n        var a = y(t.data.subarray(1));\n        return {\n          key: t.type,\n          data: a\n        };\n      }\n    },\n        p = function (t) {\n      if (\"WXXX\" === t.type) {\n        if (t.size < 2) return;\n        var e = 1,\n            r = y(t.data.subarray(e), !0);\n        e += r.length + 1;\n        var i = y(t.data.subarray(e));\n        return {\n          key: t.type,\n          info: r,\n          data: i\n        };\n      }\n\n      var a = y(t.data);\n      return {\n        key: t.type,\n        data: a\n      };\n    },\n        m = function (t) {\n      if (8 === t.data.byteLength) {\n        var e = new Uint8Array(t.data),\n            r = 1 & e[3],\n            i = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7];\n        return i /= 45, r && (i += 47721858.84), Math.round(i);\n      }\n    },\n        y = function (t, e) {\n      void 0 === e && (e = !1);\n      var r = b();\n\n      if (r) {\n        var i = r.decode(t);\n\n        if (e) {\n          var a = i.indexOf(\"\\0\");\n          return -1 !== a ? i.substring(0, a) : i;\n        }\n\n        return i.replace(/\\0/g, \"\");\n      }\n\n      for (var n, s, o, l = t.length, u = \"\", d = 0; d < l;) {\n        if (0 === (n = t[d++]) && e) return u;\n        if (0 !== n && 3 !== n) switch (n >> 4) {\n          case 0:\n          case 1:\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n            u += String.fromCharCode(n);\n            break;\n\n          case 12:\n          case 13:\n            s = t[d++], u += String.fromCharCode((31 & n) << 6 | 63 & s);\n            break;\n\n          case 14:\n            s = t[d++], o = t[d++], u += String.fromCharCode((15 & n) << 12 | (63 & s) << 6 | (63 & o) << 0);\n        }\n      }\n\n      return u;\n    };\n\n    function b() {\n      return i || void 0 === self.TextDecoder || (i = new self.TextDecoder(\"utf-8\")), i;\n    }\n  }, function (t, e, r) {\n    \"use strict\";\n\n    function i(t, e, r) {\n      return Uint8Array.prototype.slice ? t.slice(e, r) : new Uint8Array(Array.prototype.slice.call(t, e, r));\n    }\n\n    r.d(e, \"a\", function () {\n      return i;\n    });\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"c\", function () {\n      return St;\n    }), r.d(e, \"d\", function () {\n      return At;\n    }), r.d(e, \"a\", function () {\n      return Rt;\n    }), r.d(e, \"b\", function () {\n      return Dt;\n    });\n    var i = r(0),\n        a = r(2),\n        n = r(14),\n        s = r(3),\n        o = r(7);\n\n    var l = r(6),\n        u = r(8),\n        d = function () {\n      function t() {\n        this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.initPTS = null;\n      }\n\n      var e = t.prototype;\n      return e.resetInitSegment = function (t, e, r) {\n        this._id3Track = {\n          type: \"id3\",\n          id: 3,\n          pid: -1,\n          inputTimeScale: 9e4,\n          sequenceNumber: 0,\n          samples: [],\n          dropped: 0\n        };\n      }, e.resetTimeStamp = function () {}, e.resetContiguity = function () {}, e.canParse = function (t, e) {\n        return !1;\n      }, e.appendFrame = function (t, e, r) {}, e.demux = function (t, e) {\n        this.cachedData && (t = Object(l.a)(this.cachedData, t), this.cachedData = null);\n        var r,\n            i,\n            a = o.b(t, 0),\n            n = a ? a.length : 0,\n            s = this._audioTrack,\n            d = this._id3Track,\n            f = a ? o.d(a) : void 0,\n            c = t.length;\n\n        for (0 !== this.frameIndex && null !== this.initPTS || (this.initPTS = h(f, e)), a && a.length > 0 && d.samples.push({\n          pts: this.initPTS,\n          dts: this.initPTS,\n          data: a\n        }), i = this.initPTS; n < c;) {\n          if (this.canParse(t, n)) {\n            var v = this.appendFrame(s, t, n);\n            v ? (this.frameIndex++, i = v.sample.pts, r = n += v.length) : n = c;\n          } else o.a(t, n) ? (a = o.b(t, n), d.samples.push({\n            pts: i,\n            dts: i,\n            data: a\n          }), r = n += a.length) : n++;\n\n          if (n === c && r !== c) {\n            var g = Object(u.a)(t, r);\n            this.cachedData ? this.cachedData = Object(l.a)(this.cachedData, g) : this.cachedData = g;\n          }\n        }\n\n        return {\n          audioTrack: s,\n          avcTrack: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          },\n          id3Track: d,\n          textTrack: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          }\n        };\n      }, e.demuxSampleAes = function (t, e, r) {\n        return Promise.reject(new Error(\"[\" + this + \"] This demuxer does not support Sample-AES decryption\"));\n      }, e.flush = function (t) {\n        var e = this.cachedData;\n        return e && (this.cachedData = null, this.demux(e, 0)), this.frameIndex = 0, {\n          audioTrack: this._audioTrack,\n          avcTrack: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          },\n          id3Track: this._id3Track,\n          textTrack: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          }\n        };\n      }, e.destroy = function () {}, t;\n    }(),\n        h = function (t, e) {\n      return Object(s.a)(t) ? 90 * t : 9e4 * e;\n    },\n        f = d,\n        c = r(1);\n\n    function v(t, e) {\n      return 255 === t[e] && 240 == (246 & t[e + 1]);\n    }\n\n    function g(t, e) {\n      return 1 & t[e + 1] ? 7 : 9;\n    }\n\n    function p(t, e) {\n      return (3 & t[e + 3]) << 11 | t[e + 4] << 3 | (224 & t[e + 5]) >>> 5;\n    }\n\n    function m(t, e) {\n      return e + 1 < t.length && v(t, e);\n    }\n\n    function y(t, e) {\n      if (m(t, e)) {\n        var r = g(t, e);\n        if (e + r >= t.length) return !1;\n        var i = p(t, e);\n        if (i <= r) return !1;\n        var a = e + i;\n        return a === t.length || m(t, a);\n      }\n\n      return !1;\n    }\n\n    function b(t, e, r, n, s) {\n      if (!t.samplerate) {\n        var o = function (t, e, r, n) {\n          var s,\n              o,\n              l,\n              u,\n              d = navigator.userAgent.toLowerCase(),\n              h = n,\n              f = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];\n          s = 1 + ((192 & e[r + 2]) >>> 6);\n          var v = (60 & e[r + 2]) >>> 2;\n          if (!(v > f.length - 1)) return l = (1 & e[r + 2]) << 2, l |= (192 & e[r + 3]) >>> 6, c.b.log(\"manifest codec:\" + n + \", ADTS type:\" + s + \", samplingIndex:\" + v), /firefox/i.test(d) ? v >= 6 ? (s = 5, u = new Array(4), o = v - 3) : (s = 2, u = new Array(2), o = v) : -1 !== d.indexOf(\"android\") ? (s = 2, u = new Array(2), o = v) : (s = 5, u = new Array(4), n && (-1 !== n.indexOf(\"mp4a.40.29\") || -1 !== n.indexOf(\"mp4a.40.5\")) || !n && v >= 6 ? o = v - 3 : ((n && -1 !== n.indexOf(\"mp4a.40.2\") && (v >= 6 && 1 === l || /vivaldi/i.test(d)) || !n && 1 === l) && (s = 2, u = new Array(2)), o = v)), u[0] = s << 3, u[0] |= (14 & v) >> 1, u[1] |= (1 & v) << 7, u[1] |= l << 3, 5 === s && (u[1] |= (14 & o) >> 1, u[2] = (1 & o) << 7, u[2] |= 8, u[3] = 0), {\n            config: u,\n            samplerate: f[v],\n            channelCount: l,\n            codec: \"mp4a.40.\" + s,\n            manifestCodec: h\n          };\n          t.trigger(i.a.ERROR, {\n            type: a.b.MEDIA_ERROR,\n            details: a.a.FRAG_PARSING_ERROR,\n            fatal: !0,\n            reason: \"invalid ADTS sampling index:\" + v\n          });\n        }(e, r, n, s);\n\n        if (!o) return;\n        t.config = o.config, t.samplerate = o.samplerate, t.channelCount = o.channelCount, t.codec = o.codec, t.manifestCodec = o.manifestCodec, c.b.log(\"parsed codec:\" + t.codec + \", rate:\" + o.samplerate + \", channels:\" + o.channelCount);\n      }\n    }\n\n    function T(t) {\n      return 9216e4 / t;\n    }\n\n    function E(t, e, r, i, a) {\n      var n = function (t, e, r, i, a) {\n        var n = g(t, e),\n            s = p(t, e);\n        if ((s -= n) > 0) return {\n          headerLength: n,\n          frameLength: s,\n          stamp: r + i * a\n        };\n      }(e, r, i, a, T(t.samplerate));\n\n      if (n) {\n        var s,\n            o = n.frameLength,\n            l = n.headerLength,\n            u = n.stamp,\n            d = l + o,\n            h = Math.max(0, r + d - e.length);\n        h ? (s = new Uint8Array(d - l)).set(e.subarray(r + l, e.length), 0) : s = e.subarray(r + l, r + d);\n        var f = {\n          unit: s,\n          pts: u\n        };\n        return h || t.samples.push(f), {\n          sample: f,\n          length: d,\n          missing: h\n        };\n      }\n    }\n\n    function S(t, e) {\n      return (S = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    var L = function (t) {\n      var e, r;\n\n      function i(e, r) {\n        var i;\n        return (i = t.call(this) || this).observer = void 0, i.config = void 0, i.observer = e, i.config = r, i;\n      }\n\n      r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, S(e, r);\n      var a = i.prototype;\n      return a.resetInitSegment = function (e, r, i) {\n        t.prototype.resetInitSegment.call(this, e, r, i), this._audioTrack = {\n          container: \"audio/adts\",\n          type: \"audio\",\n          id: 2,\n          pid: -1,\n          sequenceNumber: 0,\n          isAAC: !0,\n          samples: [],\n          manifestCodec: e,\n          duration: i,\n          inputTimeScale: 9e4,\n          dropped: 0\n        };\n      }, i.probe = function (t) {\n        if (!t) return !1;\n\n        for (var e = (o.b(t, 0) || []).length, r = t.length; e < r; e++) if (y(t, e)) return c.b.log(\"ADTS sync word found !\"), !0;\n\n        return !1;\n      }, a.canParse = function (t, e) {\n        return function (t, e) {\n          return function (t, e) {\n            return e + 5 < t.length;\n          }(t, e) && v(t, e) && p(t, e) <= t.length - e;\n        }(t, e);\n      }, a.appendFrame = function (t, e, r) {\n        b(t, this.observer, e, r, t.manifestCodec);\n        var i = E(t, e, r, this.initPTS, this.frameIndex);\n        if (i && 0 === i.missing) return i;\n      }, i;\n    }(f);\n\n    L.minProbeByteLength = 9;\n\n    var A = L,\n        R = function () {\n      function t(t, e) {\n        this.remainderData = null, this.config = void 0, this.config = e;\n      }\n\n      var e = t.prototype;\n      return e.resetTimeStamp = function () {}, e.resetInitSegment = function () {}, e.resetContiguity = function () {}, t.probe = function (t) {\n        return Object(l.b)({\n          data: t,\n          start: 0,\n          end: Math.min(t.length, 16384)\n        }, [\"moof\"]).length > 0;\n      }, e.demux = function (t) {\n        var e = t,\n            r = {\n          type: \"\",\n          id: -1,\n          pid: -1,\n          inputTimeScale: 9e4,\n          sequenceNumber: -1,\n          samples: [],\n          dropped: 0\n        };\n\n        if (this.config.progressive) {\n          this.remainderData && (e = Object(l.a)(this.remainderData, t));\n          var i = Object(l.h)(e);\n          this.remainderData = i.remainder, r.samples = i.valid || new Uint8Array();\n        } else r.samples = e;\n\n        return {\n          audioTrack: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          },\n          avcTrack: r,\n          id3Track: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          },\n          textTrack: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          }\n        };\n      }, e.flush = function () {\n        var t = {\n          type: \"\",\n          id: -1,\n          pid: -1,\n          inputTimeScale: 9e4,\n          sequenceNumber: -1,\n          samples: [],\n          dropped: 0\n        };\n        return t.samples = this.remainderData || new Uint8Array(), this.remainderData = null, {\n          audioTrack: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          },\n          avcTrack: t,\n          id3Track: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          },\n          textTrack: {\n            type: \"\",\n            id: -1,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: -1,\n            samples: [],\n            dropped: 0\n          }\n        };\n      }, e.demuxSampleAes = function (t, e, r) {\n        return Promise.reject(new Error(\"The MP4 demuxer does not support SAMPLE-AES decryption\"));\n      }, e.destroy = function () {}, t;\n    }();\n\n    R.minProbeByteLength = 1024;\n    var D = R,\n        _ = null,\n        k = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],\n        x = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],\n        C = [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]],\n        w = [0, 1, 1, 4];\n\n    function O(t, e, r, i, a) {\n      if (!(r + 24 > e.length)) {\n        var n = I(e, r);\n\n        if (n && r + n.frameLength <= e.length) {\n          var s = i + a * (9e4 * n.samplesPerFrame / n.sampleRate),\n              o = {\n            unit: e.subarray(r, r + n.frameLength),\n            pts: s,\n            dts: s\n          };\n          return t.config = [], t.channelCount = n.channelCount, t.samplerate = n.sampleRate, t.samples.push(o), {\n            sample: o,\n            length: n.frameLength,\n            missing: 0\n          };\n        }\n      }\n    }\n\n    function I(t, e) {\n      var r = t[e + 1] >> 3 & 3,\n          i = t[e + 1] >> 1 & 3,\n          a = t[e + 2] >> 4 & 15,\n          n = t[e + 2] >> 2 & 3;\n\n      if (1 !== r && 0 !== a && 15 !== a && 3 !== n) {\n        var s = t[e + 2] >> 1 & 1,\n            o = t[e + 3] >> 6,\n            l = 1e3 * k[14 * (3 === r ? 3 - i : 3 === i ? 3 : 4) + a - 1],\n            u = x[3 * (3 === r ? 0 : 2 === r ? 1 : 2) + n],\n            d = 3 === o ? 1 : 2,\n            h = C[r][i],\n            f = w[i],\n            c = 8 * h * f,\n            v = Math.floor(h * l / u + s) * f;\n\n        if (null === _) {\n          var g = (navigator.userAgent || \"\").match(/Chrome\\/(\\d+)/i);\n          _ = g ? parseInt(g[1]) : 0;\n        }\n\n        return !!_ && _ <= 87 && 2 === i && l >= 224e3 && 0 === o && (t[e + 3] = 128 | t[e + 3]), {\n          sampleRate: u,\n          channelCount: d,\n          frameLength: v,\n          samplesPerFrame: c\n        };\n      }\n    }\n\n    function P(t, e) {\n      return 255 === t[e] && 224 == (224 & t[e + 1]) && 0 != (6 & t[e + 1]);\n    }\n\n    function F(t, e) {\n      return e + 1 < t.length && P(t, e);\n    }\n\n    function M(t, e) {\n      if (e + 1 < t.length && P(t, e)) {\n        var r = I(t, e),\n            i = 4;\n        null != r && r.frameLength && (i = r.frameLength);\n        var a = e + i;\n        return a === t.length || F(t, a);\n      }\n\n      return !1;\n    }\n\n    var N = function () {\n      function t(t) {\n        this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = t, this.bytesAvailable = t.byteLength, this.word = 0, this.bitsAvailable = 0;\n      }\n\n      var e = t.prototype;\n      return e.loadWord = function () {\n        var t = this.data,\n            e = this.bytesAvailable,\n            r = t.byteLength - e,\n            i = new Uint8Array(4),\n            a = Math.min(4, e);\n        if (0 === a) throw new Error(\"no bytes available\");\n        i.set(t.subarray(r, r + a)), this.word = new DataView(i.buffer).getUint32(0), this.bitsAvailable = 8 * a, this.bytesAvailable -= a;\n      }, e.skipBits = function (t) {\n        var e;\n        this.bitsAvailable > t ? (this.word <<= t, this.bitsAvailable -= t) : (t -= this.bitsAvailable, t -= (e = t >> 3) >> 3, this.bytesAvailable -= e, this.loadWord(), this.word <<= t, this.bitsAvailable -= t);\n      }, e.readBits = function (t) {\n        var e = Math.min(this.bitsAvailable, t),\n            r = this.word >>> 32 - e;\n        return t > 32 && c.b.error(\"Cannot read more than 32 bits at a time\"), this.bitsAvailable -= e, this.bitsAvailable > 0 ? this.word <<= e : this.bytesAvailable > 0 && this.loadWord(), (e = t - e) > 0 && this.bitsAvailable ? r << e | this.readBits(e) : r;\n      }, e.skipLZ = function () {\n        var t;\n\n        for (t = 0; t < this.bitsAvailable; ++t) if (0 != (this.word & 2147483648 >>> t)) return this.word <<= t, this.bitsAvailable -= t, t;\n\n        return this.loadWord(), t + this.skipLZ();\n      }, e.skipUEG = function () {\n        this.skipBits(1 + this.skipLZ());\n      }, e.skipEG = function () {\n        this.skipBits(1 + this.skipLZ());\n      }, e.readUEG = function () {\n        var t = this.skipLZ();\n        return this.readBits(t + 1) - 1;\n      }, e.readEG = function () {\n        var t = this.readUEG();\n        return 1 & t ? 1 + t >>> 1 : -1 * (t >>> 1);\n      }, e.readBoolean = function () {\n        return 1 === this.readBits(1);\n      }, e.readUByte = function () {\n        return this.readBits(8);\n      }, e.readUShort = function () {\n        return this.readBits(16);\n      }, e.readUInt = function () {\n        return this.readBits(32);\n      }, e.skipScalingList = function (t) {\n        for (var e = 8, r = 8, i = 0; i < t; i++) 0 !== r && (r = (e + this.readEG() + 256) % 256), e = 0 === r ? e : r;\n      }, e.readSPS = function () {\n        var t,\n            e,\n            r,\n            i = 0,\n            a = 0,\n            n = 0,\n            s = 0,\n            o = this.readUByte.bind(this),\n            l = this.readBits.bind(this),\n            u = this.readUEG.bind(this),\n            d = this.readBoolean.bind(this),\n            h = this.skipBits.bind(this),\n            f = this.skipEG.bind(this),\n            c = this.skipUEG.bind(this),\n            v = this.skipScalingList.bind(this);\n        o();\n        var g = o();\n\n        if (l(5), h(3), o(), c(), 100 === g || 110 === g || 122 === g || 244 === g || 44 === g || 83 === g || 86 === g || 118 === g || 128 === g) {\n          var p = u();\n          if (3 === p && h(1), c(), c(), h(1), d()) for (e = 3 !== p ? 8 : 12, r = 0; r < e; r++) d() && v(r < 6 ? 16 : 64);\n        }\n\n        c();\n        var m = u();\n        if (0 === m) u();else if (1 === m) for (h(1), f(), f(), t = u(), r = 0; r < t; r++) f();\n        c(), h(1);\n        var y = u(),\n            b = u(),\n            T = l(1);\n        0 === T && h(1), h(1), d() && (i = u(), a = u(), n = u(), s = u());\n        var E = [1, 1];\n        if (d() && d()) switch (o()) {\n          case 1:\n            E = [1, 1];\n            break;\n\n          case 2:\n            E = [12, 11];\n            break;\n\n          case 3:\n            E = [10, 11];\n            break;\n\n          case 4:\n            E = [16, 11];\n            break;\n\n          case 5:\n            E = [40, 33];\n            break;\n\n          case 6:\n            E = [24, 11];\n            break;\n\n          case 7:\n            E = [20, 11];\n            break;\n\n          case 8:\n            E = [32, 11];\n            break;\n\n          case 9:\n            E = [80, 33];\n            break;\n\n          case 10:\n            E = [18, 11];\n            break;\n\n          case 11:\n            E = [15, 11];\n            break;\n\n          case 12:\n            E = [64, 33];\n            break;\n\n          case 13:\n            E = [160, 99];\n            break;\n\n          case 14:\n            E = [4, 3];\n            break;\n\n          case 15:\n            E = [3, 2];\n            break;\n\n          case 16:\n            E = [2, 1];\n            break;\n\n          case 255:\n            E = [o() << 8 | o(), o() << 8 | o()];\n        }\n        return {\n          width: Math.ceil(16 * (y + 1) - 2 * i - 2 * a),\n          height: (2 - T) * (b + 1) * 16 - (T ? 2 : 4) * (n + s),\n          pixelRatio: E\n        };\n      }, e.readSliceType = function () {\n        return this.readUByte(), this.readUEG(), this.readUEG();\n      }, t;\n    }(),\n        B = function () {\n      function t(t, e, r) {\n        this.keyData = void 0, this.decrypter = void 0, this.keyData = r, this.decrypter = new n.a(t, e, {\n          removePKCS7Padding: !1\n        });\n      }\n\n      var e = t.prototype;\n      return e.decryptBuffer = function (t, e) {\n        this.decrypter.decrypt(t, this.keyData.key.buffer, this.keyData.iv.buffer, e);\n      }, e.decryptAacSample = function (t, e, r, i) {\n        var a = t[e].unit,\n            n = a.subarray(16, a.length - a.length % 16),\n            s = n.buffer.slice(n.byteOffset, n.byteOffset + n.length),\n            o = this;\n        this.decryptBuffer(s, function (n) {\n          var s = new Uint8Array(n);\n          a.set(s, 16), i || o.decryptAacSamples(t, e + 1, r);\n        });\n      }, e.decryptAacSamples = function (t, e, r) {\n        for (;; e++) {\n          if (e >= t.length) return void r();\n\n          if (!(t[e].unit.length < 32)) {\n            var i = this.decrypter.isSync();\n            if (this.decryptAacSample(t, e, r, i), !i) return;\n          }\n        }\n      }, e.getAvcEncryptedData = function (t) {\n        for (var e = 16 * Math.floor((t.length - 48) / 160) + 16, r = new Int8Array(e), i = 0, a = 32; a < t.length - 16; a += 160, i += 16) r.set(t.subarray(a, a + 16), i);\n\n        return r;\n      }, e.getAvcDecryptedUnit = function (t, e) {\n        for (var r = new Uint8Array(e), i = 0, a = 32; a < t.length - 16; a += 160, i += 16) t.set(r.subarray(i, i + 16), a);\n\n        return t;\n      }, e.decryptAvcSample = function (t, e, r, i, a, n) {\n        var s = X(a.data),\n            o = this.getAvcEncryptedData(s),\n            l = this;\n        this.decryptBuffer(o.buffer, function (o) {\n          a.data = l.getAvcDecryptedUnit(s, o), n || l.decryptAvcSamples(t, e, r + 1, i);\n        });\n      }, e.decryptAvcSamples = function (t, e, r, i) {\n        if (t instanceof Uint8Array) throw new Error(\"Cannot decrypt samples of type Uint8Array\");\n\n        for (;; e++, r = 0) {\n          if (e >= t.length) return void i();\n\n          for (var a = t[e].units; !(r >= a.length); r++) {\n            var n = a[r];\n\n            if (!(n.data.length <= 48 || 1 !== n.type && 5 !== n.type)) {\n              var s = this.decrypter.isSync();\n              if (this.decryptAvcSample(t, e, r, i, n, s), !s) return;\n            }\n          }\n        }\n      }, t;\n    }(),\n        U = {\n      video: 1,\n      audio: 2,\n      id3: 3,\n      text: 4\n    },\n        G = function () {\n      function t(t, e, r) {\n        this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this.aacLastPTS = null, this._initPTS = null, this._initDTS = null, this._pmtId = -1, this._avcTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.observer = t, this.config = e, this.typeSupported = r;\n      }\n\n      t.probe = function (e) {\n        var r = t.syncOffset(e);\n        return !(r < 0) && (r && c.b.warn(\"MPEG2-TS detected but first sync word found @ offset \" + r + \", junk ahead ?\"), !0);\n      }, t.syncOffset = function (t) {\n        for (var e = Math.min(1e3, t.length - 564), r = 0; r < e;) {\n          if (71 === t[r] && 71 === t[r + 188] && 71 === t[r + 376]) return r;\n          r++;\n        }\n\n        return -1;\n      }, t.createTrack = function (t, e) {\n        return {\n          container: \"video\" === t || \"audio\" === t ? \"video/mp2t\" : void 0,\n          type: t,\n          id: U[t],\n          pid: -1,\n          inputTimeScale: 9e4,\n          sequenceNumber: 0,\n          samples: [],\n          dropped: 0,\n          duration: \"audio\" === t ? e : void 0\n        };\n      };\n      var e = t.prototype;\n      return e.resetInitSegment = function (e, r, i) {\n        this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = t.createTrack(\"video\", i), this._audioTrack = t.createTrack(\"audio\", i), this._id3Track = t.createTrack(\"id3\", i), this._txtTrack = t.createTrack(\"text\", i), this._audioTrack.isAAC = !0, this.aacOverFlow = null, this.aacLastPTS = null, this.avcSample = null, this.audioCodec = e, this.videoCodec = r, this._duration = i;\n      }, e.resetTimeStamp = function () {}, e.resetContiguity = function () {\n        var t = this._audioTrack,\n            e = this._avcTrack,\n            r = this._id3Track;\n        t && (t.pesData = null), e && (e.pesData = null), r && (r.pesData = null), this.aacOverFlow = null, this.aacLastPTS = null;\n      }, e.demux = function (e, r, n, s) {\n        var o;\n        void 0 === n && (n = !1), void 0 === s && (s = !1), n || (this.sampleAes = null);\n        var u = this._avcTrack,\n            d = this._audioTrack,\n            h = this._id3Track,\n            f = u.pid,\n            v = u.pesData,\n            g = d.pid,\n            p = h.pid,\n            m = d.pesData,\n            y = h.pesData,\n            b = !1,\n            T = this.pmtParsed,\n            E = this._pmtId,\n            S = e.length;\n        if (this.remainderData && (S = (e = Object(l.a)(this.remainderData, e)).length, this.remainderData = null), S < 188 && !s) return this.remainderData = e, {\n          audioTrack: d,\n          avcTrack: u,\n          id3Track: h,\n          textTrack: this._txtTrack\n        };\n        var L = Math.max(0, t.syncOffset(e));\n        (S -= (S + L) % 188) < e.byteLength && !s && (this.remainderData = new Uint8Array(e.buffer, S, e.buffer.byteLength - S));\n\n        for (var A = 0, R = L; R < S; R += 188) if (71 === e[R]) {\n          var D = !!(64 & e[R + 1]),\n              _ = ((31 & e[R + 1]) << 8) + e[R + 2],\n              k = void 0;\n\n          if ((48 & e[R + 3]) >> 4 > 1) {\n            if ((k = R + 5 + e[R + 4]) === R + 188) continue;\n          } else k = R + 4;\n\n          switch (_) {\n            case f:\n              D && (v && (o = V(v)) && this.parseAVCPES(o, !1), v = {\n                data: [],\n                size: 0\n              }), v && (v.data.push(e.subarray(k, R + 188)), v.size += R + 188 - k);\n              break;\n\n            case g:\n              D && (m && (o = V(m)) && (d.isAAC ? this.parseAACPES(o) : this.parseMPEGPES(o)), m = {\n                data: [],\n                size: 0\n              }), m && (m.data.push(e.subarray(k, R + 188)), m.size += R + 188 - k);\n              break;\n\n            case p:\n              D && (y && (o = V(y)) && this.parseID3PES(o), y = {\n                data: [],\n                size: 0\n              }), y && (y.data.push(e.subarray(k, R + 188)), y.size += R + 188 - k);\n              break;\n\n            case 0:\n              D && (k += e[k] + 1), E = this._pmtId = H(e, k);\n              break;\n\n            case E:\n              D && (k += e[k] + 1);\n              var x = K(e, k, !0 === this.typeSupported.mpeg || !0 === this.typeSupported.mp3, n);\n              (f = x.avc) > 0 && (u.pid = f), (g = x.audio) > 0 && (d.pid = g, d.isAAC = x.isAAC), (p = x.id3) > 0 && (h.pid = p), b && !T && (c.b.log(\"reparse from beginning\"), b = !1, R = L - 188), T = this.pmtParsed = !0;\n              break;\n\n            case 17:\n            case 8191:\n              break;\n\n            default:\n              b = !0;\n          }\n        } else A++;\n\n        A > 0 && this.observer.emit(i.a.ERROR, i.a.ERROR, {\n          type: a.b.MEDIA_ERROR,\n          details: a.a.FRAG_PARSING_ERROR,\n          fatal: !1,\n          reason: \"Found \" + A + \" TS packet/s that do not start with 0x47\"\n        }), u.pesData = v, d.pesData = m, h.pesData = y;\n        var C = {\n          audioTrack: d,\n          avcTrack: u,\n          id3Track: h,\n          textTrack: this._txtTrack\n        };\n        return s && this.extractRemainingSamples(C), C;\n      }, e.flush = function () {\n        var t,\n            e = this.remainderData;\n        return this.remainderData = null, t = e ? this.demux(e, -1, !1, !0) : {\n          audioTrack: this._audioTrack,\n          avcTrack: this._avcTrack,\n          textTrack: this._txtTrack,\n          id3Track: this._id3Track\n        }, this.extractRemainingSamples(t), this.sampleAes ? this.decrypt(t, this.sampleAes) : t;\n      }, e.extractRemainingSamples = function (t) {\n        var e,\n            r = t.audioTrack,\n            i = t.avcTrack,\n            a = t.id3Track,\n            n = i.pesData,\n            s = r.pesData,\n            o = a.pesData;\n        n && (e = V(n)) ? (this.parseAVCPES(e, !0), i.pesData = null) : i.pesData = n, s && (e = V(s)) ? (r.isAAC ? this.parseAACPES(e) : this.parseMPEGPES(e), r.pesData = null) : (null != s && s.size && c.b.log(\"last AAC PES packet truncated,might overlap between fragments\"), r.pesData = s), o && (e = V(o)) ? (this.parseID3PES(e), a.pesData = null) : a.pesData = o;\n      }, e.demuxSampleAes = function (t, e, r) {\n        var i = this.demux(t, r, !0, !this.config.progressive),\n            a = this.sampleAes = new B(this.observer, this.config, e);\n        return this.decrypt(i, a);\n      }, e.decrypt = function (t, e) {\n        return new Promise(function (r) {\n          var i = t.audioTrack,\n              a = t.avcTrack;\n          i.samples && i.isAAC ? e.decryptAacSamples(i.samples, 0, function () {\n            a.samples ? e.decryptAvcSamples(a.samples, 0, 0, function () {\n              r(t);\n            }) : r(t);\n          }) : a.samples && e.decryptAvcSamples(a.samples, 0, 0, function () {\n            r(t);\n          });\n        });\n      }, e.destroy = function () {\n        this._initPTS = this._initDTS = null, this._duration = 0;\n      }, e.parseAVCPES = function (t, e) {\n        var r,\n            i = this,\n            a = this._avcTrack,\n            n = this.parseAVCNALu(t.data),\n            s = this.avcSample,\n            l = !1;\n        t.data = null, s && n.length && !a.audFound && (W(s, a), s = this.avcSample = j(!1, t.pts, t.dts, \"\")), n.forEach(function (e) {\n          switch (e.type) {\n            case 1:\n              r = !0, s || (s = i.avcSample = j(!0, t.pts, t.dts, \"\")), s.frame = !0;\n              var n = e.data;\n\n              if (l && n.length > 4) {\n                var u = new N(n).readSliceType();\n                2 !== u && 4 !== u && 7 !== u && 9 !== u || (s.key = !0);\n              }\n\n              break;\n\n            case 5:\n              r = !0, s || (s = i.avcSample = j(!0, t.pts, t.dts, \"\")), s.key = !0, s.frame = !0;\n              break;\n\n            case 6:\n              r = !0;\n              var d = new N(X(e.data));\n              d.readUByte();\n\n              for (var h = 0, f = 0, c = !1, v = 0; !c && d.bytesAvailable > 1;) {\n                h = 0;\n\n                do {\n                  h += v = d.readUByte();\n                } while (255 === v);\n\n                f = 0;\n\n                do {\n                  f += v = d.readUByte();\n                } while (255 === v);\n\n                if (4 === h && 0 !== d.bytesAvailable) {\n                  if (c = !0, 181 === d.readUByte()) if (49 === d.readUShort()) if (1195456820 === d.readUInt()) if (3 === d.readUByte()) {\n                    for (var g = d.readUByte(), p = 31 & g, m = [g, d.readUByte()], y = 0; y < p; y++) m.push(d.readUByte()), m.push(d.readUByte()), m.push(d.readUByte());\n\n                    Y(i._txtTrack.samples, {\n                      type: 3,\n                      pts: t.pts,\n                      bytes: m\n                    });\n                  }\n                } else if (5 === h && 0 !== d.bytesAvailable) {\n                  if (c = !0, f > 16) {\n                    for (var b = [], T = 0; T < 16; T++) b.push(d.readUByte().toString(16)), 3 !== T && 5 !== T && 7 !== T && 9 !== T || b.push(\"-\");\n\n                    for (var E = f - 16, S = new Uint8Array(E), L = 0; L < E; L++) S[L] = d.readUByte();\n\n                    Y(i._txtTrack.samples, {\n                      pts: t.pts,\n                      payloadType: h,\n                      uuid: b.join(\"\"),\n                      userData: Object(o.f)(S),\n                      userDataBytes: S\n                    });\n                  }\n                } else if (f < d.bytesAvailable) for (var A = 0; A < f; A++) d.readUByte();\n              }\n\n              break;\n\n            case 7:\n              if (r = !0, l = !0, !a.sps) {\n                var R = new N(e.data).readSPS();\n                a.width = R.width, a.height = R.height, a.pixelRatio = R.pixelRatio, a.sps = [e.data], a.duration = i._duration;\n\n                for (var D = e.data.subarray(1, 4), _ = \"avc1.\", k = 0; k < 3; k++) {\n                  var x = D[k].toString(16);\n                  x.length < 2 && (x = \"0\" + x), _ += x;\n                }\n\n                a.codec = _;\n              }\n\n              break;\n\n            case 8:\n              r = !0, a.pps || (a.pps = [e.data]);\n              break;\n\n            case 9:\n              r = !1, a.audFound = !0, s && W(s, a), s = i.avcSample = j(!1, t.pts, t.dts, \"\");\n              break;\n\n            case 12:\n              r = !1;\n              break;\n\n            default:\n              r = !1, s && (s.debug += \"unknown NAL \" + e.type + \" \");\n          }\n\n          s && r && s.units.push(e);\n        }), e && s && (W(s, a), this.avcSample = null);\n      }, e.getLastNalUnit = function () {\n        var t,\n            e,\n            r = this.avcSample;\n\n        if (!r || 0 === r.units.length) {\n          var i = this._avcTrack.samples;\n          r = i[i.length - 1];\n        }\n\n        if (null !== (t = r) && void 0 !== t && t.units) {\n          var a = r.units;\n          e = a[a.length - 1];\n        }\n\n        return e;\n      }, e.parseAVCNALu = function (t) {\n        var e,\n            r,\n            i = t.byteLength,\n            a = this._avcTrack,\n            n = a.naluState || 0,\n            s = n,\n            o = [],\n            l = 0,\n            u = -1,\n            d = 0;\n\n        for (-1 === n && (u = 0, d = 31 & t[0], n = 0, l = 1); l < i;) if (e = t[l++], n) {\n          if (1 !== n) {\n            if (e) {\n              if (1 === e) {\n                if (u >= 0) {\n                  var h = {\n                    data: t.subarray(u, l - n - 1),\n                    type: d\n                  };\n                  o.push(h);\n                } else {\n                  var f = this.getLastNalUnit();\n\n                  if (f && (s && l <= 4 - s && f.state && (f.data = f.data.subarray(0, f.data.byteLength - s)), (r = l - n - 1) > 0)) {\n                    var c = new Uint8Array(f.data.byteLength + r);\n                    c.set(f.data, 0), c.set(t.subarray(0, r), f.data.byteLength), f.data = c, f.state = 0;\n                  }\n                }\n\n                l < i ? (u = l, d = 31 & t[l], n = 0) : n = -1;\n              } else n = 0;\n            } else n = 3;\n          } else n = e ? 0 : 2;\n        } else n = e ? 0 : 1;\n\n        if (u >= 0 && n >= 0) {\n          var v = {\n            data: t.subarray(u, i),\n            type: d,\n            state: n\n          };\n          o.push(v);\n        }\n\n        if (0 === o.length) {\n          var g = this.getLastNalUnit();\n\n          if (g) {\n            var p = new Uint8Array(g.data.byteLength + t.byteLength);\n            p.set(g.data, 0), p.set(t, g.data.byteLength), g.data = p;\n          }\n        }\n\n        return a.naluState = n, o;\n      }, e.parseAACPES = function (t) {\n        var e,\n            r,\n            n,\n            s,\n            o,\n            l = 0,\n            u = this._audioTrack,\n            d = this.aacOverFlow,\n            h = t.data;\n\n        if (d) {\n          this.aacOverFlow = null;\n          var f = d.sample.unit.byteLength,\n              v = Math.min(d.missing, f),\n              g = f - v;\n          d.sample.unit.set(h.subarray(0, v), g), u.samples.push(d.sample), l = d.missing;\n        }\n\n        for (e = l, r = h.length; e < r - 1 && !m(h, e); e++);\n\n        if (e !== l && (e < r - 1 ? (n = \"AAC PES did not start with ADTS header,offset:\" + e, s = !1) : (n = \"no ADTS header found in AAC PES\", s = !0), c.b.warn(\"parsing error:\" + n), this.observer.emit(i.a.ERROR, i.a.ERROR, {\n          type: a.b.MEDIA_ERROR,\n          details: a.a.FRAG_PARSING_ERROR,\n          fatal: s,\n          reason: n\n        }), s)) return;\n        if (b(u, this.observer, h, e, this.audioCodec), void 0 !== t.pts) o = t.pts;else {\n          if (!d) return void c.b.warn(\"[tsdemuxer]: AAC PES unknown PTS\");\n          var p = T(u.samplerate);\n          o = d.sample.pts + p;\n        }\n\n        for (var y = 0; e < r;) {\n          if (m(h, e)) {\n            if (e + 5 < r) {\n              var S = E(u, h, e, o, y);\n\n              if (S) {\n                if (!S.missing) {\n                  e += S.length, y++;\n                  continue;\n                }\n\n                this.aacOverFlow = S;\n              }\n            }\n\n            break;\n          }\n\n          e++;\n        }\n      }, e.parseMPEGPES = function (t) {\n        var e = t.data,\n            r = e.length,\n            i = 0,\n            a = 0,\n            n = t.pts;\n        if (void 0 !== n) {\n          for (; a < r;) if (F(e, a)) {\n            var s = O(this._audioTrack, e, a, n, i);\n            if (!s) break;\n            a += s.length, i++;\n          } else a++;\n        } else c.b.warn(\"[tsdemuxer]: MPEG PES unknown PTS\");\n      }, e.parseID3PES = function (t) {\n        void 0 !== t.pts ? this._id3Track.samples.push(t) : c.b.warn(\"[tsdemuxer]: ID3 PES unknown PTS\");\n      }, t;\n    }();\n\n    function j(t, e, r, i) {\n      return {\n        key: t,\n        frame: !1,\n        pts: e,\n        dts: r,\n        units: [],\n        debug: i,\n        length: 0\n      };\n    }\n\n    function H(t, e) {\n      return (31 & t[e + 10]) << 8 | t[e + 11];\n    }\n\n    function K(t, e, r, i) {\n      var a = {\n        audio: -1,\n        avc: -1,\n        id3: -1,\n        isAAC: !0\n      },\n          n = e + 3 + ((15 & t[e + 1]) << 8 | t[e + 2]) - 4;\n\n      for (e += 12 + ((15 & t[e + 10]) << 8 | t[e + 11]); e < n;) {\n        var s = (31 & t[e + 1]) << 8 | t[e + 2];\n\n        switch (t[e]) {\n          case 207:\n            if (!i) {\n              c.b.log(\"ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream\");\n              break;\n            }\n\n          case 15:\n            -1 === a.audio && (a.audio = s);\n            break;\n\n          case 21:\n            -1 === a.id3 && (a.id3 = s);\n            break;\n\n          case 219:\n            if (!i) {\n              c.b.log(\"H.264 with AES-128-CBC slice encryption found in unencrypted stream\");\n              break;\n            }\n\n          case 27:\n            -1 === a.avc && (a.avc = s);\n            break;\n\n          case 3:\n          case 4:\n            r ? -1 === a.audio && (a.audio = s, a.isAAC = !1) : c.b.log(\"MPEG audio found, not supported in this browser\");\n            break;\n\n          case 36:\n            c.b.warn(\"Unsupported HEVC stream type found\");\n        }\n\n        e += 5 + ((15 & t[e + 3]) << 8 | t[e + 4]);\n      }\n\n      return a;\n    }\n\n    function V(t) {\n      var e,\n          r,\n          i,\n          a,\n          n,\n          s = 0,\n          o = t.data;\n      if (!t || 0 === t.size) return null;\n\n      for (; o[0].length < 19 && o.length > 1;) {\n        var l = new Uint8Array(o[0].length + o[1].length);\n        l.set(o[0]), l.set(o[1], o[0].length), o[0] = l, o.splice(1, 1);\n      }\n\n      if (1 === ((e = o[0])[0] << 16) + (e[1] << 8) + e[2]) {\n        if ((r = (e[4] << 8) + e[5]) && r > t.size - 6) return null;\n        var u = e[7];\n        192 & u && (a = 536870912 * (14 & e[9]) + 4194304 * (255 & e[10]) + 16384 * (254 & e[11]) + 128 * (255 & e[12]) + (254 & e[13]) / 2, 64 & u ? a - (n = 536870912 * (14 & e[14]) + 4194304 * (255 & e[15]) + 16384 * (254 & e[16]) + 128 * (255 & e[17]) + (254 & e[18]) / 2) > 54e5 && (c.b.warn(Math.round((a - n) / 9e4) + \"s delta between PTS and DTS, align them\"), a = n) : n = a);\n        var d = (i = e[8]) + 9;\n        if (t.size <= d) return null;\n        t.size -= d;\n\n        for (var h = new Uint8Array(t.size), f = 0, v = o.length; f < v; f++) {\n          var g = (e = o[f]).byteLength;\n\n          if (d) {\n            if (d > g) {\n              d -= g;\n              continue;\n            }\n\n            e = e.subarray(d), g -= d, d = 0;\n          }\n\n          h.set(e, s), s += g;\n        }\n\n        return r && (r -= i + 3), {\n          data: h,\n          pts: a,\n          dts: n,\n          len: r\n        };\n      }\n\n      return null;\n    }\n\n    function W(t, e) {\n      if (t.units.length && t.frame) {\n        if (void 0 === t.pts) {\n          var r = e.samples,\n              i = r.length;\n          if (!i) return void e.dropped++;\n          var a = r[i - 1];\n          t.pts = a.pts, t.dts = a.dts;\n        }\n\n        e.samples.push(t);\n      }\n\n      t.debug.length && c.b.log(t.pts + \"/\" + t.dts + \":\" + t.debug);\n    }\n\n    function Y(t, e) {\n      var r = t.length;\n\n      if (r > 0) {\n        if (e.pts >= t[r - 1].pts) t.push(e);else for (var i = r - 1; i >= 0; i--) if (e.pts < t[i].pts) {\n          t.splice(i, 0, e);\n          break;\n        }\n      } else t.push(e);\n    }\n\n    function X(t) {\n      for (var e = t.byteLength, r = [], i = 1; i < e - 2;) 0 === t[i] && 0 === t[i + 1] && 3 === t[i + 2] ? (r.push(i + 2), i += 2) : i++;\n\n      if (0 === r.length) return t;\n      var a = e - r.length,\n          n = new Uint8Array(a),\n          s = 0;\n\n      for (i = 0; i < a; s++, i++) s === r[0] && (s++, r.shift()), n[i] = t[s];\n\n      return n;\n    }\n\n    G.minProbeByteLength = 188;\n    var q = G;\n\n    function z(t, e) {\n      return (z = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    var Q = function (t) {\n      var e, r;\n\n      function i() {\n        return t.apply(this, arguments) || this;\n      }\n\n      r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, z(e, r);\n      var a = i.prototype;\n      return a.resetInitSegment = function (e, r, i) {\n        t.prototype.resetInitSegment.call(this, e, r, i), this._audioTrack = {\n          container: \"audio/mpeg\",\n          type: \"audio\",\n          id: 2,\n          pid: -1,\n          sequenceNumber: 0,\n          isAAC: !1,\n          samples: [],\n          manifestCodec: e,\n          duration: i,\n          inputTimeScale: 9e4,\n          dropped: 0\n        };\n      }, i.probe = function (t) {\n        if (!t) return !1;\n\n        for (var e = (o.b(t, 0) || []).length, r = t.length; e < r; e++) if (M(t, e)) return c.b.log(\"MPEG Audio sync word found !\"), !0;\n\n        return !1;\n      }, a.canParse = function (t, e) {\n        return function (t, e) {\n          return P(t, e) && 4 <= t.length - e;\n        }(t, e);\n      }, a.appendFrame = function (t, e, r) {\n        if (null !== this.initPTS) return O(t, e, r, this.initPTS, this.frameIndex);\n      }, i;\n    }(f);\n\n    Q.minProbeByteLength = 4;\n\n    var $ = Q,\n        Z = function () {\n      function t() {}\n\n      return t.getSilentFrame = function (t, e) {\n        switch (t) {\n          case \"mp4a.40.2\":\n            if (1 === e) return new Uint8Array([0, 200, 0, 128, 35, 128]);\n            if (2 === e) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);\n            if (3 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);\n            if (4 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);\n            if (5 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);\n            if (6 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);\n            break;\n\n          default:\n            if (1 === e) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);\n            if (2 === e) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);\n            if (3 === e) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);\n        }\n      }, t;\n    }(),\n        J = Math.pow(2, 32) - 1,\n        tt = function () {\n      function t() {}\n\n      return t.init = function () {\n        var e;\n\n        for (e in t.types = {\n          avc1: [],\n          avcC: [],\n          btrt: [],\n          dinf: [],\n          dref: [],\n          esds: [],\n          ftyp: [],\n          hdlr: [],\n          mdat: [],\n          mdhd: [],\n          mdia: [],\n          mfhd: [],\n          minf: [],\n          moof: [],\n          moov: [],\n          mp4a: [],\n          \".mp3\": [],\n          mvex: [],\n          mvhd: [],\n          pasp: [],\n          sdtp: [],\n          stbl: [],\n          stco: [],\n          stsc: [],\n          stsd: [],\n          stsz: [],\n          stts: [],\n          tfdt: [],\n          tfhd: [],\n          traf: [],\n          trak: [],\n          trun: [],\n          trex: [],\n          tkhd: [],\n          vmhd: [],\n          smhd: []\n        }, t.types) t.types.hasOwnProperty(e) && (t.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);\n\n        var r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),\n            i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);\n        t.HDLR_TYPES = {\n          video: r,\n          audio: i\n        };\n        var a = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),\n            n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);\n        t.STTS = t.STSC = t.STCO = n, t.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), t.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), t.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), t.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);\n        var s = new Uint8Array([105, 115, 111, 109]),\n            o = new Uint8Array([97, 118, 99, 49]),\n            l = new Uint8Array([0, 0, 0, 1]);\n        t.FTYP = t.box(t.types.ftyp, s, l, s, o), t.DINF = t.box(t.types.dinf, t.box(t.types.dref, a));\n      }, t.box = function (t) {\n        for (var e = 8, r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++) i[a - 1] = arguments[a];\n\n        for (var n = i.length, s = n; n--;) e += i[n].byteLength;\n\n        var o = new Uint8Array(e);\n\n        for (o[0] = e >> 24 & 255, o[1] = e >> 16 & 255, o[2] = e >> 8 & 255, o[3] = 255 & e, o.set(t, 4), n = 0, e = 8; n < s; n++) o.set(i[n], e), e += i[n].byteLength;\n\n        return o;\n      }, t.hdlr = function (e) {\n        return t.box(t.types.hdlr, t.HDLR_TYPES[e]);\n      }, t.mdat = function (e) {\n        return t.box(t.types.mdat, e);\n      }, t.mdhd = function (e, r) {\n        r *= e;\n        var i = Math.floor(r / (J + 1)),\n            a = Math.floor(r % (J + 1));\n        return t.box(t.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, 85, 196, 0, 0]));\n      }, t.mdia = function (e) {\n        return t.box(t.types.mdia, t.mdhd(e.timescale, e.duration), t.hdlr(e.type), t.minf(e));\n      }, t.mfhd = function (e) {\n        return t.box(t.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e]));\n      }, t.minf = function (e) {\n        return \"audio\" === e.type ? t.box(t.types.minf, t.box(t.types.smhd, t.SMHD), t.DINF, t.stbl(e)) : t.box(t.types.minf, t.box(t.types.vmhd, t.VMHD), t.DINF, t.stbl(e));\n      }, t.moof = function (e, r, i) {\n        return t.box(t.types.moof, t.mfhd(e), t.traf(i, r));\n      }, t.moov = function (e) {\n        for (var r = e.length, i = []; r--;) i[r] = t.trak(e[r]);\n\n        return t.box.apply(null, [t.types.moov, t.mvhd(e[0].timescale, e[0].duration)].concat(i).concat(t.mvex(e)));\n      }, t.mvex = function (e) {\n        for (var r = e.length, i = []; r--;) i[r] = t.trex(e[r]);\n\n        return t.box.apply(null, [t.types.mvex].concat(i));\n      }, t.mvhd = function (e, r) {\n        r *= e;\n        var i = Math.floor(r / (J + 1)),\n            a = Math.floor(r % (J + 1)),\n            n = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);\n        return t.box(t.types.mvhd, n);\n      }, t.sdtp = function (e) {\n        var r,\n            i,\n            a = e.samples || [],\n            n = new Uint8Array(4 + a.length);\n\n        for (r = 0; r < a.length; r++) i = a[r].flags, n[r + 4] = i.dependsOn << 4 | i.isDependedOn << 2 | i.hasRedundancy;\n\n        return t.box(t.types.sdtp, n);\n      }, t.stbl = function (e) {\n        return t.box(t.types.stbl, t.stsd(e), t.box(t.types.stts, t.STTS), t.box(t.types.stsc, t.STSC), t.box(t.types.stsz, t.STSZ), t.box(t.types.stco, t.STCO));\n      }, t.avc1 = function (e) {\n        var r,\n            i,\n            a,\n            n = [],\n            s = [];\n\n        for (r = 0; r < e.sps.length; r++) a = (i = e.sps[r]).byteLength, n.push(a >>> 8 & 255), n.push(255 & a), n = n.concat(Array.prototype.slice.call(i));\n\n        for (r = 0; r < e.pps.length; r++) a = (i = e.pps[r]).byteLength, s.push(a >>> 8 & 255), s.push(255 & a), s = s.concat(Array.prototype.slice.call(i));\n\n        var o = t.box(t.types.avcC, new Uint8Array([1, n[3], n[4], n[5], 255, 224 | e.sps.length].concat(n).concat([e.pps.length]).concat(s))),\n            l = e.width,\n            u = e.height,\n            d = e.pixelRatio[0],\n            h = e.pixelRatio[1];\n        return t.box(t.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, 255 & l, u >> 8 & 255, 255 & u, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), o, t.box(t.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), t.box(t.types.pasp, new Uint8Array([d >> 24, d >> 16 & 255, d >> 8 & 255, 255 & d, h >> 24, h >> 16 & 255, h >> 8 & 255, 255 & h])));\n      }, t.esds = function (t) {\n        var e = t.config.length;\n        return new Uint8Array([0, 0, 0, 0, 3, 23 + e, 0, 1, 0, 4, 15 + e, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([e]).concat(t.config).concat([6, 1, 2]));\n      }, t.mp4a = function (e) {\n        var r = e.samplerate;\n        return t.box(t.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]), t.box(t.types.esds, t.esds(e)));\n      }, t.mp3 = function (e) {\n        var r = e.samplerate;\n        return t.box(t.types[\".mp3\"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]));\n      }, t.stsd = function (e) {\n        return \"audio\" === e.type ? e.isAAC || \"mp3\" !== e.codec ? t.box(t.types.stsd, t.STSD, t.mp4a(e)) : t.box(t.types.stsd, t.STSD, t.mp3(e)) : t.box(t.types.stsd, t.STSD, t.avc1(e));\n      }, t.tkhd = function (e) {\n        var r = e.id,\n            i = e.duration * e.timescale,\n            a = e.width,\n            n = e.height,\n            s = Math.floor(i / (J + 1)),\n            o = Math.floor(i % (J + 1));\n        return t.box(t.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, o >> 24, o >> 16 & 255, o >> 8 & 255, 255 & o, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, a >> 8 & 255, 255 & a, 0, 0, n >> 8 & 255, 255 & n, 0, 0]));\n      }, t.traf = function (e, r) {\n        var i = t.sdtp(e),\n            a = e.id,\n            n = Math.floor(r / (J + 1)),\n            s = Math.floor(r % (J + 1));\n        return t.box(t.types.traf, t.box(t.types.tfhd, new Uint8Array([0, 0, 0, 0, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a])), t.box(t.types.tfdt, new Uint8Array([1, 0, 0, 0, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s])), t.trun(e, i.length + 16 + 20 + 8 + 16 + 8 + 8), i);\n      }, t.trak = function (e) {\n        return e.duration = e.duration || 4294967295, t.box(t.types.trak, t.tkhd(e), t.mdia(e));\n      }, t.trex = function (e) {\n        var r = e.id;\n        return t.box(t.types.trex, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]));\n      }, t.trun = function (e, r) {\n        var i,\n            a,\n            n,\n            s,\n            o,\n            l,\n            u = e.samples || [],\n            d = u.length,\n            h = 12 + 16 * d,\n            f = new Uint8Array(h);\n\n        for (r += 8 + h, f.set([0, 0, 15, 1, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, 255 & d, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r], 0), i = 0; i < d; i++) n = (a = u[i]).duration, s = a.size, o = a.flags, l = a.cts, f.set([n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, o.isLeading << 2 | o.dependsOn, o.isDependedOn << 6 | o.hasRedundancy << 4 | o.paddingValue << 1 | o.isNonSync, 61440 & o.degradPrio, 15 & o.degradPrio, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l], 12 + 16 * i);\n\n        return t.box(t.types.trun, f);\n      }, t.initSegment = function (e) {\n        t.types || t.init();\n        var r = t.moov(e),\n            i = new Uint8Array(t.FTYP.byteLength + r.byteLength);\n        return i.set(t.FTYP), i.set(r, t.FTYP.byteLength), i;\n      }, t;\n    }();\n\n    tt.types = void 0, tt.HDLR_TYPES = void 0, tt.STTS = void 0, tt.STSC = void 0, tt.STCO = void 0, tt.STSZ = void 0, tt.VMHD = void 0, tt.SMHD = void 0, tt.STSD = void 0, tt.FTYP = void 0, tt.DINF = void 0;\n    var et = tt,\n        rt = r(4);\n\n    function it(t, e, r, i) {\n      void 0 === r && (r = 1), void 0 === i && (i = !1);\n      var a = t * e * r;\n      return i ? Math.round(a) : a;\n    }\n\n    function at(t, e) {\n      return void 0 === e && (e = !1), it(t, 1e3, 1 / 9e4, e);\n    }\n\n    function nt() {\n      return (nt = Object.assign || function (t) {\n        for (var e = 1; e < arguments.length; e++) {\n          var r = arguments[e];\n\n          for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);\n        }\n\n        return t;\n      }).apply(this, arguments);\n    }\n\n    var st = null,\n        ot = null,\n        lt = !1,\n        ut = function () {\n      function t(t, e, r, i) {\n        if (void 0 === i && (i = \"\"), this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = void 0, this._initDTS = void 0, this.nextAvcDts = null, this.nextAudioPts = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.observer = t, this.config = e, this.typeSupported = r, this.ISGenerated = !1, null === st) {\n          var a = (navigator.userAgent || \"\").match(/Chrome\\/(\\d+)/i);\n          st = a ? parseInt(a[1]) : 0;\n        }\n\n        if (null === ot) {\n          var n = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n          ot = n ? parseInt(n[1]) : 0;\n        }\n\n        lt = !!st && st < 75 || !!ot && ot < 600;\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {}, e.resetTimeStamp = function (t) {\n        c.b.log(\"[mp4-remuxer]: initPTS & initDTS reset\"), this._initPTS = this._initDTS = t;\n      }, e.resetNextTimestamp = function () {\n        c.b.log(\"[mp4-remuxer]: reset next timestamp\"), this.isVideoContiguous = !1, this.isAudioContiguous = !1;\n      }, e.resetInitSegment = function () {\n        c.b.log(\"[mp4-remuxer]: ISGenerated flag reset\"), this.ISGenerated = !1;\n      }, e.getVideoStartPts = function (t) {\n        var e = !1,\n            r = t.reduce(function (t, r) {\n          var i = r.pts - t;\n          return i < -4294967296 ? (e = !0, dt(t, r.pts)) : i > 0 ? t : r.pts;\n        }, t[0].pts);\n        return e && c.b.debug(\"PTS rollover detected\"), r;\n      }, e.remux = function (t, e, r, i, a, n, s, o) {\n        var l,\n            u,\n            d,\n            h,\n            f,\n            v,\n            g = a,\n            p = a,\n            m = t.pid > -1,\n            y = e.pid > -1,\n            b = e.samples.length,\n            T = t.samples.length > 0,\n            E = b > 1;\n\n        if ((!m || T) && (!y || E) || this.ISGenerated || s) {\n          this.ISGenerated || (d = this.generateIS(t, e, a));\n          var S = this.isVideoContiguous,\n              L = -1;\n          if (E && (L = function (t) {\n            for (var e = 0; e < t.length; e++) if (t[e].key) return e;\n\n            return -1;\n          }(e.samples), !S && this.config.forceKeyFrameOnDiscontinuity)) if (v = !0, L > 0) {\n            c.b.warn(\"[mp4-remuxer]: Dropped \" + L + \" out of \" + b + \" video samples due to a missing keyframe\");\n            var A = this.getVideoStartPts(e.samples);\n            e.samples = e.samples.slice(L), e.dropped += L, p += (e.samples[0].pts - A) / (e.timescale || 9e4);\n          } else -1 === L && (c.b.warn(\"[mp4-remuxer]: No keyframe found out of \" + b + \" video samples\"), v = !1);\n\n          if (this.ISGenerated) {\n            if (T && E) {\n              var R = this.getVideoStartPts(e.samples),\n                  D = (dt(t.samples[0].pts, R) - R) / e.inputTimeScale;\n              g += Math.max(0, D), p += Math.max(0, -D);\n            }\n\n            if (T) {\n              if (t.samplerate || (c.b.warn(\"[mp4-remuxer]: regenerate InitSegment as audio detected\"), d = this.generateIS(t, e, a)), u = this.remuxAudio(t, g, this.isAudioContiguous, n, y || E || o === rt.b.AUDIO ? p : void 0), E) {\n                var _ = u ? u.endPTS - u.startPTS : 0;\n\n                e.inputTimeScale || (c.b.warn(\"[mp4-remuxer]: regenerate InitSegment as video detected\"), d = this.generateIS(t, e, a)), l = this.remuxVideo(e, p, S, _);\n              }\n            } else E && (l = this.remuxVideo(e, p, S, 0));\n\n            l && (l.firstKeyFrame = L, l.independent = -1 !== L);\n          }\n        }\n\n        return this.ISGenerated && (r.samples.length && (f = this.remuxID3(r, a)), i.samples.length && (h = this.remuxText(i, a))), {\n          audio: u,\n          video: l,\n          initSegment: d,\n          independent: v,\n          text: h,\n          id3: f\n        };\n      }, e.generateIS = function (t, e, r) {\n        var i,\n            a,\n            n,\n            o = t.samples,\n            l = e.samples,\n            u = this.typeSupported,\n            d = {},\n            h = !Object(s.a)(this._initPTS),\n            f = \"audio/mp4\";\n\n        if (h && (i = a = 1 / 0), t.config && o.length && (t.timescale = t.samplerate, t.isAAC || (u.mpeg ? (f = \"audio/mpeg\", t.codec = \"\") : u.mp3 && (t.codec = \"mp3\")), d.audio = {\n          id: \"audio\",\n          container: f,\n          codec: t.codec,\n          initSegment: !t.isAAC && u.mpeg ? new Uint8Array(0) : et.initSegment([t]),\n          metadata: {\n            channelCount: t.channelCount\n          }\n        }, h && (n = t.inputTimeScale, i = a = o[0].pts - Math.round(n * r))), e.sps && e.pps && l.length && (e.timescale = e.inputTimeScale, d.video = {\n          id: \"main\",\n          container: \"video/mp4\",\n          codec: e.codec,\n          initSegment: et.initSegment([e]),\n          metadata: {\n            width: e.width,\n            height: e.height\n          }\n        }, h)) {\n          n = e.inputTimeScale;\n          var c = this.getVideoStartPts(l),\n              v = Math.round(n * r);\n          a = Math.min(a, dt(l[0].dts, c) - v), i = Math.min(i, c - v);\n        }\n\n        if (Object.keys(d).length) return this.ISGenerated = !0, h && (this._initPTS = i, this._initDTS = a), {\n          tracks: d,\n          initPTS: i,\n          timescale: n\n        };\n      }, e.remuxVideo = function (t, e, r, n) {\n        var s,\n            o,\n            l,\n            u = t.inputTimeScale,\n            d = t.samples,\n            h = [],\n            f = d.length,\n            v = this._initPTS,\n            g = this.nextAvcDts,\n            p = 8,\n            m = Number.POSITIVE_INFINITY,\n            y = Number.NEGATIVE_INFINITY,\n            b = 0,\n            T = !1;\n        r && null !== g || (g = e * u - (d[0].pts - dt(d[0].dts, d[0].pts)));\n\n        for (var E = 0; E < f; E++) {\n          var S = d[E];\n\n          if (S.pts = dt(S.pts - v, g), S.dts = dt(S.dts - v, g), S.dts > S.pts) {\n            b = Math.max(Math.min(b, S.pts - S.dts), -18e3);\n          }\n\n          S.dts < d[E > 0 ? E - 1 : E].dts && (T = !0);\n        }\n\n        T && d.sort(function (t, e) {\n          var r = t.dts - e.dts,\n              i = t.pts - e.pts;\n          return r || i;\n        }), o = d[0].dts, l = d[d.length - 1].dts;\n        var L = Math.round((l - o) / (f - 1));\n\n        if (b < 0) {\n          if (b < -2 * L) {\n            c.b.warn(\"PTS < DTS detected in video samples, offsetting DTS from PTS by \" + at(-L, !0) + \" ms\");\n\n            for (var A = b, R = 0; R < f; R++) d[R].dts = A = Math.max(A, d[R].pts - L), d[R].pts = Math.max(A, d[R].pts);\n          } else {\n            c.b.warn(\"PTS < DTS detected in video samples, shifting DTS by \" + at(b, !0) + \" ms to overcome this issue\");\n\n            for (var D = 0; D < f; D++) d[D].dts = d[D].dts + b;\n          }\n\n          o = d[0].dts;\n        }\n\n        if (r) {\n          var _ = o - g,\n              k = _ > L;\n\n          if (k || _ < -1) {\n            k ? c.b.warn(\"AVC: \" + at(_, !0) + \" ms (\" + _ + \"dts) hole between fragments detected, filling it\") : c.b.warn(\"AVC: \" + at(-_, !0) + \" ms (\" + _ + \"dts) overlapping between fragments detected\"), o = g;\n            var x = d[0].pts - _;\n            d[0].dts = o, d[0].pts = x, c.b.log(\"Video: First PTS/DTS adjusted: \" + at(x, !0) + \"/\" + at(o, !0) + \", delta: \" + at(_, !0) + \" ms\");\n          }\n        }\n\n        lt && (o = Math.max(0, o));\n\n        for (var C = 0, w = 0, O = 0; O < f; O++) {\n          for (var I = d[O], P = I.units, F = P.length, M = 0, N = 0; N < F; N++) M += P[N].data.length;\n\n          w += M, C += F, I.length = M, I.dts = Math.max(I.dts, o), I.pts = Math.max(I.pts, I.dts, 0), m = Math.min(I.pts, m), y = Math.max(I.pts, y);\n        }\n\n        l = d[f - 1].dts;\n        var B,\n            U = w + 4 * C + 8;\n\n        try {\n          B = new Uint8Array(U);\n        } catch (t) {\n          return void this.observer.emit(i.a.ERROR, i.a.ERROR, {\n            type: a.b.MUX_ERROR,\n            details: a.a.REMUX_ALLOC_ERROR,\n            fatal: !1,\n            bytes: U,\n            reason: \"fail allocating video mdat \" + U\n          });\n        }\n\n        var G = new DataView(B.buffer);\n        G.setUint32(0, U), B.set(et.types.mdat, 4);\n\n        for (var j = 0; j < f; j++) {\n          for (var H = d[j], K = H.units, V = 0, W = 0, Y = K.length; W < Y; W++) {\n            var X = K[W],\n                q = X.data,\n                z = X.data.byteLength;\n            G.setUint32(p, z), p += 4, B.set(q, p), p += z, V += 4 + z;\n          }\n\n          if (j < f - 1) s = d[j + 1].dts - H.dts;else {\n            var Q = this.config,\n                $ = H.dts - d[j > 0 ? j - 1 : j].dts;\n\n            if (Q.stretchShortVideoTrack && null !== this.nextAudioPts) {\n              var Z = Math.floor(Q.maxBufferHole * u),\n                  J = (n ? m + n * u : this.nextAudioPts) - H.pts;\n              J > Z ? ((s = J - $) < 0 && (s = $), c.b.log(\"[mp4-remuxer]: It is approximately \" + J / 90 + \" ms to the next segment; using duration \" + s / 90 + \" ms for the last video frame.\")) : s = $;\n            } else s = $;\n          }\n          var tt = Math.round(H.pts - H.dts);\n          h.push(new ht(H.key, s, V, tt));\n        }\n\n        if (h.length && st && st < 70) {\n          var rt = h[0].flags;\n          rt.dependsOn = 2, rt.isNonSync = 0;\n        }\n\n        this.nextAvcDts = g = l + s, this.isVideoContiguous = !0;\n        var it = {\n          data1: et.moof(t.sequenceNumber++, o, nt({}, t, {\n            samples: h\n          })),\n          data2: B,\n          startPTS: m / u,\n          endPTS: (y + s) / u,\n          startDTS: o / u,\n          endDTS: g / u,\n          type: \"video\",\n          hasAudio: !1,\n          hasVideo: !0,\n          nb: h.length,\n          dropped: t.dropped\n        };\n        return t.samples = [], t.dropped = 0, it;\n      }, e.remuxAudio = function (t, e, r, n, s) {\n        var o = t.inputTimeScale,\n            l = o / (t.samplerate ? t.samplerate : o),\n            u = t.isAAC ? 1024 : 1152,\n            d = u * l,\n            h = this._initPTS,\n            f = !t.isAAC && this.typeSupported.mpeg,\n            v = [],\n            g = t.samples,\n            p = f ? 0 : 8,\n            m = this.nextAudioPts || -1,\n            y = e * o;\n\n        if (this.isAudioContiguous = r = r || g.length && m > 0 && (n && Math.abs(y - m) < 9e3 || Math.abs(dt(g[0].pts - h, y) - m) < 20 * d), g.forEach(function (t) {\n          t.pts = dt(t.pts - h, y);\n        }), !r || m < 0) {\n          if (!(g = g.filter(function (t) {\n            return t.pts >= 0;\n          })).length) return;\n          m = 0 === s ? 0 : n ? Math.max(0, y) : g[0].pts;\n        }\n\n        if (t.isAAC) for (var b = void 0 !== s, T = this.config.maxAudioFramesDrift, E = 0, S = m; E < g.length; E++) {\n          var L = g[E],\n              A = L.pts,\n              R = A - S,\n              D = Math.abs(1e3 * R / o);\n          if (R <= -T * d && b) 0 === E && (c.b.warn(\"Audio frame @ \" + (A / o).toFixed(3) + \"s overlaps nextAudioPts by \" + Math.round(1e3 * R / o) + \" ms.\"), this.nextAudioPts = m = S = A);else if (R >= T * d && D < 1e4 && b) {\n            var _ = Math.round(R / d);\n\n            (S = A - _ * d) < 0 && (_--, S += d), 0 === E && (this.nextAudioPts = m = S), c.b.warn(\"[mp4-remuxer]: Injecting \" + _ + \" audio frame @ \" + (S / o).toFixed(3) + \"s due to \" + Math.round(1e3 * R / o) + \" ms gap.\");\n\n            for (var k = 0; k < _; k++) {\n              var x = Math.max(S, 0),\n                  C = Z.getSilentFrame(t.manifestCodec || t.codec, t.channelCount);\n              C || (c.b.log(\"[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.\"), C = L.unit.subarray()), g.splice(E, 0, {\n                unit: C,\n                pts: x\n              }), S += d, E++;\n            }\n          }\n          L.pts = S, S += d;\n        }\n\n        for (var w, O = null, I = null, P = 0, F = g.length; F--;) P += g[F].unit.byteLength;\n\n        for (var M = 0, N = g.length; M < N; M++) {\n          var B = g[M],\n              U = B.unit,\n              G = B.pts;\n\n          if (null !== I) {\n            v[M - 1].duration = Math.round((G - I) / l);\n          } else {\n            if (r && t.isAAC && (G = m), O = G, !(P > 0)) return;\n            P += p;\n\n            try {\n              w = new Uint8Array(P);\n            } catch (t) {\n              return void this.observer.emit(i.a.ERROR, i.a.ERROR, {\n                type: a.b.MUX_ERROR,\n                details: a.a.REMUX_ALLOC_ERROR,\n                fatal: !1,\n                bytes: P,\n                reason: \"fail allocating audio mdat \" + P\n              });\n            }\n\n            f || (new DataView(w.buffer).setUint32(0, P), w.set(et.types.mdat, 4));\n          }\n\n          w.set(U, p);\n          var j = U.byteLength;\n          p += j, v.push(new ht(!0, u, j, 0)), I = G;\n        }\n\n        var H = v.length;\n\n        if (H) {\n          var K = v[v.length - 1];\n          this.nextAudioPts = m = I + l * K.duration;\n          var V = f ? new Uint8Array(0) : et.moof(t.sequenceNumber++, O / l, nt({}, t, {\n            samples: v\n          }));\n          t.samples = [];\n          var W = O / o,\n              Y = m / o,\n              X = {\n            data1: V,\n            data2: w,\n            startPTS: W,\n            endPTS: Y,\n            startDTS: W,\n            endDTS: Y,\n            type: \"audio\",\n            hasAudio: !0,\n            hasVideo: !1,\n            nb: H\n          };\n          return this.isAudioContiguous = !0, X;\n        }\n      }, e.remuxEmptyAudio = function (t, e, r, i) {\n        var a = t.inputTimeScale,\n            n = a / (t.samplerate ? t.samplerate : a),\n            s = this.nextAudioPts,\n            o = (null !== s ? s : i.startDTS * a) + this._initDTS,\n            l = i.endDTS * a + this._initDTS,\n            u = 1024 * n,\n            d = Math.ceil((l - o) / u),\n            h = Z.getSilentFrame(t.manifestCodec || t.codec, t.channelCount);\n\n        if (c.b.warn(\"[mp4-remuxer]: remux empty Audio\"), h) {\n          for (var f = [], v = 0; v < d; v++) {\n            var g = o + v * u;\n            f.push({\n              unit: h,\n              pts: g,\n              dts: g\n            });\n          }\n\n          return t.samples = f, this.remuxAudio(t, e, r, !1);\n        }\n\n        c.b.trace(\"[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec\");\n      }, e.remuxID3 = function (t, e) {\n        var r = t.samples.length;\n\n        if (r) {\n          for (var i = t.inputTimeScale, a = this._initPTS, n = this._initDTS, s = 0; s < r; s++) {\n            var o = t.samples[s];\n            o.pts = dt(o.pts - a, e * i) / i, o.dts = dt(o.dts - n, e * i) / i;\n          }\n\n          var l = t.samples;\n          return t.samples = [], {\n            samples: l\n          };\n        }\n      }, e.remuxText = function (t, e) {\n        var r = t.samples.length;\n\n        if (r) {\n          for (var i = t.inputTimeScale, a = this._initPTS, n = 0; n < r; n++) {\n            var s = t.samples[n];\n            s.pts = dt(s.pts - a, e * i) / i;\n          }\n\n          t.samples.sort(function (t, e) {\n            return t.pts - e.pts;\n          });\n          var o = t.samples;\n          return t.samples = [], {\n            samples: o\n          };\n        }\n      }, t;\n    }();\n\n    function dt(t, e) {\n      var r;\n      if (null === e) return t;\n\n      for (r = e < t ? -8589934592 : 8589934592; Math.abs(t - e) > 4294967296;) t += r;\n\n      return t;\n    }\n\n    var ht = function (t, e, r, i) {\n      this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = e, this.size = r, this.cts = i, this.flags = new ft(t);\n    },\n        ft = function (t) {\n      this.isLeading = 0, this.isDependedOn = 0, this.hasRedundancy = 0, this.degradPrio = 0, this.dependsOn = 1, this.isNonSync = 1, this.dependsOn = t ? 2 : 1, this.isNonSync = t ? 0 : 1;\n    },\n        ct = r(5),\n        vt = function () {\n      function t() {\n        this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = void 0, this.initTracks = void 0, this.lastEndDTS = null;\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {}, e.resetTimeStamp = function (t) {\n        this.initPTS = t, this.lastEndDTS = null;\n      }, e.resetNextTimestamp = function () {\n        this.lastEndDTS = null;\n      }, e.resetInitSegment = function (t, e, r) {\n        this.audioCodec = e, this.videoCodec = r, this.generateInitSegment(t), this.emitInitSegment = !0;\n      }, e.generateInitSegment = function (t) {\n        var e = this.audioCodec,\n            r = this.videoCodec;\n        if (!t || !t.byteLength) return this.initTracks = void 0, void (this.initData = void 0);\n        var i = this.initData = Object(l.f)(t);\n        e || (e = pt(i.audio, ct.a.AUDIO)), r || (r = pt(i.video, ct.a.VIDEO));\n        var a = {};\n        i.audio && i.video ? a.audiovideo = {\n          container: \"video/mp4\",\n          codec: e + \",\" + r,\n          initSegment: t,\n          id: \"main\"\n        } : i.audio ? a.audio = {\n          container: \"audio/mp4\",\n          codec: e,\n          initSegment: t,\n          id: \"audio\"\n        } : i.video ? a.video = {\n          container: \"video/mp4\",\n          codec: r,\n          initSegment: t,\n          id: \"main\"\n        } : c.b.warn(\"[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.\"), this.initTracks = a;\n      }, e.remux = function (t, e, r, i, a) {\n        var n = this.initPTS,\n            o = this.lastEndDTS,\n            u = {\n          audio: void 0,\n          video: void 0,\n          text: i,\n          id3: r,\n          initSegment: void 0\n        };\n        Object(s.a)(o) || (o = this.lastEndDTS = a || 0);\n        var d = e.samples;\n        if (!d || !d.length) return u;\n        var h = {\n          initPTS: void 0,\n          timescale: 1\n        },\n            f = this.initData;\n        if (f && f.length || (this.generateInitSegment(d), f = this.initData), !f || !f.length) return c.b.warn(\"[passthrough-remuxer.ts]: Failed to generate initSegment.\"), u;\n        this.emitInitSegment && (h.tracks = this.initTracks, this.emitInitSegment = !1), Object(s.a)(n) || (this.initPTS = h.initPTS = n = gt(f, d, o));\n        var v = Object(l.c)(d, f),\n            g = o,\n            p = v + g;\n        Object(l.e)(f, d, n), v > 0 ? this.lastEndDTS = p : (c.b.warn(\"Duration parsed from mp4 should be greater than zero\"), this.resetNextTimestamp());\n        var m = !!f.audio,\n            y = !!f.video,\n            b = \"\";\n        m && (b += \"audio\"), y && (b += \"video\");\n        var T = {\n          data1: d,\n          startPTS: g,\n          startDTS: g,\n          endPTS: p,\n          endDTS: p,\n          type: b,\n          hasAudio: m,\n          hasVideo: y,\n          nb: 1,\n          dropped: 0\n        };\n        return u.audio = \"audio\" === T.type ? T : void 0, u.video = \"audio\" !== T.type ? T : void 0, u.text = i, u.id3 = r, u.initSegment = h, u;\n      }, t;\n    }(),\n        gt = function (t, e, r) {\n      return Object(l.d)(t, e) - r;\n    };\n\n    function pt(t, e) {\n      var r = null == t ? void 0 : t.codec;\n      return r && r.length > 4 ? r : \"hvc1\" === r ? \"hvc1.1.c.L120.90\" : \"av01\" === r ? \"av01.0.04M.08\" : \"avc1\" === r || e === ct.a.VIDEO ? \"avc1.42e01e\" : \"mp4a.40.5\";\n    }\n\n    var mt,\n        yt = vt,\n        bt = r(16);\n\n    try {\n      mt = self.performance.now.bind(self.performance);\n    } catch (t) {\n      c.b.debug(\"Unable to use Performance API on this environment\"), mt = self.Date.now;\n    }\n\n    var Tt = [{\n      demux: q,\n      remux: ut\n    }, {\n      demux: D,\n      remux: yt\n    }, {\n      demux: A,\n      remux: ut\n    }, {\n      demux: $,\n      remux: ut\n    }],\n        Et = 1024;\n    Tt.forEach(function (t) {\n      var e = t.demux;\n      Et = Math.max(Et, e.minProbeByteLength);\n    });\n\n    var St = function () {\n      function t(t, e, r, i, a) {\n        this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.cache = new bt.a(), this.observer = t, this.typeSupported = e, this.config = r, this.vendor = i, this.id = a;\n      }\n\n      var e = t.prototype;\n      return e.configure = function (t) {\n        this.transmuxConfig = t, this.decrypter && this.decrypter.reset();\n      }, e.push = function (t, e, r, i) {\n        var a = this,\n            n = r.transmuxing;\n        n.executeStart = mt();\n        var s = new Uint8Array(t),\n            o = this.cache,\n            u = this.config,\n            d = this.currentTransmuxState,\n            h = this.transmuxConfig;\n        i && (this.currentTransmuxState = i);\n\n        var f = function (t, e) {\n          var r = null;\n          t.byteLength > 0 && null != e && null != e.key && null !== e.iv && null != e.method && (r = e);\n          return r;\n        }(s, e);\n\n        if (f && \"AES-128\" === f.method) {\n          var c = this.getDecrypter();\n          if (!u.enableSoftwareAES) return this.decryptionPromise = c.webCryptoDecrypt(s, f.key.buffer, f.iv.buffer).then(function (t) {\n            var e = a.push(t, null, r);\n            return a.decryptionPromise = null, e;\n          }), this.decryptionPromise;\n          var v = c.softwareDecrypt(s, f.key.buffer, f.iv.buffer);\n          if (!v) return n.executeEnd = mt(), Lt(r);\n          s = new Uint8Array(v);\n        }\n\n        var g = i || d,\n            p = g.contiguous,\n            m = g.discontinuity,\n            y = g.trackSwitch,\n            b = g.accurateTimeOffset,\n            T = g.timeOffset,\n            E = g.initSegmentChange,\n            S = h.audioCodec,\n            L = h.videoCodec,\n            A = h.defaultInitPts,\n            R = h.duration,\n            D = h.initSegmentData;\n\n        if ((m || y || E) && this.resetInitSegment(D, S, L, R), (m || E) && this.resetInitialTimestamp(A), p || this.resetContiguity(), this.needsProbing(s, m, y)) {\n          if (o.dataLength) {\n            var _ = o.flush();\n\n            s = Object(l.a)(_, s);\n          }\n\n          this.configureTransmuxer(s, h);\n        }\n\n        var k = this.transmux(s, f, T, b, r),\n            x = this.currentTransmuxState;\n        return x.contiguous = !0, x.discontinuity = !1, x.trackSwitch = !1, n.executeEnd = mt(), k;\n      }, e.flush = function (t) {\n        var e = this,\n            r = t.transmuxing;\n        r.executeStart = mt();\n        var n = this.decrypter,\n            s = this.cache,\n            o = this.currentTransmuxState,\n            l = this.decryptionPromise;\n        if (l) return l.then(function () {\n          return e.flush(t);\n        });\n        var u = [],\n            d = o.timeOffset;\n\n        if (n) {\n          var h = n.flush();\n          h && u.push(this.push(h, null, t));\n        }\n\n        var f = s.dataLength;\n        s.reset();\n        var c = this.demuxer,\n            v = this.remuxer;\n        if (!c || !v) return f >= Et && this.observer.emit(i.a.ERROR, i.a.ERROR, {\n          type: a.b.MEDIA_ERROR,\n          details: a.a.FRAG_PARSING_ERROR,\n          fatal: !0,\n          reason: \"no demux matching with content found\"\n        }), r.executeEnd = mt(), [Lt(t)];\n        var g = c.flush(d);\n        return At(g) ? g.then(function (r) {\n          return e.flushRemux(u, r, t), u;\n        }) : (this.flushRemux(u, g, t), u);\n      }, e.flushRemux = function (t, e, r) {\n        var i = e.audioTrack,\n            a = e.avcTrack,\n            n = e.id3Track,\n            s = e.textTrack,\n            o = this.currentTransmuxState,\n            l = o.accurateTimeOffset,\n            u = o.timeOffset;\n        c.b.log(\"[transmuxer.ts]: Flushed fragment \" + r.sn + (r.part > -1 ? \" p: \" + r.part : \"\") + \" of level \" + r.level);\n        var d = this.remuxer.remux(i, a, n, s, u, l, !0, this.id);\n        t.push({\n          remuxResult: d,\n          chunkMeta: r\n        }), r.transmuxing.executeEnd = mt();\n      }, e.resetInitialTimestamp = function (t) {\n        var e = this.demuxer,\n            r = this.remuxer;\n        e && r && (e.resetTimeStamp(t), r.resetTimeStamp(t));\n      }, e.resetContiguity = function () {\n        var t = this.demuxer,\n            e = this.remuxer;\n        t && e && (t.resetContiguity(), e.resetNextTimestamp());\n      }, e.resetInitSegment = function (t, e, r, i) {\n        var a = this.demuxer,\n            n = this.remuxer;\n        a && n && (a.resetInitSegment(e, r, i), n.resetInitSegment(t, e, r));\n      }, e.destroy = function () {\n        this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0);\n      }, e.transmux = function (t, e, r, i, a) {\n        return e && \"SAMPLE-AES\" === e.method ? this.transmuxSampleAes(t, e, r, i, a) : this.transmuxUnencrypted(t, r, i, a);\n      }, e.transmuxUnencrypted = function (t, e, r, i) {\n        var a = this.demuxer.demux(t, e, !1, !this.config.progressive),\n            n = a.audioTrack,\n            s = a.avcTrack,\n            o = a.id3Track,\n            l = a.textTrack;\n        return {\n          remuxResult: this.remuxer.remux(n, s, o, l, e, r, !1, this.id),\n          chunkMeta: i\n        };\n      }, e.transmuxSampleAes = function (t, e, r, i, a) {\n        var n = this;\n        return this.demuxer.demuxSampleAes(t, e, r).then(function (t) {\n          return {\n            remuxResult: n.remuxer.remux(t.audioTrack, t.avcTrack, t.id3Track, t.textTrack, r, i, !1, n.id),\n            chunkMeta: a\n          };\n        });\n      }, e.configureTransmuxer = function (t, e) {\n        for (var r, i = this.config, a = this.observer, n = this.typeSupported, s = this.vendor, o = e.audioCodec, l = e.defaultInitPts, u = e.duration, d = e.initSegmentData, h = e.videoCodec, f = 0, v = Tt.length; f < v; f++) if (Tt[f].demux.probe(t)) {\n          r = Tt[f];\n          break;\n        }\n\n        r || (c.b.warn(\"Failed to find demuxer by probing frag, treating as mp4 passthrough\"), r = {\n          demux: D,\n          remux: yt\n        });\n        var g = this.demuxer,\n            p = this.remuxer,\n            m = r.remux,\n            y = r.demux;\n        p && p instanceof m || (this.remuxer = new m(a, i, n, s)), g && g instanceof y || (this.demuxer = new y(a, i, n), this.probe = y.probe), this.resetInitSegment(d, o, h, u), this.resetInitialTimestamp(l);\n      }, e.needsProbing = function (t, e, r) {\n        return !this.demuxer || !this.remuxer || e || r;\n      }, e.getDecrypter = function () {\n        var t = this.decrypter;\n        return t || (t = this.decrypter = new n.a(this.observer, this.config)), t;\n      }, t;\n    }();\n\n    var Lt = function (t) {\n      return {\n        remuxResult: {},\n        chunkMeta: t\n      };\n    };\n\n    function At(t) {\n      return \"then\" in t && t.then instanceof Function;\n    }\n\n    var Rt = function (t, e, r, i, a) {\n      this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = t, this.videoCodec = e, this.initSegmentData = r, this.duration = i, this.defaultInitPts = a;\n    },\n        Dt = function (t, e, r, i, a, n) {\n      this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = t, this.contiguous = e, this.accurateTimeOffset = r, this.trackSwitch = i, this.timeOffset = a, this.initSegmentChange = n;\n    };\n  }, function (t, e) {\n    t.exports = void 0;\n  }, function (t, e, r) {\n    var i, a, n, s, o;\n    i = /^((?:[a-zA-Z0-9+\\-.]+:)?)(\\/\\/[^\\/?#]*)?((?:[^\\/?#]*\\/)*[^;?#]*)?(;[^?#]*)?(\\?[^#]*)?(#[^]*)?$/, a = /^([^\\/?#]*)([^]*)$/, n = /(?:\\/|^)\\.(?=\\/)/g, s = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g, o = {\n      buildAbsoluteURL: function (t, e, r) {\n        if (r = r || {}, t = t.trim(), !(e = e.trim())) {\n          if (!r.alwaysNormalize) return t;\n          var i = o.parseURL(t);\n          if (!i) throw new Error(\"Error trying to parse base URL.\");\n          return i.path = o.normalizePath(i.path), o.buildURLFromParts(i);\n        }\n\n        var n = o.parseURL(e);\n        if (!n) throw new Error(\"Error trying to parse relative URL.\");\n        if (n.scheme) return r.alwaysNormalize ? (n.path = o.normalizePath(n.path), o.buildURLFromParts(n)) : e;\n        var s = o.parseURL(t);\n        if (!s) throw new Error(\"Error trying to parse base URL.\");\n\n        if (!s.netLoc && s.path && \"/\" !== s.path[0]) {\n          var l = a.exec(s.path);\n          s.netLoc = l[1], s.path = l[2];\n        }\n\n        s.netLoc && !s.path && (s.path = \"/\");\n        var u = {\n          scheme: s.scheme,\n          netLoc: n.netLoc,\n          path: null,\n          params: n.params,\n          query: n.query,\n          fragment: n.fragment\n        };\n        if (!n.netLoc && (u.netLoc = s.netLoc, \"/\" !== n.path[0])) if (n.path) {\n          var d = s.path,\n              h = d.substring(0, d.lastIndexOf(\"/\") + 1) + n.path;\n          u.path = o.normalizePath(h);\n        } else u.path = s.path, n.params || (u.params = s.params, n.query || (u.query = s.query));\n        return null === u.path && (u.path = r.alwaysNormalize ? o.normalizePath(n.path) : n.path), o.buildURLFromParts(u);\n      },\n      parseURL: function (t) {\n        var e = i.exec(t);\n        return e ? {\n          scheme: e[1] || \"\",\n          netLoc: e[2] || \"\",\n          path: e[3] || \"\",\n          params: e[4] || \"\",\n          query: e[5] || \"\",\n          fragment: e[6] || \"\"\n        } : null;\n      },\n      normalizePath: function (t) {\n        for (t = t.split(\"\").reverse().join(\"\").replace(n, \"\"); t.length !== (t = t.replace(s, \"\")).length;);\n\n        return t.split(\"\").reverse().join(\"\");\n      },\n      buildURLFromParts: function (t) {\n        return t.scheme + t.netLoc + t.path + t.params + t.query + t.fragment;\n      }\n    }, t.exports = o;\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"a\", function () {\n      return i;\n    });\n\n    var i = function () {\n      this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {\n        start: 0,\n        first: 0,\n        end: 0\n      }, this.parsing = {\n        start: 0,\n        end: 0\n      }, this.buffering = {\n        start: 0,\n        first: 0,\n        end: 0\n      };\n    };\n  }, function (t, e, r) {\n    \"use strict\";\n\n    var i = Object.prototype.hasOwnProperty,\n        a = \"~\";\n\n    function n() {}\n\n    function s(t, e, r) {\n      this.fn = t, this.context = e, this.once = r || !1;\n    }\n\n    function o(t, e, r, i, n) {\n      if (\"function\" != typeof r) throw new TypeError(\"The listener must be a function\");\n      var o = new s(r, i || t, n),\n          l = a ? a + e : e;\n      return t._events[l] ? t._events[l].fn ? t._events[l] = [t._events[l], o] : t._events[l].push(o) : (t._events[l] = o, t._eventsCount++), t;\n    }\n\n    function l(t, e) {\n      0 == --t._eventsCount ? t._events = new n() : delete t._events[e];\n    }\n\n    function u() {\n      this._events = new n(), this._eventsCount = 0;\n    }\n\n    Object.create && (n.prototype = Object.create(null), new n().__proto__ || (a = !1)), u.prototype.eventNames = function () {\n      var t,\n          e,\n          r = [];\n      if (0 === this._eventsCount) return r;\n\n      for (e in t = this._events) i.call(t, e) && r.push(a ? e.slice(1) : e);\n\n      return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(t)) : r;\n    }, u.prototype.listeners = function (t) {\n      var e = a ? a + t : t,\n          r = this._events[e];\n      if (!r) return [];\n      if (r.fn) return [r.fn];\n\n      for (var i = 0, n = r.length, s = new Array(n); i < n; i++) s[i] = r[i].fn;\n\n      return s;\n    }, u.prototype.listenerCount = function (t) {\n      var e = a ? a + t : t,\n          r = this._events[e];\n      return r ? r.fn ? 1 : r.length : 0;\n    }, u.prototype.emit = function (t, e, r, i, n, s) {\n      var o = a ? a + t : t;\n      if (!this._events[o]) return !1;\n      var l,\n          u,\n          d = this._events[o],\n          h = arguments.length;\n\n      if (d.fn) {\n        switch (d.once && this.removeListener(t, d.fn, void 0, !0), h) {\n          case 1:\n            return d.fn.call(d.context), !0;\n\n          case 2:\n            return d.fn.call(d.context, e), !0;\n\n          case 3:\n            return d.fn.call(d.context, e, r), !0;\n\n          case 4:\n            return d.fn.call(d.context, e, r, i), !0;\n\n          case 5:\n            return d.fn.call(d.context, e, r, i, n), !0;\n\n          case 6:\n            return d.fn.call(d.context, e, r, i, n, s), !0;\n        }\n\n        for (u = 1, l = new Array(h - 1); u < h; u++) l[u - 1] = arguments[u];\n\n        d.fn.apply(d.context, l);\n      } else {\n        var f,\n            c = d.length;\n\n        for (u = 0; u < c; u++) switch (d[u].once && this.removeListener(t, d[u].fn, void 0, !0), h) {\n          case 1:\n            d[u].fn.call(d[u].context);\n            break;\n\n          case 2:\n            d[u].fn.call(d[u].context, e);\n            break;\n\n          case 3:\n            d[u].fn.call(d[u].context, e, r);\n            break;\n\n          case 4:\n            d[u].fn.call(d[u].context, e, r, i);\n            break;\n\n          default:\n            if (!l) for (f = 1, l = new Array(h - 1); f < h; f++) l[f - 1] = arguments[f];\n            d[u].fn.apply(d[u].context, l);\n        }\n      }\n\n      return !0;\n    }, u.prototype.on = function (t, e, r) {\n      return o(this, t, e, r, !1);\n    }, u.prototype.once = function (t, e, r) {\n      return o(this, t, e, r, !0);\n    }, u.prototype.removeListener = function (t, e, r, i) {\n      var n = a ? a + t : t;\n      if (!this._events[n]) return this;\n      if (!e) return l(this, n), this;\n      var s = this._events[n];\n      if (s.fn) s.fn !== e || i && !s.once || r && s.context !== r || l(this, n);else {\n        for (var o = 0, u = [], d = s.length; o < d; o++) (s[o].fn !== e || i && !s[o].once || r && s[o].context !== r) && u.push(s[o]);\n\n        u.length ? this._events[n] = 1 === u.length ? u[0] : u : l(this, n);\n      }\n      return this;\n    }, u.prototype.removeAllListeners = function (t) {\n      var e;\n      return t ? (e = a ? a + t : t, this._events[e] && l(this, e)) : (this._events = new n(), this._eventsCount = 0), this;\n    }, u.prototype.off = u.prototype.removeListener, u.prototype.addListener = u.prototype.on, u.prefixed = a, u.EventEmitter = u, t.exports = u;\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"a\", function () {\n      return u;\n    });\n\n    var i = function () {\n      function t(t, e) {\n        this.subtle = void 0, this.aesIV = void 0, this.subtle = t, this.aesIV = e;\n      }\n\n      return t.prototype.decrypt = function (t, e) {\n        return this.subtle.decrypt({\n          name: \"AES-CBC\",\n          iv: this.aesIV\n        }, e, t);\n      }, t;\n    }(),\n        a = function () {\n      function t(t, e) {\n        this.subtle = void 0, this.key = void 0, this.subtle = t, this.key = e;\n      }\n\n      return t.prototype.expandKey = function () {\n        return this.subtle.importKey(\"raw\", this.key, {\n          name: \"AES-CBC\"\n        }, !1, [\"encrypt\", \"decrypt\"]);\n      }, t;\n    }(),\n        n = r(8);\n\n    var s = function () {\n      function t() {\n        this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable();\n      }\n\n      var e = t.prototype;\n      return e.uint8ArrayToUint32Array_ = function (t) {\n        for (var e = new DataView(t), r = new Uint32Array(4), i = 0; i < 4; i++) r[i] = e.getUint32(4 * i);\n\n        return r;\n      }, e.initTable = function () {\n        var t = this.sBox,\n            e = this.invSBox,\n            r = this.subMix,\n            i = r[0],\n            a = r[1],\n            n = r[2],\n            s = r[3],\n            o = this.invSubMix,\n            l = o[0],\n            u = o[1],\n            d = o[2],\n            h = o[3],\n            f = new Uint32Array(256),\n            c = 0,\n            v = 0,\n            g = 0;\n\n        for (g = 0; g < 256; g++) f[g] = g < 128 ? g << 1 : g << 1 ^ 283;\n\n        for (g = 0; g < 256; g++) {\n          var p = v ^ v << 1 ^ v << 2 ^ v << 3 ^ v << 4;\n          p = p >>> 8 ^ 255 & p ^ 99, t[c] = p, e[p] = c;\n          var m = f[c],\n              y = f[m],\n              b = f[y],\n              T = 257 * f[p] ^ 16843008 * p;\n          i[c] = T << 24 | T >>> 8, a[c] = T << 16 | T >>> 16, n[c] = T << 8 | T >>> 24, s[c] = T, T = 16843009 * b ^ 65537 * y ^ 257 * m ^ 16843008 * c, l[p] = T << 24 | T >>> 8, u[p] = T << 16 | T >>> 16, d[p] = T << 8 | T >>> 24, h[p] = T, c ? (c = m ^ f[f[f[b ^ m]]], v ^= f[f[v]]) : c = v = 1;\n        }\n      }, e.expandKey = function (t) {\n        for (var e = this.uint8ArrayToUint32Array_(t), r = !0, i = 0; i < e.length && r;) r = e[i] === this.key[i], i++;\n\n        if (!r) {\n          this.key = e;\n          var a = this.keySize = e.length;\n          if (4 !== a && 6 !== a && 8 !== a) throw new Error(\"Invalid aes key size=\" + a);\n          var n,\n              s,\n              o,\n              l,\n              u = this.ksRows = 4 * (a + 6 + 1),\n              d = this.keySchedule = new Uint32Array(u),\n              h = this.invKeySchedule = new Uint32Array(u),\n              f = this.sBox,\n              c = this.rcon,\n              v = this.invSubMix,\n              g = v[0],\n              p = v[1],\n              m = v[2],\n              y = v[3];\n\n          for (n = 0; n < u; n++) n < a ? o = d[n] = e[n] : (l = o, n % a == 0 ? (l = f[(l = l << 8 | l >>> 24) >>> 24] << 24 | f[l >>> 16 & 255] << 16 | f[l >>> 8 & 255] << 8 | f[255 & l], l ^= c[n / a | 0] << 24) : a > 6 && n % a == 4 && (l = f[l >>> 24] << 24 | f[l >>> 16 & 255] << 16 | f[l >>> 8 & 255] << 8 | f[255 & l]), d[n] = o = (d[n - a] ^ l) >>> 0);\n\n          for (s = 0; s < u; s++) n = u - s, l = 3 & s ? d[n] : d[n - 4], h[s] = s < 4 || n <= 4 ? l : g[f[l >>> 24]] ^ p[f[l >>> 16 & 255]] ^ m[f[l >>> 8 & 255]] ^ y[f[255 & l]], h[s] = h[s] >>> 0;\n        }\n      }, e.networkToHostOrderSwap = function (t) {\n        return t << 24 | (65280 & t) << 8 | (16711680 & t) >> 8 | t >>> 24;\n      }, e.decrypt = function (t, e, r) {\n        for (var i, a, n, s, o, l, u, d, h, f, c, v, g, p, m = this.keySize + 6, y = this.invKeySchedule, b = this.invSBox, T = this.invSubMix, E = T[0], S = T[1], L = T[2], A = T[3], R = this.uint8ArrayToUint32Array_(r), D = R[0], _ = R[1], k = R[2], x = R[3], C = new Int32Array(t), w = new Int32Array(C.length), O = this.networkToHostOrderSwap; e < C.length;) {\n          for (h = O(C[e]), f = O(C[e + 1]), c = O(C[e + 2]), v = O(C[e + 3]), o = h ^ y[0], l = v ^ y[1], u = c ^ y[2], d = f ^ y[3], g = 4, p = 1; p < m; p++) i = E[o >>> 24] ^ S[l >> 16 & 255] ^ L[u >> 8 & 255] ^ A[255 & d] ^ y[g], a = E[l >>> 24] ^ S[u >> 16 & 255] ^ L[d >> 8 & 255] ^ A[255 & o] ^ y[g + 1], n = E[u >>> 24] ^ S[d >> 16 & 255] ^ L[o >> 8 & 255] ^ A[255 & l] ^ y[g + 2], s = E[d >>> 24] ^ S[o >> 16 & 255] ^ L[l >> 8 & 255] ^ A[255 & u] ^ y[g + 3], o = i, l = a, u = n, d = s, g += 4;\n\n          i = b[o >>> 24] << 24 ^ b[l >> 16 & 255] << 16 ^ b[u >> 8 & 255] << 8 ^ b[255 & d] ^ y[g], a = b[l >>> 24] << 24 ^ b[u >> 16 & 255] << 16 ^ b[d >> 8 & 255] << 8 ^ b[255 & o] ^ y[g + 1], n = b[u >>> 24] << 24 ^ b[d >> 16 & 255] << 16 ^ b[o >> 8 & 255] << 8 ^ b[255 & l] ^ y[g + 2], s = b[d >>> 24] << 24 ^ b[o >> 16 & 255] << 16 ^ b[l >> 8 & 255] << 8 ^ b[255 & u] ^ y[g + 3], w[e] = O(i ^ D), w[e + 1] = O(s ^ _), w[e + 2] = O(n ^ k), w[e + 3] = O(a ^ x), D = h, _ = f, k = c, x = v, e += 4;\n        }\n\n        return w.buffer;\n      }, t;\n    }(),\n        o = r(1),\n        l = r(6),\n        u = function () {\n      function t(t, e, r) {\n        var i = (void 0 === r ? {} : r).removePKCS7Padding,\n            a = void 0 === i || i;\n        if (this.logEnabled = !0, this.observer = void 0, this.config = void 0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.observer = t, this.config = e, this.removePKCS7Padding = a, a) try {\n          var n = self.crypto;\n          n && (this.subtle = n.subtle || n.webkitSubtle);\n        } catch (t) {}\n        null === this.subtle && (this.config.enableSoftwareAES = !0);\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        this.observer = null;\n      }, e.isSync = function () {\n        return this.config.enableSoftwareAES;\n      }, e.flush = function () {\n        var t = this.currentResult;\n\n        if (t) {\n          var e,\n              r,\n              i,\n              a = new Uint8Array(t);\n          return this.reset(), this.removePKCS7Padding ? (r = (e = a).byteLength, (i = r && new DataView(e.buffer).getUint8(r - 1)) ? Object(n.a)(e, 0, r - i) : e) : a;\n        }\n\n        this.reset();\n      }, e.reset = function () {\n        this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null);\n      }, e.decrypt = function (t, e, r, i) {\n        if (this.config.enableSoftwareAES) {\n          this.softwareDecrypt(new Uint8Array(t), e, r);\n          var a = this.flush();\n          a && i(a.buffer);\n        } else this.webCryptoDecrypt(new Uint8Array(t), e, r).then(i);\n      }, e.softwareDecrypt = function (t, e, r) {\n        var i = this.currentIV,\n            a = this.currentResult,\n            o = this.remainderData;\n        this.logOnce(\"JS AES decrypt\"), o && (t = Object(l.a)(o, t), this.remainderData = null);\n        var u = this.getValidChunk(t);\n        if (!u.length) return null;\n        i && (r = i);\n        var d = this.softwareDecrypter;\n        d || (d = this.softwareDecrypter = new s()), d.expandKey(e);\n        var h = a;\n        return this.currentResult = d.decrypt(u.buffer, 0, r), this.currentIV = Object(n.a)(u, -16).buffer, h || null;\n      }, e.webCryptoDecrypt = function (t, e, r) {\n        var n = this,\n            s = this.subtle;\n        return this.key === e && this.fastAesKey || (this.key = e, this.fastAesKey = new a(s, e)), this.fastAesKey.expandKey().then(function (e) {\n          return s ? new i(s, r).decrypt(t.buffer, e) : Promise.reject(new Error(\"web crypto not initialized\"));\n        }).catch(function (i) {\n          return n.onWebCryptoError(i, t, e, r);\n        });\n      }, e.onWebCryptoError = function (t, e, r, i) {\n        return o.b.warn(\"[decrypter.ts]: WebCrypto Error, disable WebCrypto API:\", t), this.config.enableSoftwareAES = !0, this.logEnabled = !0, this.softwareDecrypt(e, r, i);\n      }, e.getValidChunk = function (t) {\n        var e = t,\n            r = t.length - t.length % 16;\n        return r !== t.length && (e = Object(n.a)(t, 0, r), this.remainderData = Object(n.a)(t, r)), e;\n      }, e.logOnce = function (t) {\n        this.logEnabled && (o.b.log(\"[decrypter.ts]: \" + t), this.logEnabled = !1);\n      }, t;\n    }();\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"a\", function () {\n      return n;\n    });\n    var i = r(11);\n\n    function a(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    var n = function () {\n      function t(t, e) {\n        this._uri = null, this.method = null, this.keyFormat = null, this.keyFormatVersions = null, this.keyID = null, this.key = null, this.iv = null, this._uri = e ? Object(i.buildAbsoluteURL)(t, e, {\n          alwaysNormalize: !0\n        }) : t;\n      }\n\n      var e, r, n;\n      return t.fromURL = function (e, r) {\n        return new t(e, r);\n      }, t.fromURI = function (e) {\n        return new t(e);\n      }, e = t, (r = [{\n        key: \"uri\",\n        get: function () {\n          return this._uri;\n        }\n      }]) && a(e.prototype, r), n && a(e, n), t;\n    }();\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.d(e, \"a\", function () {\n      return i;\n    });\n\n    var i = function () {\n      function t() {\n        this.chunks = [], this.dataLength = 0;\n      }\n\n      var e = t.prototype;\n      return e.push = function (t) {\n        this.chunks.push(t), this.dataLength += t.length;\n      }, e.flush = function () {\n        var t,\n            e = this.chunks,\n            r = this.dataLength;\n        return e.length ? (t = 1 === e.length ? e[0] : function (t, e) {\n          for (var r = new Uint8Array(e), i = 0, a = 0; a < t.length; a++) {\n            var n = t[a];\n            r.set(n, i), i += n.length;\n          }\n\n          return r;\n        }(e, r), this.reset(), t) : new Uint8Array(0);\n      }, e.reset = function () {\n        this.chunks.length = 0, this.dataLength = 0;\n      }, t;\n    }();\n  }, function (t, e, r) {\n    function i(t) {\n      var e = {};\n\n      function r(i) {\n        if (e[i]) return e[i].exports;\n        var a = e[i] = {\n          i: i,\n          l: !1,\n          exports: {}\n        };\n        return t[i].call(a.exports, a, a.exports, r), a.l = !0, a.exports;\n      }\n\n      r.m = t, r.c = e, r.i = function (t) {\n        return t;\n      }, r.d = function (t, e, i) {\n        r.o(t, e) || Object.defineProperty(t, e, {\n          configurable: !1,\n          enumerable: !0,\n          get: i\n        });\n      }, r.r = function (t) {\n        Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      }, r.n = function (t) {\n        var e = t && t.__esModule ? function () {\n          return t.default;\n        } : function () {\n          return t;\n        };\n        return r.d(e, \"a\", e), e;\n      }, r.o = function (t, e) {\n        return Object.prototype.hasOwnProperty.call(t, e);\n      }, r.p = \"/\", r.oe = function (t) {\n        throw console.error(t), t;\n      };\n      var i = r(r.s = ENTRY_MODULE);\n      return i.default || i;\n    }\n\n    function a(t) {\n      return (t + \"\").replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"\\\\$&\");\n    }\n\n    function n(t, e, i) {\n      var n = {};\n      n[i] = [];\n      var s = e.toString(),\n          o = s.match(/^function\\s?\\w*\\(\\w+,\\s*\\w+,\\s*(\\w+)\\)/);\n      if (!o) return n;\n\n      for (var l, u = o[1], d = new RegExp(\"(\\\\\\\\n|\\\\W)\" + a(u) + \"\\\\(\\\\s*(/\\\\*.*?\\\\*/)?\\\\s*.*?([\\\\.|\\\\-|\\\\+|\\\\w|/|@]+).*?\\\\)\", \"g\"); l = d.exec(s);) \"dll-reference\" !== l[3] && n[i].push(l[3]);\n\n      for (d = new RegExp(\"\\\\(\" + a(u) + '\\\\(\"(dll-reference\\\\s([\\\\.|\\\\-|\\\\+|\\\\w|/|@]+))\"\\\\)\\\\)\\\\(\\\\s*(/\\\\*.*?\\\\*/)?\\\\s*.*?([\\\\.|\\\\-|\\\\+|\\\\w|/|@]+).*?\\\\)', \"g\"); l = d.exec(s);) t[l[2]] || (n[i].push(l[1]), t[l[2]] = r(l[1]).m), n[l[2]] = n[l[2]] || [], n[l[2]].push(l[4]);\n\n      for (var h, f = Object.keys(n), c = 0; c < f.length; c++) for (var v = 0; v < n[f[c]].length; v++) h = n[f[c]][v], isNaN(1 * h) || (n[f[c]][v] = 1 * n[f[c]][v]);\n\n      return n;\n    }\n\n    function s(t) {\n      return Object.keys(t).reduce(function (e, r) {\n        return e || t[r].length > 0;\n      }, !1);\n    }\n\n    t.exports = function (t, e) {\n      e = e || {};\n      var a = {\n        main: r.m\n      },\n          o = e.all ? {\n        main: Object.keys(a.main)\n      } : function (t, e) {\n        for (var r = {\n          main: [e]\n        }, i = {\n          main: []\n        }, a = {\n          main: {}\n        }; s(r);) for (var o = Object.keys(r), l = 0; l < o.length; l++) {\n          var u = o[l],\n              d = r[u].pop();\n\n          if (a[u] = a[u] || {}, !a[u][d] && t[u][d]) {\n            a[u][d] = !0, i[u] = i[u] || [], i[u].push(d);\n\n            for (var h = n(t, t[u][d], u), f = Object.keys(h), c = 0; c < f.length; c++) r[f[c]] = r[f[c]] || [], r[f[c]] = r[f[c]].concat(h[f[c]]);\n          }\n        }\n\n        return i;\n      }(a, t),\n          l = \"\";\n      Object.keys(o).filter(function (t) {\n        return \"main\" !== t;\n      }).forEach(function (t) {\n        for (var e = 0; o[t][e];) e++;\n\n        o[t].push(e), a[t][e] = \"(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })\", l = l + \"var \" + t + \" = (\" + i.toString().replace(\"ENTRY_MODULE\", JSON.stringify(e)) + \")({\" + o[t].map(function (e) {\n          return JSON.stringify(e) + \": \" + a[t][e].toString();\n        }).join(\",\") + \"});\\n\";\n      }), l = l + \"new ((\" + i.toString().replace(\"ENTRY_MODULE\", JSON.stringify(t)) + \")({\" + o.main.map(function (t) {\n        return JSON.stringify(t) + \": \" + a.main[t].toString();\n      }).join(\",\") + \"}))(self);\";\n      var u = new window.Blob([l], {\n        type: \"text/javascript\"\n      });\n      if (e.bare) return u;\n      var d = (window.URL || window.webkitURL || window.mozURL || window.msURL).createObjectURL(u),\n          h = new window.Worker(d);\n      return h.objectURL = d, h;\n    };\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.r(e), r.d(e, \"default\", function () {\n      return o;\n    });\n    var i = r(9),\n        a = r(0),\n        n = r(1),\n        s = r(13);\n\n    function o(t) {\n      var e = new s.EventEmitter(),\n          r = function (e, r) {\n        t.postMessage({\n          event: e,\n          data: r\n        });\n      };\n\n      e.on(a.a.FRAG_DECRYPTED, r), e.on(a.a.ERROR, r), t.addEventListener(\"message\", function (a) {\n        var s = a.data;\n\n        switch (s.cmd) {\n          case \"init\":\n            var o = JSON.parse(s.config);\n            t.transmuxer = new i.c(e, s.typeSupported, o, s.vendor, s.id), Object(n.a)(o.debug), r(\"init\", null);\n            break;\n\n          case \"configure\":\n            t.transmuxer.configure(s.config);\n            break;\n\n          case \"demux\":\n            var u = t.transmuxer.push(s.data, s.decryptdata, s.chunkMeta, s.state);\n            Object(i.d)(u) ? u.then(function (e) {\n              l(t, e);\n            }) : l(t, u);\n            break;\n\n          case \"flush\":\n            var h = s.chunkMeta,\n                f = t.transmuxer.flush(h);\n            Object(i.d)(f) ? f.then(function (e) {\n              d(t, e, h);\n            }) : d(t, f, h);\n        }\n      });\n    }\n\n    function l(t, e) {\n      if ((r = e.remuxResult).audio || r.video || r.text || r.id3 || r.initSegment) {\n        var r,\n            i = [],\n            a = e.remuxResult,\n            n = a.audio,\n            s = a.video;\n        n && u(i, n), s && u(i, s), t.postMessage({\n          event: \"transmuxComplete\",\n          data: e\n        }, i);\n      }\n    }\n\n    function u(t, e) {\n      e.data1 && t.push(e.data1.buffer), e.data2 && t.push(e.data2.buffer);\n    }\n\n    function d(t, e, r) {\n      e.forEach(function (e) {\n        l(t, e);\n      }), t.postMessage({\n        event: \"flush\",\n        data: r\n      });\n    }\n  }, function (t, e, r) {\n    \"use strict\";\n\n    r.r(e), r.d(e, \"default\", function () {\n      return we;\n    });\n    var i = r(11),\n        a = r(3),\n        n = r(0),\n        s = r(2),\n        o = r(1),\n        l = r(6),\n        u = r(5);\n\n    function d(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    var h = function () {\n      function t(t) {\n        this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.live = !0, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.availabilityDelay = void 0, this.misses = 0, this.needSidxRanges = !1, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = \"\", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.fragments = [], this.url = t;\n      }\n\n      var e, r, i;\n      return t.prototype.reloaded = function (t) {\n        if (!t) return this.advanced = !0, void (this.updated = !0);\n        var e = this.lastPartSn - t.lastPartSn,\n            r = this.lastPartIndex - t.lastPartIndex;\n        this.updated = this.endSN !== t.endSN || !!r || !!e, this.advanced = this.endSN > t.endSN || e > 0 || 0 === e && r > 0, this.updated || this.advanced ? this.misses = Math.floor(.6 * t.misses) : this.misses = t.misses + 1, this.availabilityDelay = t.availabilityDelay;\n      }, e = t, (r = [{\n        key: \"hasProgramDateTime\",\n        get: function () {\n          return !!this.fragments.length && Object(a.a)(this.fragments[this.fragments.length - 1].programDateTime);\n        }\n      }, {\n        key: \"levelTargetDuration\",\n        get: function () {\n          return this.averagetargetduration || this.targetduration || 10;\n        }\n      }, {\n        key: \"drift\",\n        get: function () {\n          var t = this.driftEndTime - this.driftStartTime;\n          return t > 0 ? 1e3 * (this.driftEnd - this.driftStart) / t : 1;\n        }\n      }, {\n        key: \"edge\",\n        get: function () {\n          return this.partEnd || this.fragmentEnd;\n        }\n      }, {\n        key: \"partEnd\",\n        get: function () {\n          var t;\n          return null !== (t = this.partList) && void 0 !== t && t.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd;\n        }\n      }, {\n        key: \"fragmentEnd\",\n        get: function () {\n          var t;\n          return null !== (t = this.fragments) && void 0 !== t && t.length ? this.fragments[this.fragments.length - 1].end : 0;\n        }\n      }, {\n        key: \"age\",\n        get: function () {\n          return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0;\n        }\n      }, {\n        key: \"lastPartIndex\",\n        get: function () {\n          var t;\n          return null !== (t = this.partList) && void 0 !== t && t.length ? this.partList[this.partList.length - 1].index : -1;\n        }\n      }, {\n        key: \"lastPartSn\",\n        get: function () {\n          var t;\n          return null !== (t = this.partList) && void 0 !== t && t.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN;\n        }\n      }]) && d(e.prototype, r), i && d(e, i), t;\n    }(),\n        f = r(15),\n        c = /^(\\d+)x(\\d+)$/,\n        v = /\\s*(.+?)\\s*=((?:\\\".*?\\\")|.*?)(?:,|$)/g,\n        g = function () {\n      function t(e) {\n        for (var r in \"string\" == typeof e && (e = t.parseAttrList(e)), e) e.hasOwnProperty(r) && (this[r] = e[r]);\n      }\n\n      var e = t.prototype;\n      return e.decimalInteger = function (t) {\n        var e = parseInt(this[t], 10);\n        return e > Number.MAX_SAFE_INTEGER ? 1 / 0 : e;\n      }, e.hexadecimalInteger = function (t) {\n        if (this[t]) {\n          var e = (this[t] || \"0x\").slice(2);\n          e = (1 & e.length ? \"0\" : \"\") + e;\n\n          for (var r = new Uint8Array(e.length / 2), i = 0; i < e.length / 2; i++) r[i] = parseInt(e.slice(2 * i, 2 * i + 2), 16);\n\n          return r;\n        }\n\n        return null;\n      }, e.hexadecimalIntegerAsNumber = function (t) {\n        var e = parseInt(this[t], 16);\n        return e > Number.MAX_SAFE_INTEGER ? 1 / 0 : e;\n      }, e.decimalFloatingPoint = function (t) {\n        return parseFloat(this[t]);\n      }, e.optionalFloat = function (t, e) {\n        var r = this[t];\n        return r ? parseFloat(r) : e;\n      }, e.enumeratedString = function (t) {\n        return this[t];\n      }, e.bool = function (t) {\n        return \"YES\" === this[t];\n      }, e.decimalResolution = function (t) {\n        var e = c.exec(this[t]);\n        if (null !== e) return {\n          width: parseInt(e[1], 10),\n          height: parseInt(e[2], 10)\n        };\n      }, t.parseAttrList = function (t) {\n        var e,\n            r = {};\n\n        for (v.lastIndex = 0; null !== (e = v.exec(t));) {\n          var i = e[2];\n          0 === i.indexOf('\"') && i.lastIndexOf('\"') === i.length - 1 && (i = i.slice(1, -1)), r[e[1]] = i;\n        }\n\n        return r;\n      }, t;\n    }(),\n        p = {\n      audio: {\n        a3ds: !0,\n        \"ac-3\": !0,\n        \"ac-4\": !0,\n        alac: !0,\n        alaw: !0,\n        dra1: !0,\n        \"dts+\": !0,\n        \"dts-\": !0,\n        dtsc: !0,\n        dtse: !0,\n        dtsh: !0,\n        \"ec-3\": !0,\n        enca: !0,\n        g719: !0,\n        g726: !0,\n        m4ae: !0,\n        mha1: !0,\n        mha2: !0,\n        mhm1: !0,\n        mhm2: !0,\n        mlpa: !0,\n        mp4a: !0,\n        \"raw \": !0,\n        Opus: !0,\n        samr: !0,\n        sawb: !0,\n        sawp: !0,\n        sevc: !0,\n        sqcp: !0,\n        ssmv: !0,\n        twos: !0,\n        ulaw: !0\n      },\n      video: {\n        avc1: !0,\n        avc2: !0,\n        avc3: !0,\n        avc4: !0,\n        avcp: !0,\n        av01: !0,\n        drac: !0,\n        dvav: !0,\n        dvhe: !0,\n        encv: !0,\n        hev1: !0,\n        hvc1: !0,\n        mjp2: !0,\n        mp4v: !0,\n        mvc1: !0,\n        mvc2: !0,\n        mvc3: !0,\n        mvc4: !0,\n        resv: !0,\n        rv60: !0,\n        s263: !0,\n        svc1: !0,\n        svc2: !0,\n        \"vc-1\": !0,\n        vp08: !0,\n        vp09: !0\n      },\n      text: {\n        stpp: !0,\n        wvtt: !0\n      }\n    };\n\n    function m(t, e) {\n      return MediaSource.isTypeSupported((e || \"video\") + '/mp4;codecs=\"' + t + '\"');\n    }\n\n    var y = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-SESSION-DATA:([^\\r\\n]*)[\\r\\n]+/g,\n        b = /#EXT-X-MEDIA:(.*)/g,\n        T = new RegExp([/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source, /(?!#) *(\\S[\\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join(\"|\"), \"g\"),\n        E = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(PLAYLIST-TYPE):(.+)/.source, /#EXT-X-(MEDIA-SEQUENCE): *(\\d+)/.source, /#EXT-X-(SKIP):(.+)/.source, /#EXT-X-(TARGETDURATION): *(\\d+)/.source, /#EXT-X-(KEY):(.+)/.source, /#EXT-X-(START):(.+)/.source, /#EXT-X-(ENDLIST)/.source, /#EXT-X-(DISCONTINUITY-SEQ)UENCE: *(\\d+)/.source, /#EXT-X-(DIS)CONTINUITY/.source, /#EXT-X-(VERSION):(\\d+)/.source, /#EXT-X-(MAP):(.+)/.source, /#EXT-X-(SERVER-CONTROL):(.+)/.source, /#EXT-X-(PART-INF):(.+)/.source, /#EXT-X-(GAP)/.source, /#EXT-X-(BITRATE):\\s*(\\d+)/.source, /#EXT-X-(PART):(.+)/.source, /#EXT-X-(PRELOAD-HINT):(.+)/.source, /#EXT-X-(RENDITION-REPORT):(.+)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\\r?\\n?/.source].join(\"|\")),\n        S = /\\.(mp4|m4s|m4v|m4a)$/i;\n\n    var L = function () {\n      function t() {}\n\n      return t.findGroup = function (t, e) {\n        for (var r = 0; r < t.length; r++) {\n          var i = t[r];\n          if (i.id === e) return i;\n        }\n      }, t.convertAVC1ToAVCOTI = function (t) {\n        var e = t.split(\".\");\n\n        if (e.length > 2) {\n          var r = e.shift() + \".\";\n          return r += parseInt(e.shift()).toString(16), r += (\"000\" + parseInt(e.shift()).toString(16)).substr(-4);\n        }\n\n        return t;\n      }, t.resolve = function (t, e) {\n        return i.buildAbsoluteURL(e, t, {\n          alwaysNormalize: !0\n        });\n      }, t.parseMasterPlaylist = function (e, r) {\n        var i,\n            a = [],\n            n = {},\n            s = !1;\n\n        for (y.lastIndex = 0; null != (i = y.exec(e));) if (i[1]) {\n          var o = new g(i[1]),\n              l = {\n            attrs: o,\n            bitrate: o.decimalInteger(\"AVERAGE-BANDWIDTH\") || o.decimalInteger(\"BANDWIDTH\"),\n            name: o.NAME,\n            url: t.resolve(i[2], r)\n          },\n              u = o.decimalResolution(\"RESOLUTION\");\n          u && (l.width = u.width, l.height = u.height), A((o.CODECS || \"\").split(/[ ,]+/).filter(function (t) {\n            return t;\n          }), l), l.videoCodec && -1 !== l.videoCodec.indexOf(\"avc1\") && (l.videoCodec = t.convertAVC1ToAVCOTI(l.videoCodec)), a.push(l);\n        } else if (i[3]) {\n          var d = new g(i[3]);\n          d[\"DATA-ID\"] && (s = !0, n[d[\"DATA-ID\"]] = d);\n        }\n\n        return {\n          levels: a,\n          sessionData: s ? n : null\n        };\n      }, t.parseMasterPlaylistMedia = function (e, r, i, a) {\n        var n;\n        void 0 === a && (a = []);\n        var s = [],\n            o = 0;\n\n        for (b.lastIndex = 0; null !== (n = b.exec(e));) {\n          var l = new g(n[1]);\n\n          if (l.TYPE === i) {\n            var u = {\n              attrs: l,\n              bitrate: 0,\n              id: o++,\n              groupId: l[\"GROUP-ID\"],\n              instreamId: l[\"INSTREAM-ID\"],\n              name: l.NAME || l.LANGUAGE || \"\",\n              type: i,\n              default: l.bool(\"DEFAULT\"),\n              autoselect: l.bool(\"AUTOSELECT\"),\n              forced: l.bool(\"FORCED\"),\n              lang: l.LANGUAGE,\n              url: l.URI ? t.resolve(l.URI, r) : \"\"\n            };\n\n            if (a.length) {\n              var d = t.findGroup(a, u.groupId) || a[0];\n              R(u, d, \"audioCodec\"), R(u, d, \"textCodec\");\n            }\n\n            s.push(u);\n          }\n        }\n\n        return s;\n      }, t.parseLevelPlaylist = function (t, e, r, n, s) {\n        var l,\n            d,\n            c,\n            v = new h(e),\n            p = v.fragments,\n            m = null,\n            y = 0,\n            b = 0,\n            L = 0,\n            A = 0,\n            R = null,\n            _ = new u.b(n, e),\n            k = -1,\n            x = !1;\n\n        for (T.lastIndex = 0, v.m3u8 = t; null !== (l = T.exec(t));) {\n          x && (x = !1, (_ = new u.b(n, e)).start = L, _.sn = y, _.cc = A, _.level = r, m && (_.initSegment = m, _.rawProgramDateTime = m.rawProgramDateTime));\n          var C = l[1];\n\n          if (C) {\n            _.duration = parseFloat(C);\n            var w = (\" \" + l[2]).slice(1);\n            _.title = w || null, _.tagList.push(w ? [\"INF\", C, w] : [\"INF\", C]);\n          } else if (l[3]) Object(a.a)(_.duration) && (_.start = L, c && (_.levelkey = c), _.sn = y, _.level = r, _.cc = A, _.urlId = s, p.push(_), _.relurl = (\" \" + l[3]).slice(1), D(_, R), R = _, L += _.duration, y++, b = 0, x = !0);else if (l[4]) {\n            var O = (\" \" + l[4]).slice(1);\n            R ? _.setByteRange(O, R) : _.setByteRange(O);\n          } else if (l[5]) _.rawProgramDateTime = (\" \" + l[5]).slice(1), _.tagList.push([\"PROGRAM-DATE-TIME\", _.rawProgramDateTime]), -1 === k && (k = p.length);else {\n            if (!(l = l[0].match(E))) {\n              o.b.warn(\"No matches on slow regex match for level playlist!\");\n              continue;\n            }\n\n            for (d = 1; d < l.length && void 0 === l[d]; d++);\n\n            var I = (\" \" + l[d]).slice(1),\n                P = (\" \" + l[d + 1]).slice(1),\n                F = l[d + 2] ? (\" \" + l[d + 2]).slice(1) : \"\";\n\n            switch (I) {\n              case \"PLAYLIST-TYPE\":\n                v.type = P.toUpperCase();\n                break;\n\n              case \"MEDIA-SEQUENCE\":\n                y = v.startSN = parseInt(P);\n                break;\n\n              case \"SKIP\":\n                var M = new g(P),\n                    N = M.decimalInteger(\"SKIPPED-SEGMENTS\");\n\n                if (Object(a.a)(N)) {\n                  v.skippedSegments = N;\n\n                  for (var B = N; B--;) p.unshift(null);\n\n                  y += N;\n                }\n\n                var U = M.enumeratedString(\"RECENTLY-REMOVED-DATERANGES\");\n                U && (v.recentlyRemovedDateranges = U.split(\"\\t\"));\n                break;\n\n              case \"TARGETDURATION\":\n                v.targetduration = parseFloat(P);\n                break;\n\n              case \"VERSION\":\n                v.version = parseInt(P);\n                break;\n\n              case \"EXTM3U\":\n                break;\n\n              case \"ENDLIST\":\n                v.live = !1;\n                break;\n\n              case \"#\":\n                (P || F) && _.tagList.push(F ? [P, F] : [P]);\n                break;\n\n              case \"DIS\":\n                A++;\n\n              case \"GAP\":\n                _.tagList.push([I]);\n\n                break;\n\n              case \"BITRATE\":\n                _.tagList.push([I, P]);\n\n                break;\n\n              case \"DISCONTINUITY-SEQ\":\n                A = parseInt(P);\n                break;\n\n              case \"KEY\":\n                var G,\n                    j = new g(P),\n                    H = j.enumeratedString(\"METHOD\"),\n                    K = j.URI,\n                    V = j.hexadecimalInteger(\"IV\"),\n                    W = j.enumeratedString(\"KEYFORMATVERSIONS\"),\n                    Y = j.enumeratedString(\"KEYID\"),\n                    X = null != (G = j.enumeratedString(\"KEYFORMAT\")) ? G : \"identity\";\n\n                if ([\"com.apple.streamingkeydelivery\", \"com.microsoft.playready\", \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\", \"com.widevine\"].indexOf(X) > -1) {\n                  o.b.warn(\"Keyformat \" + X + \" is not supported from the manifest\");\n                  continue;\n                }\n\n                if (\"identity\" !== X) continue;\n                H && (c = f.a.fromURL(e, K), K && [\"AES-128\", \"SAMPLE-AES\", \"SAMPLE-AES-CENC\"].indexOf(H) >= 0 && (c.method = H, c.keyFormat = X, Y && (c.keyID = Y), W && (c.keyFormatVersions = W), c.iv = V));\n                break;\n\n              case \"START\":\n                var q = new g(P).decimalFloatingPoint(\"TIME-OFFSET\");\n                Object(a.a)(q) && (v.startTimeOffset = q);\n                break;\n\n              case \"MAP\":\n                var z = new g(P);\n                _.relurl = z.URI, z.BYTERANGE && _.setByteRange(z.BYTERANGE), _.level = r, _.sn = \"initSegment\", c && (_.levelkey = c), _.initSegment = null, m = _, x = !0;\n                break;\n\n              case \"SERVER-CONTROL\":\n                var Q = new g(P);\n                v.canBlockReload = Q.bool(\"CAN-BLOCK-RELOAD\"), v.canSkipUntil = Q.optionalFloat(\"CAN-SKIP-UNTIL\", 0), v.canSkipDateRanges = v.canSkipUntil > 0 && Q.bool(\"CAN-SKIP-DATERANGES\"), v.partHoldBack = Q.optionalFloat(\"PART-HOLD-BACK\", 0), v.holdBack = Q.optionalFloat(\"HOLD-BACK\", 0);\n                break;\n\n              case \"PART-INF\":\n                var $ = new g(P);\n                v.partTarget = $.decimalFloatingPoint(\"PART-TARGET\");\n                break;\n\n              case \"PART\":\n                var Z = v.partList;\n                Z || (Z = v.partList = []);\n                var J = b > 0 ? Z[Z.length - 1] : void 0,\n                    tt = b++,\n                    et = new u.c(new g(P), _, e, tt, J);\n                Z.push(et), _.duration += et.duration;\n                break;\n\n              case \"PRELOAD-HINT\":\n                var rt = new g(P);\n                v.preloadHint = rt;\n                break;\n\n              case \"RENDITION-REPORT\":\n                var it = new g(P);\n                v.renditionReports = v.renditionReports || [], v.renditionReports.push(it);\n                break;\n\n              default:\n                o.b.warn(\"line parsed but not handled: \" + l);\n            }\n          }\n        }\n\n        R && !R.relurl ? (p.pop(), L -= R.duration, v.partList && (v.fragmentHint = R)) : v.partList && (D(_, R), _.cc = A, v.fragmentHint = _);\n        var at = p.length,\n            nt = p[0],\n            st = p[at - 1];\n\n        if ((L += v.skippedSegments * v.targetduration) > 0 && at && st) {\n          v.averagetargetduration = L / at;\n          var ot = st.sn;\n          v.endSN = \"initSegment\" !== ot ? ot : 0, nt && (v.startCC = nt.cc, nt.initSegment || v.fragments.every(function (t) {\n            return t.relurl && (e = t.relurl, S.test(null != (r = null === (a = i.parseURL(e)) || void 0 === a ? void 0 : a.path) ? r : \"\"));\n            var e, r, a;\n          }) && (o.b.warn(\"MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX\"), (_ = new u.b(n, e)).relurl = st.relurl, _.level = r, _.sn = \"initSegment\", nt.initSegment = _, v.needSidxRanges = !0));\n        } else v.endSN = 0, v.startCC = 0;\n\n        return v.fragmentHint && (L += v.fragmentHint.duration), v.totalduration = L, v.endCC = A, k > 0 && function (t, e) {\n          for (var r = t[e], i = e; i--;) {\n            var a = t[i];\n            if (!a) return;\n            a.programDateTime = r.programDateTime - 1e3 * a.duration, r = a;\n          }\n        }(p, k), v;\n      }, t;\n    }();\n\n    function A(t, e) {\n      [\"video\", \"audio\", \"text\"].forEach(function (r) {\n        var i = t.filter(function (t) {\n          return function (t, e) {\n            var r = p[e];\n            return !!r && !0 === r[t.slice(0, 4)];\n          }(t, r);\n        });\n\n        if (i.length) {\n          var a = i.filter(function (t) {\n            return 0 === t.lastIndexOf(\"avc1\", 0) || 0 === t.lastIndexOf(\"mp4a\", 0);\n          });\n          e[r + \"Codec\"] = a.length > 0 ? a[0] : i[0], t = t.filter(function (t) {\n            return -1 === i.indexOf(t);\n          });\n        }\n      }), e.unknownCodecs = t;\n    }\n\n    function R(t, e, r) {\n      var i = e[r];\n      i && (t[r] = i);\n    }\n\n    function D(t, e) {\n      t.rawProgramDateTime ? t.programDateTime = Date.parse(t.rawProgramDateTime) : null != e && e.programDateTime && (t.programDateTime = e.endProgramDateTime), Object(a.a)(t.programDateTime) || (t.programDateTime = null, t.rawProgramDateTime = null);\n    }\n\n    var _ = r(4);\n\n    function k(t, e) {\n      var r = t.url;\n      return void 0 !== r && 0 !== r.indexOf(\"data:\") || (r = e.url), r;\n    }\n\n    var x = function () {\n      function t(t) {\n        this.hls = void 0, this.loaders = Object.create(null), this.hls = t, this.registerListeners();\n      }\n\n      var e = t.prototype;\n      return e.registerListeners = function () {\n        var t = this.hls;\n        t.on(n.a.MANIFEST_LOADING, this.onManifestLoading, this), t.on(n.a.LEVEL_LOADING, this.onLevelLoading, this), t.on(n.a.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), t.on(n.a.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n      }, e.unregisterListeners = function () {\n        var t = this.hls;\n        t.off(n.a.MANIFEST_LOADING, this.onManifestLoading, this), t.off(n.a.LEVEL_LOADING, this.onLevelLoading, this), t.off(n.a.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), t.off(n.a.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n      }, e.createInternalLoader = function (t) {\n        var e = this.hls.config,\n            r = e.pLoader,\n            i = e.loader,\n            a = new (r || i)(e);\n        return t.loader = a, this.loaders[t.type] = a, a;\n      }, e.getInternalLoader = function (t) {\n        return this.loaders[t.type];\n      }, e.resetInternalLoader = function (t) {\n        this.loaders[t] && delete this.loaders[t];\n      }, e.destroyInternalLoaders = function () {\n        for (var t in this.loaders) {\n          var e = this.loaders[t];\n          e && e.destroy(), this.resetInternalLoader(t);\n        }\n      }, e.destroy = function () {\n        this.unregisterListeners(), this.destroyInternalLoaders();\n      }, e.onManifestLoading = function (t, e) {\n        var r = e.url;\n        this.load({\n          id: null,\n          groupId: null,\n          level: 0,\n          responseType: \"text\",\n          type: _.a.MANIFEST,\n          url: r,\n          deliveryDirectives: null\n        });\n      }, e.onLevelLoading = function (t, e) {\n        var r = e.id,\n            i = e.level,\n            a = e.url,\n            n = e.deliveryDirectives;\n        this.load({\n          id: r,\n          groupId: null,\n          level: i,\n          responseType: \"text\",\n          type: _.a.LEVEL,\n          url: a,\n          deliveryDirectives: n\n        });\n      }, e.onAudioTrackLoading = function (t, e) {\n        var r = e.id,\n            i = e.groupId,\n            a = e.url,\n            n = e.deliveryDirectives;\n        this.load({\n          id: r,\n          groupId: i,\n          level: null,\n          responseType: \"text\",\n          type: _.a.AUDIO_TRACK,\n          url: a,\n          deliveryDirectives: n\n        });\n      }, e.onSubtitleTrackLoading = function (t, e) {\n        var r = e.id,\n            i = e.groupId,\n            a = e.url,\n            n = e.deliveryDirectives;\n        this.load({\n          id: r,\n          groupId: i,\n          level: null,\n          responseType: \"text\",\n          type: _.a.SUBTITLE_TRACK,\n          url: a,\n          deliveryDirectives: n\n        });\n      }, e.load = function (t) {\n        var e,\n            r,\n            i,\n            a,\n            n,\n            s,\n            l = this.hls.config,\n            u = this.getInternalLoader(t);\n\n        if (u) {\n          var d = u.context;\n          if (d && d.url === t.url) return void o.b.trace(\"[playlist-loader]: playlist request ongoing\");\n          o.b.log(\"[playlist-loader]: aborting previous loader for type: \" + t.type), u.abort();\n        }\n\n        switch (t.type) {\n          case _.a.MANIFEST:\n            r = l.manifestLoadingMaxRetry, i = l.manifestLoadingTimeOut, a = l.manifestLoadingRetryDelay, n = l.manifestLoadingMaxRetryTimeout;\n            break;\n\n          case _.a.LEVEL:\n          case _.a.AUDIO_TRACK:\n          case _.a.SUBTITLE_TRACK:\n            r = 0, i = l.levelLoadingTimeOut;\n            break;\n\n          default:\n            r = l.levelLoadingMaxRetry, i = l.levelLoadingTimeOut, a = l.levelLoadingRetryDelay, n = l.levelLoadingMaxRetryTimeout;\n        }\n\n        if ((u = this.createInternalLoader(t), null !== (e = t.deliveryDirectives) && void 0 !== e && e.part) && (t.type === _.a.LEVEL && null !== t.level ? s = this.hls.levels[t.level].details : t.type === _.a.AUDIO_TRACK && null !== t.id ? s = this.hls.audioTracks[t.id].details : t.type === _.a.SUBTITLE_TRACK && null !== t.id && (s = this.hls.subtitleTracks[t.id].details), s)) {\n          var h = s.partTarget,\n              f = s.targetduration;\n          h && f && (i = Math.min(1e3 * Math.max(3 * h, .8 * f), i));\n        }\n\n        var c = {\n          timeout: i,\n          maxRetry: r,\n          retryDelay: a,\n          maxRetryDelay: n,\n          highWaterMark: 0\n        },\n            v = {\n          onSuccess: this.loadsuccess.bind(this),\n          onError: this.loaderror.bind(this),\n          onTimeout: this.loadtimeout.bind(this)\n        };\n        u.load(t, c, v);\n      }, e.loadsuccess = function (t, e, r, i) {\n        if (void 0 === i && (i = null), r.isSidxRequest) return this.handleSidxRequest(t, r), void this.handlePlaylistLoaded(t, e, r, i);\n        this.resetInternalLoader(r.type);\n        var a = t.data;\n        0 === a.indexOf(\"#EXTM3U\") ? (e.parsing.start = performance.now(), a.indexOf(\"#EXTINF:\") > 0 || a.indexOf(\"#EXT-X-TARGETDURATION:\") > 0 ? this.handleTrackOrLevelPlaylist(t, e, r, i) : this.handleMasterPlaylist(t, e, r, i)) : this.handleManifestParsingError(t, r, \"no EXTM3U delimiter\", i);\n      }, e.loaderror = function (t, e, r) {\n        void 0 === r && (r = null), this.handleNetworkError(e, r, !1, t);\n      }, e.loadtimeout = function (t, e, r) {\n        void 0 === r && (r = null), this.handleNetworkError(e, r, !0);\n      }, e.handleMasterPlaylist = function (t, e, r, i) {\n        var a = this.hls,\n            s = t.data,\n            l = k(t, r),\n            u = L.parseMasterPlaylist(s, l),\n            d = u.levels,\n            h = u.sessionData;\n\n        if (d.length) {\n          var f = d.map(function (t) {\n            return {\n              id: t.attrs.AUDIO,\n              audioCodec: t.audioCodec\n            };\n          }),\n              c = d.map(function (t) {\n            return {\n              id: t.attrs.SUBTITLES,\n              textCodec: t.textCodec\n            };\n          }),\n              v = L.parseMasterPlaylistMedia(s, l, \"AUDIO\", f),\n              p = L.parseMasterPlaylistMedia(s, l, \"SUBTITLES\", c),\n              m = L.parseMasterPlaylistMedia(s, l, \"CLOSED-CAPTIONS\");\n          if (v.length) v.some(function (t) {\n            return !t.url;\n          }) || !d[0].audioCodec || d[0].attrs.AUDIO || (o.b.log(\"[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one\"), v.unshift({\n            type: \"main\",\n            name: \"main\",\n            default: !1,\n            autoselect: !1,\n            forced: !1,\n            id: -1,\n            attrs: new g({}),\n            bitrate: 0,\n            url: \"\"\n          }));\n          a.trigger(n.a.MANIFEST_LOADED, {\n            levels: d,\n            audioTracks: v,\n            subtitles: p,\n            captions: m,\n            url: l,\n            stats: e,\n            networkDetails: i,\n            sessionData: h\n          });\n        } else this.handleManifestParsingError(t, r, \"no level found in manifest\", i);\n      }, e.handleTrackOrLevelPlaylist = function (t, e, r, i) {\n        var o = this.hls,\n            l = r.id,\n            u = r.level,\n            d = r.type,\n            h = k(t, r),\n            f = Object(a.a)(l) ? l : 0,\n            c = Object(a.a)(u) ? u : f,\n            v = function (t) {\n          switch (t.type) {\n            case _.a.AUDIO_TRACK:\n              return _.b.AUDIO;\n\n            case _.a.SUBTITLE_TRACK:\n              return _.b.SUBTITLE;\n\n            default:\n              return _.b.MAIN;\n          }\n        }(r),\n            p = L.parseLevelPlaylist(t.data, h, c, v, f);\n\n        if (p.fragments.length) {\n          if (d === _.a.MANIFEST) {\n            var m = {\n              attrs: new g({}),\n              bitrate: 0,\n              details: p,\n              name: \"\",\n              url: h\n            };\n            o.trigger(n.a.MANIFEST_LOADED, {\n              levels: [m],\n              audioTracks: [],\n              url: h,\n              stats: e,\n              networkDetails: i,\n              sessionData: null\n            });\n          }\n\n          if (e.parsing.end = performance.now(), p.needSidxRanges) {\n            var y,\n                b = null === (y = p.fragments[0].initSegment) || void 0 === y ? void 0 : y.url;\n            this.load({\n              url: b,\n              isSidxRequest: !0,\n              type: d,\n              level: u,\n              levelDetails: p,\n              id: l,\n              groupId: null,\n              rangeStart: 0,\n              rangeEnd: 2048,\n              responseType: \"arraybuffer\",\n              deliveryDirectives: null\n            });\n          } else r.levelDetails = p, this.handlePlaylistLoaded(t, e, r, i);\n        } else o.trigger(n.a.ERROR, {\n          type: s.b.NETWORK_ERROR,\n          details: s.a.LEVEL_EMPTY_ERROR,\n          fatal: !1,\n          url: h,\n          reason: \"no fragments found in level\",\n          level: \"number\" == typeof r.level ? r.level : void 0\n        });\n      }, e.handleSidxRequest = function (t, e) {\n        var r = Object(l.g)(new Uint8Array(t.data));\n\n        if (r) {\n          var i = r.references,\n              a = e.levelDetails;\n          i.forEach(function (t, e) {\n            var i = t.info,\n                n = a.fragments[e];\n            0 === n.byteRange.length && n.setByteRange(String(1 + i.end - i.start) + \"@\" + String(i.start)), n.initSegment && n.initSegment.setByteRange(String(r.moovEndOffset) + \"@0\");\n          });\n        }\n      }, e.handleManifestParsingError = function (t, e, r, i) {\n        this.hls.trigger(n.a.ERROR, {\n          type: s.b.NETWORK_ERROR,\n          details: s.a.MANIFEST_PARSING_ERROR,\n          fatal: e.type === _.a.MANIFEST,\n          url: t.url,\n          reason: r,\n          response: t,\n          context: e,\n          networkDetails: i\n        });\n      }, e.handleNetworkError = function (t, e, r, i) {\n        void 0 === r && (r = !1), o.b.warn(\"[playlist-loader]: A network \" + (r ? \"timeout\" : \"error\") + \" occurred while loading \" + t.type + \" level: \" + t.level + \" id: \" + t.id + ' group-id: \"' + t.groupId + '\"');\n        var a = s.a.UNKNOWN,\n            l = !1,\n            u = this.getInternalLoader(t);\n\n        switch (t.type) {\n          case _.a.MANIFEST:\n            a = r ? s.a.MANIFEST_LOAD_TIMEOUT : s.a.MANIFEST_LOAD_ERROR, l = !0;\n            break;\n\n          case _.a.LEVEL:\n            a = r ? s.a.LEVEL_LOAD_TIMEOUT : s.a.LEVEL_LOAD_ERROR, l = !1;\n            break;\n\n          case _.a.AUDIO_TRACK:\n            a = r ? s.a.AUDIO_TRACK_LOAD_TIMEOUT : s.a.AUDIO_TRACK_LOAD_ERROR, l = !1;\n            break;\n\n          case _.a.SUBTITLE_TRACK:\n            a = r ? s.a.SUBTITLE_TRACK_LOAD_TIMEOUT : s.a.SUBTITLE_LOAD_ERROR, l = !1;\n        }\n\n        u && this.resetInternalLoader(t.type);\n        var d = {\n          type: s.b.NETWORK_ERROR,\n          details: a,\n          fatal: l,\n          url: t.url,\n          loader: u,\n          context: t,\n          networkDetails: e\n        };\n        i && (d.response = i), this.hls.trigger(n.a.ERROR, d);\n      }, e.handlePlaylistLoaded = function (t, e, r, i) {\n        var a = r.type,\n            s = r.level,\n            o = r.id,\n            l = r.groupId,\n            u = r.loader,\n            d = r.levelDetails,\n            h = r.deliveryDirectives;\n\n        if (null != d && d.targetduration) {\n          if (u) switch (d.live && (u.getCacheAge && (d.ageHeader = u.getCacheAge() || 0), u.getCacheAge && !isNaN(d.ageHeader) || (d.ageHeader = 0)), a) {\n            case _.a.MANIFEST:\n            case _.a.LEVEL:\n              this.hls.trigger(n.a.LEVEL_LOADED, {\n                details: d,\n                level: s || 0,\n                id: o || 0,\n                stats: e,\n                networkDetails: i,\n                deliveryDirectives: h\n              });\n              break;\n\n            case _.a.AUDIO_TRACK:\n              this.hls.trigger(n.a.AUDIO_TRACK_LOADED, {\n                details: d,\n                id: o || 0,\n                groupId: l || \"\",\n                stats: e,\n                networkDetails: i,\n                deliveryDirectives: h\n              });\n              break;\n\n            case _.a.SUBTITLE_TRACK:\n              this.hls.trigger(n.a.SUBTITLE_TRACK_LOADED, {\n                details: d,\n                id: o || 0,\n                groupId: l || \"\",\n                stats: e,\n                networkDetails: i,\n                deliveryDirectives: h\n              });\n          }\n        } else this.handleManifestParsingError(t, r, \"invalid target duration\", i);\n      }, t;\n    }(),\n        C = function () {\n      function t(t) {\n        this.hls = void 0, this.loaders = {}, this.decryptkey = null, this.decrypturl = null, this.hls = t, this._registerListeners();\n      }\n\n      var e = t.prototype;\n      return e._registerListeners = function () {\n        this.hls.on(n.a.KEY_LOADING, this.onKeyLoading, this);\n      }, e._unregisterListeners = function () {\n        this.hls.off(n.a.KEY_LOADING, this.onKeyLoading);\n      }, e.destroy = function () {\n        for (var t in this._unregisterListeners(), this.loaders) {\n          var e = this.loaders[t];\n          e && e.destroy();\n        }\n\n        this.loaders = {};\n      }, e.onKeyLoading = function (t, e) {\n        var r = e.frag,\n            i = r.type,\n            a = this.loaders[i];\n\n        if (r.decryptdata) {\n          var s = r.decryptdata.uri;\n\n          if (s !== this.decrypturl || null === this.decryptkey) {\n            var l = this.hls.config;\n            if (a && (o.b.warn(\"abort previous key loader for type:\" + i), a.abort()), !s) return void o.b.warn(\"key uri is falsy\");\n            var u = l.loader,\n                d = r.loader = this.loaders[i] = new u(l);\n            this.decrypturl = s, this.decryptkey = null;\n            var h = {\n              url: s,\n              frag: r,\n              responseType: \"arraybuffer\"\n            },\n                f = {\n              timeout: l.fragLoadingTimeOut,\n              maxRetry: 0,\n              retryDelay: l.fragLoadingRetryDelay,\n              maxRetryDelay: l.fragLoadingMaxRetryTimeout,\n              highWaterMark: 0\n            },\n                c = {\n              onSuccess: this.loadsuccess.bind(this),\n              onError: this.loaderror.bind(this),\n              onTimeout: this.loadtimeout.bind(this)\n            };\n            d.load(h, f, c);\n          } else this.decryptkey && (r.decryptdata.key = this.decryptkey, this.hls.trigger(n.a.KEY_LOADED, {\n            frag: r\n          }));\n        } else o.b.warn(\"Missing decryption data on fragment in onKeyLoading\");\n      }, e.loadsuccess = function (t, e, r) {\n        var i = r.frag;\n        i.decryptdata ? (this.decryptkey = i.decryptdata.key = new Uint8Array(t.data), i.loader = null, delete this.loaders[i.type], this.hls.trigger(n.a.KEY_LOADED, {\n          frag: i\n        })) : o.b.error(\"after key load, decryptdata unset\");\n      }, e.loaderror = function (t, e) {\n        var r = e.frag,\n            i = r.loader;\n        i && i.abort(), delete this.loaders[r.type], this.hls.trigger(n.a.ERROR, {\n          type: s.b.NETWORK_ERROR,\n          details: s.a.KEY_LOAD_ERROR,\n          fatal: !1,\n          frag: r,\n          response: t\n        });\n      }, e.loadtimeout = function (t, e) {\n        var r = e.frag,\n            i = r.loader;\n        i && i.abort(), delete this.loaders[r.type], this.hls.trigger(n.a.ERROR, {\n          type: s.b.NETWORK_ERROR,\n          details: s.a.KEY_LOAD_TIMEOUT,\n          fatal: !1,\n          frag: r\n        });\n      }, t;\n    }();\n\n    function w(t, e) {\n      var r;\n\n      try {\n        r = new Event(\"addtrack\");\n      } catch (t) {\n        (r = document.createEvent(\"Event\")).initEvent(\"addtrack\", !1, !1);\n      }\n\n      r.track = t, e.dispatchEvent(r);\n    }\n\n    function O(t, e, r) {\n      var i = t.mode;\n      if (\"disabled\" === i && (t.mode = \"hidden\"), t.cues && t.cues.length > 0) for (var a = function (t, e, r) {\n        var i = [],\n            a = function (t, e) {\n          if (e < t[0].startTime) return 0;\n          var r = t.length - 1;\n          if (e > t[r].endTime) return -1;\n          var i = 0,\n              a = r;\n\n          for (; i <= a;) {\n            var n = Math.floor((a + i) / 2);\n            if (e < t[n].startTime) a = n - 1;else {\n              if (!(e > t[n].startTime && i < r)) return n;\n              i = n + 1;\n            }\n          }\n\n          return t[i].startTime - e < e - t[a].startTime ? i : a;\n        }(t, e);\n\n        if (a > -1) for (var n = a, s = t.length; n < s; n++) {\n          var o = t[n];\n          if (o.startTime >= e && o.endTime <= r) i.push(o);else if (o.startTime > r) return i;\n        }\n        return i;\n      }(t.cues, e, r), n = 0; n < a.length; n++) t.removeCue(a[n]);\n      \"disabled\" === i && (t.mode = i);\n    }\n\n    var I = r(7),\n        P = function () {\n      function t(t) {\n        this.hls = void 0, this.id3Track = null, this.media = null, this.hls = t, this._registerListeners();\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        this._unregisterListeners();\n      }, e._registerListeners = function () {\n        var t = this.hls;\n        t.on(n.a.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(n.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(n.a.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), t.on(n.a.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      }, e._unregisterListeners = function () {\n        var t = this.hls;\n        t.off(n.a.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(n.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(n.a.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), t.off(n.a.BUFFER_FLUSHING, this.onBufferFlushing, this);\n      }, e.onMediaAttached = function (t, e) {\n        this.media = e.media;\n      }, e.onMediaDetaching = function () {\n        this.id3Track && (!function (t) {\n          var e = t.mode;\n          if (\"disabled\" === e && (t.mode = \"hidden\"), t.cues) for (var r = t.cues.length; r--;) t.removeCue(t.cues[r]);\n          \"disabled\" === e && (t.mode = e);\n        }(this.id3Track), this.id3Track = null, this.media = null);\n      }, e.getID3Track = function (t) {\n        if (this.media) {\n          for (var e = 0; e < t.length; e++) {\n            var r = t[e];\n            if (\"metadata\" === r.kind && \"id3\" === r.label) return w(r, this.media), r;\n          }\n\n          return this.media.addTextTrack(\"metadata\", \"id3\");\n        }\n      }, e.onFragParsingMetadata = function (t, e) {\n        if (this.media) {\n          var r = e.frag,\n              i = e.samples;\n          this.id3Track || (this.id3Track = this.getID3Track(this.media.textTracks), this.id3Track.mode = \"hidden\");\n\n          for (var a = self.WebKitDataCue || self.VTTCue || self.TextTrackCue, n = 0; n < i.length; n++) {\n            var s = I.c(i[n].data);\n\n            if (s) {\n              var o = i[n].pts,\n                  l = n < i.length - 1 ? i[n + 1].pts : r.end;\n              l - o <= 0 && (l = o + .25);\n\n              for (var u = 0; u < s.length; u++) {\n                var d = s[u];\n\n                if (!I.e(d)) {\n                  var h = new a(o, l, \"\");\n                  h.value = d, this.id3Track.addCue(h);\n                }\n              }\n            }\n          }\n        }\n      }, e.onBufferFlushing = function (t, e) {\n        var r = e.startOffset,\n            i = e.endOffset,\n            a = e.type;\n\n        if (!a || \"audio\" === a) {\n          var n = this.id3Track;\n          n && O(n, r, i);\n        }\n      }, t;\n    }();\n\n    function F(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    var M,\n        N = function () {\n      function t(t) {\n        var e = this;\n        this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = function () {\n          return e.timeupdate();\n        }, this.hls = t, this.config = t.config, this.registerListeners();\n      }\n\n      var e,\n          r,\n          i,\n          a = t.prototype;\n      return a.destroy = function () {\n        this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null;\n      }, a.registerListeners = function () {\n        this.hls.on(n.a.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(n.a.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(n.a.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(n.a.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(n.a.ERROR, this.onError, this);\n      }, a.unregisterListeners = function () {\n        this.hls.off(n.a.MEDIA_ATTACHED, this.onMediaAttached), this.hls.off(n.a.MEDIA_DETACHING, this.onMediaDetaching), this.hls.off(n.a.MANIFEST_LOADING, this.onManifestLoading), this.hls.off(n.a.LEVEL_UPDATED, this.onLevelUpdated), this.hls.off(n.a.ERROR, this.onError);\n      }, a.onMediaAttached = function (t, e) {\n        this.media = e.media, this.media.addEventListener(\"timeupdate\", this.timeupdateHandler);\n      }, a.onMediaDetaching = function () {\n        this.media && (this.media.removeEventListener(\"timeupdate\", this.timeupdateHandler), this.media = null);\n      }, a.onManifestLoading = function () {\n        this.levelDetails = null, this._latency = null, this.stallCount = 0;\n      }, a.onLevelUpdated = function (t, e) {\n        var r = e.details;\n        this.levelDetails = r, r.advanced && this.timeupdate(), !r.live && this.media && this.media.removeEventListener(\"timeupdate\", this.timeupdateHandler);\n      }, a.onError = function (t, e) {\n        e.details === s.a.BUFFER_STALLED_ERROR && (this.stallCount++, o.b.warn(\"[playback-rate-controller]: Stall detected, adjusting target latency\"));\n      }, a.timeupdate = function () {\n        var t = this.media,\n            e = this.levelDetails;\n\n        if (t && e) {\n          this.currentTime = t.currentTime;\n          var r = this.computeLatency();\n\n          if (null !== r) {\n            this._latency = r;\n            var i = this.config,\n                a = i.lowLatencyMode,\n                n = i.maxLiveSyncPlaybackRate;\n\n            if (a && 1 !== n) {\n              var s = this.targetLatency;\n\n              if (null !== s) {\n                var o = r - s,\n                    l = o < Math.min(this.maxLatency, s + e.targetduration);\n\n                if (e.live && l && o > .05 && this.forwardBufferLength > 1) {\n                  var u = Math.min(2, Math.max(1, n)),\n                      d = Math.round(2 / (1 + Math.exp(-.75 * o - this.edgeStalled)) * 20) / 20;\n                  t.playbackRate = Math.min(u, Math.max(1, d));\n                } else 1 !== t.playbackRate && 0 !== t.playbackRate && (t.playbackRate = 1);\n              }\n            }\n          }\n        }\n      }, a.estimateLiveEdge = function () {\n        var t = this.levelDetails;\n        return null === t ? null : t.edge + t.age;\n      }, a.computeLatency = function () {\n        var t = this.estimateLiveEdge();\n        return null === t ? null : t - this.currentTime;\n      }, e = t, (r = [{\n        key: \"latency\",\n        get: function () {\n          return this._latency || 0;\n        }\n      }, {\n        key: \"maxLatency\",\n        get: function () {\n          var t = this.config,\n              e = this.levelDetails;\n          return void 0 !== t.liveMaxLatencyDuration ? t.liveMaxLatencyDuration : e ? t.liveMaxLatencyDurationCount * e.targetduration : 0;\n        }\n      }, {\n        key: \"targetLatency\",\n        get: function () {\n          var t = this.levelDetails;\n          if (null === t) return null;\n          var e = t.holdBack,\n              r = t.partHoldBack,\n              i = t.targetduration,\n              a = this.config,\n              n = a.liveSyncDuration,\n              s = a.liveSyncDurationCount,\n              o = a.lowLatencyMode,\n              l = this.hls.userConfig,\n              u = o && r || e;\n          (l.liveSyncDuration || l.liveSyncDurationCount || 0 === u) && (u = void 0 !== n ? n : s * i);\n          var d = i;\n          return u + Math.min(1 * this.stallCount, d);\n        }\n      }, {\n        key: \"liveSyncPosition\",\n        get: function () {\n          var t = this.estimateLiveEdge(),\n              e = this.targetLatency,\n              r = this.levelDetails;\n          if (null === t || null === e || null === r) return null;\n          var i = r.edge,\n              a = t - e - this.edgeStalled,\n              n = i - r.totalduration,\n              s = i - (this.config.lowLatencyMode && r.partTarget || r.targetduration);\n          return Math.min(Math.max(n, a), s);\n        }\n      }, {\n        key: \"drift\",\n        get: function () {\n          var t = this.levelDetails;\n          return null === t ? 1 : t.drift;\n        }\n      }, {\n        key: \"edgeStalled\",\n        get: function () {\n          var t = this.levelDetails;\n          if (null === t) return 0;\n          var e = 3 * (this.config.lowLatencyMode && t.partTarget || t.targetduration);\n          return Math.max(t.age - e, 0);\n        }\n      }, {\n        key: \"forwardBufferLength\",\n        get: function () {\n          var t = this.media,\n              e = this.levelDetails;\n          if (!t || !e) return 0;\n          var r = t.buffered.length;\n          return r ? t.buffered.end(r - 1) : e.edge - this.currentTime;\n        }\n      }]) && F(e.prototype, r), i && F(e, i), t;\n    }();\n\n    function B(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    !function (t) {\n      t.No = \"\", t.Yes = \"YES\", t.v2 = \"v2\";\n    }(M || (M = {}));\n\n    var U = function () {\n      function t(t, e, r) {\n        this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = t, this.part = e, this.skip = r;\n      }\n\n      return t.prototype.addDirectives = function (t) {\n        var e = new self.URL(t);\n        return void 0 !== this.msn && e.searchParams.set(\"_HLS_msn\", this.msn.toString()), void 0 !== this.part && e.searchParams.set(\"_HLS_part\", this.part.toString()), this.skip && e.searchParams.set(\"_HLS_skip\", this.skip), e.toString();\n      }, t;\n    }(),\n        G = function () {\n      function t(t) {\n        this.attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.unknownCodecs = void 0, this.audioGroupIds = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.textGroupIds = void 0, this.url = void 0, this._urlId = 0, this.url = [t.url], this.attrs = t.attrs, this.bitrate = t.bitrate, t.details && (this.details = t.details), this.id = t.id || 0, this.name = t.name, this.width = t.width || 0, this.height = t.height || 0, this.audioCodec = t.audioCodec, this.videoCodec = t.videoCodec, this.unknownCodecs = t.unknownCodecs, this.codecSet = [t.videoCodec, t.audioCodec].filter(function (t) {\n          return t;\n        }).join(\",\").replace(/\\.[^.,]+/g, \"\");\n      }\n\n      var e, r, i;\n      return e = t, (r = [{\n        key: \"maxBitrate\",\n        get: function () {\n          return Math.max(this.realBitrate, this.bitrate);\n        }\n      }, {\n        key: \"uri\",\n        get: function () {\n          return this.url[this._urlId] || \"\";\n        }\n      }, {\n        key: \"urlId\",\n        get: function () {\n          return this._urlId;\n        },\n        set: function (t) {\n          var e = t % this.url.length;\n          this._urlId !== e && (this.details = void 0, this._urlId = e);\n        }\n      }]) && B(e.prototype, r), i && B(e, i), t;\n    }();\n\n    function j(t, e, r) {\n      switch (e) {\n        case \"audio\":\n          t.audioGroupIds || (t.audioGroupIds = []), t.audioGroupIds.push(r);\n          break;\n\n        case \"text\":\n          t.textGroupIds || (t.textGroupIds = []), t.textGroupIds.push(r);\n      }\n    }\n\n    function H(t) {\n      var e = {};\n      t.forEach(function (t) {\n        var r = t.groupId || \"\";\n        t.id = e[r] = e[r] || 0, e[r]++;\n      });\n    }\n\n    function K(t, e) {\n      var r = e.startPTS;\n\n      if (Object(a.a)(r)) {\n        var i,\n            n = 0;\n        e.sn > t.sn ? (n = r - t.start, i = t) : (n = t.start - r, i = e), i.duration !== n && (i.duration = n);\n      } else if (e.sn > t.sn) {\n        t.cc === e.cc && t.minEndPTS ? e.start = t.start + (t.minEndPTS - t.start) : e.start = t.start + t.duration;\n      } else e.start = Math.max(t.start - e.duration, 0);\n    }\n\n    function V(t, e, r, i, n, s) {\n      i - r <= 0 && (o.b.warn(\"Fragment should have a positive duration\", e), i = r + e.duration, s = n + e.duration);\n      var l = r,\n          u = i,\n          d = e.startPTS,\n          h = e.endPTS;\n\n      if (Object(a.a)(d)) {\n        var f = Math.abs(d - r);\n        Object(a.a)(e.deltaPTS) ? e.deltaPTS = Math.max(f, e.deltaPTS) : e.deltaPTS = f, l = Math.max(r, d), r = Math.min(r, d), n = Math.min(n, e.startDTS), u = Math.min(i, h), i = Math.max(i, h), s = Math.max(s, e.endDTS);\n      }\n\n      e.duration = i - r;\n      var c = r - e.start;\n      e.appendedPTS = i, e.start = e.startPTS = r, e.maxStartPTS = l, e.startDTS = n, e.endPTS = i, e.minEndPTS = u, e.endDTS = s;\n      var v,\n          g = e.sn;\n      if (!t || g < t.startSN || g > t.endSN) return 0;\n      var p = g - t.startSN,\n          m = t.fragments;\n\n      for (m[p] = e, v = p; v > 0; v--) K(m[v], m[v - 1]);\n\n      for (v = p; v < m.length - 1; v++) K(m[v], m[v + 1]);\n\n      return t.fragmentHint && K(m[m.length - 1], t.fragmentHint), t.PTSKnown = t.alignedSliding = !0, c;\n    }\n\n    function W(t, e) {\n      for (var r = null, i = t.fragments, n = i.length - 1; n >= 0; n--) {\n        var s = i[n].initSegment;\n\n        if (s) {\n          r = s;\n          break;\n        }\n      }\n\n      t.fragmentHint && delete t.fragmentHint.endPTS;\n      var l,\n          u = 0;\n      ((function (t, e, r) {\n        for (var i = e.skippedSegments, a = Math.max(t.startSN, e.startSN) - e.startSN, n = (t.fragmentHint ? 1 : 0) + (i ? e.endSN : Math.min(t.endSN, e.endSN)) - e.startSN, s = e.startSN - t.startSN, o = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments, l = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments, u = a; u <= n; u++) {\n          var d = l[s + u],\n              h = o[u];\n          i && !h && u < i && (h = e.fragments[u] = d), d && h && r(d, h);\n        }\n      })(t, e, function (t, i) {\n        t.relurl && (u = t.cc - i.cc), Object(a.a)(t.startPTS) && Object(a.a)(t.endPTS) && (i.start = i.startPTS = t.startPTS, i.startDTS = t.startDTS, i.appendedPTS = t.appendedPTS, i.maxStartPTS = t.maxStartPTS, i.endPTS = t.endPTS, i.endDTS = t.endDTS, i.minEndPTS = t.minEndPTS, i.duration = t.endPTS - t.startPTS, i.duration && (l = i), e.PTSKnown = e.alignedSliding = !0), i.elementaryStreams = t.elementaryStreams, i.loader = t.loader, i.stats = t.stats, i.urlId = t.urlId, t.initSegment && (i.initSegment = t.initSegment, r = t.initSegment);\n      }), r) && (e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments).forEach(function (t) {\n        var e;\n        t.initSegment && t.initSegment.relurl !== (null === (e = r) || void 0 === e ? void 0 : e.relurl) || (t.initSegment = r);\n      });\n\n      if (e.skippedSegments && (e.deltaUpdateFailed = e.fragments.some(function (t) {\n        return !t;\n      }), e.deltaUpdateFailed)) {\n        o.b.warn(\"[level-helper] Previous playlist missing segments skipped in delta playlist\");\n\n        for (var d = e.skippedSegments; d--;) e.fragments.shift();\n\n        e.startSN = e.fragments[0].sn, e.startCC = e.fragments[0].cc;\n      }\n\n      var h = e.fragments;\n\n      if (u) {\n        o.b.warn(\"discontinuity sliding from playlist, take drift into account\");\n\n        for (var f = 0; f < h.length; f++) h[f].cc += u;\n      }\n\n      e.skippedSegments && (e.startCC = e.fragments[0].cc), function (t, e, r) {\n        if (t && e) for (var i = 0, a = 0, n = t.length; a <= n; a++) {\n          var s = t[a],\n              o = e[a + i];\n          s && o && s.index === o.index && s.fragment.sn === o.fragment.sn ? r(s, o) : i--;\n        }\n      }(t.partList, e.partList, function (t, e) {\n        e.elementaryStreams = t.elementaryStreams, e.stats = t.stats;\n      }), l ? V(e, l, l.startPTS, l.endPTS, l.startDTS, l.endDTS) : Y(t, e), h.length && (e.totalduration = e.edge - h[0].start), e.driftStartTime = t.driftStartTime, e.driftStart = t.driftStart;\n      var c = e.advancedDateTime;\n\n      if (e.advanced && c) {\n        var v = e.edge;\n        e.driftStart || (e.driftStartTime = c, e.driftStart = v), e.driftEndTime = c, e.driftEnd = v;\n      } else e.driftEndTime = t.driftEndTime, e.driftEnd = t.driftEnd, e.advancedDateTime = t.advancedDateTime;\n    }\n\n    function Y(t, e) {\n      var r = e.startSN + e.skippedSegments - t.startSN,\n          i = t.fragments;\n      r < 0 || r >= i.length || function (t, e) {\n        if (e) {\n          for (var r = t.fragments, i = t.skippedSegments; i < r.length; i++) r[i].start += e;\n\n          t.fragmentHint && (t.fragmentHint.start += e);\n        }\n      }(e, i[r].start);\n    }\n\n    var X = function () {\n      function t(t, e) {\n        this.hls = void 0, this.timer = -1, this.canLoad = !1, this.retryCount = 0, this.log = void 0, this.warn = void 0, this.log = o.b.log.bind(o.b, e + \":\"), this.warn = o.b.warn.bind(o.b, e + \":\"), this.hls = t;\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        this.clearTimer(), this.hls = this.log = this.warn = null;\n      }, e.onError = function (t, e) {\n        e.fatal && e.type === s.b.NETWORK_ERROR && this.clearTimer();\n      }, e.clearTimer = function () {\n        clearTimeout(this.timer), this.timer = -1;\n      }, e.startLoad = function () {\n        this.canLoad = !0, this.retryCount = 0, this.loadPlaylist();\n      }, e.stopLoad = function () {\n        this.canLoad = !1, this.clearTimer();\n      }, e.switchParams = function (t, e) {\n        var r = null == e ? void 0 : e.renditionReports;\n        if (r) for (var i = 0; i < r.length; i++) {\n          var n = r[i],\n              s = \"\" + n.URI;\n\n          if (s === t.substr(-s.length)) {\n            var o = parseInt(n[\"LAST-MSN\"]),\n                l = parseInt(n[\"LAST-PART\"]);\n\n            if (e && this.hls.config.lowLatencyMode) {\n              var u = Math.min(e.age - e.partTarget, e.targetduration);\n              void 0 !== l && u > e.partTarget && (l += 1);\n            }\n\n            if (Object(a.a)(o)) return new U(o, Object(a.a)(l) ? l : void 0, M.No);\n          }\n        }\n      }, e.loadPlaylist = function (t) {}, e.shouldLoadTrack = function (t) {\n        return this.canLoad && t && !!t.url && (!t.details || t.details.live);\n      }, e.playlistLoaded = function (t, e, r) {\n        var i = this,\n            a = e.details,\n            n = e.stats,\n            s = n.loading.end ? Math.max(0, self.performance.now() - n.loading.end) : 0;\n\n        if (a.advancedDateTime = Date.now() - s, a.live || null != r && r.live) {\n          if (a.reloaded(r), r && this.log(\"live playlist \" + t + \" \" + (a.advanced ? \"REFRESHED \" + a.lastPartSn + \"-\" + a.lastPartIndex : \"MISSED\")), r && a.fragments.length > 0 && W(r, a), !this.canLoad || !a.live) return;\n          var o,\n              l = void 0,\n              u = void 0;\n\n          if (a.canBlockReload && a.endSN && a.advanced) {\n            var d = this.hls.config.lowLatencyMode,\n                h = a.lastPartSn,\n                f = a.endSN,\n                c = a.lastPartIndex,\n                v = h === f;\n            -1 !== c ? (l = v ? f + 1 : h, u = v ? d ? 0 : c : c + 1) : l = f + 1;\n            var g = a.age,\n                p = g + a.ageHeader,\n                m = Math.min(p - a.partTarget, 1.5 * a.targetduration);\n\n            if (m > 0) {\n              if (r && m > r.tuneInGoal) this.warn(\"CDN Tune-in goal increased from: \" + r.tuneInGoal + \" to: \" + m + \" with playlist age: \" + a.age), m = 0;else {\n                var y = Math.floor(m / a.targetduration);\n                if (l += y, void 0 !== u) u += Math.round(m % a.targetduration / a.partTarget);\n                this.log(\"CDN Tune-in age: \" + a.ageHeader + \"s last advanced \" + g.toFixed(2) + \"s goal: \" + m + \" skip sn \" + y + \" to part \" + u);\n              }\n              a.tuneInGoal = m;\n            }\n\n            if (o = this.getDeliveryDirectives(a, e.deliveryDirectives, l, u), d || !v) return void this.loadPlaylist(o);\n          } else o = this.getDeliveryDirectives(a, e.deliveryDirectives, l, u);\n\n          var b = function (t, e) {\n            var r,\n                i = 1e3 * t.levelTargetDuration,\n                a = i / 2,\n                n = t.age,\n                s = n > 0 && n < 3 * i,\n                o = e.loading.end - e.loading.start,\n                l = t.availabilityDelay;\n            if (!1 === t.updated) {\n              if (s) {\n                var u = 333 * t.misses;\n                r = Math.max(Math.min(a, 2 * o), u), t.availabilityDelay = (t.availabilityDelay || 0) + r;\n              } else r = a;\n            } else s ? (l = Math.min(l || i / 2, n), t.availabilityDelay = l, r = l + i - n) : r = i - o;\n            return Math.round(r);\n          }(a, n);\n\n          void 0 !== l && a.canBlockReload && (b -= a.partTarget || 1), this.log(\"reload live playlist \" + t + \" in \" + Math.round(b) + \" ms\"), this.timer = self.setTimeout(function () {\n            return i.loadPlaylist(o);\n          }, b);\n        } else this.clearTimer();\n      }, e.getDeliveryDirectives = function (t, e, r, i) {\n        var a = function (t, e) {\n          var r = t.canSkipUntil,\n              i = t.canSkipDateRanges,\n              a = t.endSN;\n          return r && (void 0 !== e ? e - a : 0) < r ? i ? M.v2 : M.Yes : M.No;\n        }(t, r);\n\n        return null != e && e.skip && t.deltaUpdateFailed && (r = e.msn, i = e.part, a = M.No), new U(r, i, a);\n      }, e.retryLoadingOrFail = function (t) {\n        var e,\n            r = this,\n            i = this.hls.config,\n            a = this.retryCount < i.levelLoadingMaxRetry;\n        if (a) {\n          if (this.retryCount++, t.details.indexOf(\"LoadTimeOut\") > -1 && null !== (e = t.context) && void 0 !== e && e.deliveryDirectives) this.warn(\"retry playlist loading #\" + this.retryCount + ' after \"' + t.details + '\"'), this.loadPlaylist();else {\n            var n = Math.min(Math.pow(2, this.retryCount) * i.levelLoadingRetryDelay, i.levelLoadingMaxRetryTimeout);\n            this.timer = self.setTimeout(function () {\n              return r.loadPlaylist();\n            }, n), this.warn(\"retry playlist loading #\" + this.retryCount + \" in \" + n + ' ms after \"' + t.details + '\"');\n          }\n        } else this.warn('cannot recover from error \"' + t.details + '\"'), this.clearTimer(), t.fatal = !0;\n        return a;\n      }, t;\n    }();\n\n    function q() {\n      return (q = Object.assign || function (t) {\n        for (var e = 1; e < arguments.length; e++) {\n          var r = arguments[e];\n\n          for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);\n        }\n\n        return t;\n      }).apply(this, arguments);\n    }\n\n    function z(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    function Q(t, e) {\n      return (Q = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    var $,\n        Z = /chrome|firefox/.test(navigator.userAgent.toLowerCase()),\n        J = function (t) {\n      var e, r;\n\n      function i(e) {\n        var r;\n        return (r = t.call(this, e, \"[level-controller]\") || this)._levels = [], r._firstLevel = -1, r._startLevel = void 0, r.currentLevelIndex = -1, r.manualLevelIndex = -1, r.onParsedComplete = void 0, r._registerListeners(), r;\n      }\n\n      r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, Q(e, r);\n      var a,\n          o,\n          l,\n          u = i.prototype;\n      return u._registerListeners = function () {\n        var t = this.hls;\n        t.on(n.a.MANIFEST_LOADED, this.onManifestLoaded, this), t.on(n.a.LEVEL_LOADED, this.onLevelLoaded, this), t.on(n.a.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.on(n.a.FRAG_LOADED, this.onFragLoaded, this), t.on(n.a.ERROR, this.onError, this);\n      }, u._unregisterListeners = function () {\n        var t = this.hls;\n        t.off(n.a.MANIFEST_LOADED, this.onManifestLoaded, this), t.off(n.a.LEVEL_LOADED, this.onLevelLoaded, this), t.off(n.a.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.off(n.a.FRAG_LOADED, this.onFragLoaded, this), t.off(n.a.ERROR, this.onError, this);\n      }, u.destroy = function () {\n        this._unregisterListeners(), this.manualLevelIndex = -1, this._levels.length = 0, t.prototype.destroy.call(this);\n      }, u.startLoad = function () {\n        this._levels.forEach(function (t) {\n          t.loadError = 0;\n        }), t.prototype.startLoad.call(this);\n      }, u.onManifestLoaded = function (t, e) {\n        var r,\n            i,\n            a = [],\n            o = [],\n            l = [],\n            u = {},\n            d = !1,\n            h = !1,\n            f = !1;\n\n        if (e.levels.forEach(function (t) {\n          var e = t.attrs;\n          d = d || !(!t.width || !t.height), h = h || !!t.videoCodec, f = f || !!t.audioCodec, Z && t.audioCodec && -1 !== t.audioCodec.indexOf(\"mp4a.40.34\") && (t.audioCodec = void 0);\n          var r = t.bitrate + \"-\" + t.attrs.RESOLUTION + \"-\" + t.attrs.CODECS;\n          (i = u[r]) ? i.url.push(t.url) : (i = new G(t), u[r] = i, a.push(i)), e && (e.AUDIO && j(i, \"audio\", e.AUDIO), e.SUBTITLES && j(i, \"text\", e.SUBTITLES));\n        }), (d || h) && f && (a = a.filter(function (t) {\n          var e = t.videoCodec,\n              r = t.width,\n              i = t.height;\n          return !!e || !(!r || !i);\n        })), a = a.filter(function (t) {\n          var e = t.audioCodec,\n              r = t.videoCodec;\n          return (!e || m(e, \"audio\")) && (!r || m(r, \"video\"));\n        }), e.audioTracks && H(o = e.audioTracks.filter(function (t) {\n          return !t.audioCodec || m(t.audioCodec, \"audio\");\n        })), e.subtitles && H(l = e.subtitles), a.length > 0) {\n          r = a[0].bitrate, a.sort(function (t, e) {\n            return t.bitrate - e.bitrate;\n          }), this._levels = a;\n\n          for (var c = 0; c < a.length; c++) if (a[c].bitrate === r) {\n            this._firstLevel = c, this.log(\"manifest loaded, \" + a.length + \" level(s) found, first bitrate: \" + r);\n            break;\n          }\n\n          var v = f && !h,\n              g = {\n            levels: a,\n            audioTracks: o,\n            subtitleTracks: l,\n            firstLevel: this._firstLevel,\n            stats: e.stats,\n            audio: f,\n            video: h,\n            altAudio: !v && o.some(function (t) {\n              return !!t.url;\n            })\n          };\n          this.hls.trigger(n.a.MANIFEST_PARSED, g), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition);\n        } else this.hls.trigger(n.a.ERROR, {\n          type: s.b.MEDIA_ERROR,\n          details: s.a.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n          fatal: !0,\n          url: e.url,\n          reason: \"no level with compatible codecs found in manifest\"\n        });\n      }, u.onError = function (e, r) {\n        if (t.prototype.onError.call(this, e, r), !r.fatal) {\n          var i = r.context,\n              a = this._levels[this.currentLevelIndex];\n          if (i && (i.type === _.a.AUDIO_TRACK && a.audioGroupIds && i.groupId === a.audioGroupIds[a.urlId] || i.type === _.a.SUBTITLE_TRACK && a.textGroupIds && i.groupId === a.textGroupIds[a.urlId])) this.redundantFailover(this.currentLevelIndex);else {\n            var n,\n                o = !1,\n                l = !0;\n\n            switch (r.details) {\n              case s.a.FRAG_LOAD_ERROR:\n              case s.a.FRAG_LOAD_TIMEOUT:\n              case s.a.KEY_LOAD_ERROR:\n              case s.a.KEY_LOAD_TIMEOUT:\n                if (r.frag) {\n                  var u = this._levels[r.frag.level];\n                  u ? (u.fragmentError++, u.fragmentError > this.hls.config.fragLoadingMaxRetry && (n = r.frag.level)) : n = r.frag.level;\n                }\n\n                break;\n\n              case s.a.LEVEL_LOAD_ERROR:\n              case s.a.LEVEL_LOAD_TIMEOUT:\n                i && (i.deliveryDirectives && (l = !1), n = i.level), o = !0;\n                break;\n\n              case s.a.REMUX_ALLOC_ERROR:\n                n = r.level, o = !0;\n            }\n\n            void 0 !== n && this.recoverLevel(r, n, o, l);\n          }\n        }\n      }, u.recoverLevel = function (t, e, r, i) {\n        var a = t.details,\n            n = this._levels[e];\n\n        if (n.loadError++, r) {\n          if (!this.retryLoadingOrFail(t)) return void (this.currentLevelIndex = -1);\n          t.levelRetry = !0;\n        }\n\n        if (i) {\n          var s = n.url.length;\n          if (s > 1 && n.loadError < s) t.levelRetry = !0, this.redundantFailover(e);else if (-1 === this.manualLevelIndex) {\n            var o = 0 === e ? this._levels.length - 1 : e - 1;\n            this.currentLevelIndex !== o && 0 === this._levels[o].loadError && (this.warn(a + \": switch to \" + o), t.levelRetry = !0, this.hls.nextAutoLevel = o);\n          }\n        }\n      }, u.redundantFailover = function (t) {\n        var e = this._levels[t],\n            r = e.url.length;\n\n        if (r > 1) {\n          var i = (e.urlId + 1) % r;\n          this.warn(\"Switching to redundant URL-id \" + i), this._levels.forEach(function (t) {\n            t.urlId = i;\n          }), this.level = t;\n        }\n      }, u.onFragLoaded = function (t, e) {\n        var r = e.frag;\n\n        if (void 0 !== r && r.type === _.b.MAIN) {\n          var i = this._levels[r.level];\n          void 0 !== i && (i.fragmentError = 0, i.loadError = 0);\n        }\n      }, u.onLevelLoaded = function (t, e) {\n        var r,\n            i,\n            a = e.level,\n            n = e.details,\n            s = this._levels[a];\n        if (!s) return this.warn(\"Invalid level index \" + a), void (null !== (i = e.deliveryDirectives) && void 0 !== i && i.skip && (n.deltaUpdateFailed = !0));\n        a === this.currentLevelIndex ? (0 === s.fragmentError && (s.loadError = 0, this.retryCount = 0), this.playlistLoaded(a, e, s.details)) : null !== (r = e.deliveryDirectives) && void 0 !== r && r.skip && (n.deltaUpdateFailed = !0);\n      }, u.onAudioTrackSwitched = function (t, e) {\n        var r = this.hls.levels[this.currentLevelIndex];\n\n        if (r && r.audioGroupIds) {\n          for (var i = -1, a = this.hls.audioTracks[e.id].groupId, n = 0; n < r.audioGroupIds.length; n++) if (r.audioGroupIds[n] === a) {\n            i = n;\n            break;\n          }\n\n          i !== r.urlId && (r.urlId = i, this.startLoad());\n        }\n      }, u.loadPlaylist = function (t) {\n        var e = this.currentLevelIndex,\n            r = this._levels[e];\n\n        if (this.canLoad && r && r.url.length > 0) {\n          var i = r.urlId,\n              a = r.url[i];\n          if (t) try {\n            a = t.addDirectives(a);\n          } catch (t) {\n            this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + t);\n          }\n          this.log(\"Attempt loading level index \" + e + (t ? \" at sn \" + t.msn + \" part \" + t.part : \"\") + \" with URL-id \" + i + \" \" + a), this.clearTimer(), this.hls.trigger(n.a.LEVEL_LOADING, {\n            url: a,\n            level: e,\n            id: i,\n            deliveryDirectives: t || null\n          });\n        }\n      }, u.removeLevel = function (t, e) {\n        var r = function (t, r) {\n          return r !== e;\n        },\n            i = this._levels.filter(function (i, a) {\n          return a !== t || i.url.length > 1 && void 0 !== e && (i.url = i.url.filter(r), i.audioGroupIds && (i.audioGroupIds = i.audioGroupIds.filter(r)), i.textGroupIds && (i.textGroupIds = i.textGroupIds.filter(r)), i.urlId = 0, !0);\n        }).map(function (t, e) {\n          var r = t.details;\n          return null != r && r.fragments && r.fragments.forEach(function (t) {\n            t.level = e;\n          }), t;\n        });\n\n        this._levels = i, this.hls.trigger(n.a.LEVELS_UPDATED, {\n          levels: i\n        });\n      }, a = i, (o = [{\n        key: \"levels\",\n        get: function () {\n          return 0 === this._levels.length ? null : this._levels;\n        }\n      }, {\n        key: \"level\",\n        get: function () {\n          return this.currentLevelIndex;\n        },\n        set: function (t) {\n          var e,\n              r = this._levels;\n\n          if (0 !== r.length && (this.currentLevelIndex !== t || null === (e = r[t]) || void 0 === e || !e.details)) {\n            if (t < 0 || t >= r.length) {\n              var i = t < 0;\n              if (this.hls.trigger(n.a.ERROR, {\n                type: s.b.OTHER_ERROR,\n                details: s.a.LEVEL_SWITCH_ERROR,\n                level: t,\n                fatal: i,\n                reason: \"invalid level idx\"\n              }), i) return;\n              t = Math.min(t, r.length - 1);\n            }\n\n            this.clearTimer();\n            var a = this.currentLevelIndex,\n                o = r[a],\n                l = r[t];\n            this.log(\"switching to level \" + t + \" from \" + a), this.currentLevelIndex = t;\n            var u = q({}, l, {\n              level: t,\n              maxBitrate: l.maxBitrate,\n              uri: l.uri,\n              urlId: l.urlId\n            });\n            delete u._urlId, this.hls.trigger(n.a.LEVEL_SWITCHING, u);\n            var d = l.details;\n\n            if (!d || d.live) {\n              var h = this.switchParams(l.uri, null == o ? void 0 : o.details);\n              this.loadPlaylist(h);\n            }\n          }\n        }\n      }, {\n        key: \"manualLevel\",\n        get: function () {\n          return this.manualLevelIndex;\n        },\n        set: function (t) {\n          this.manualLevelIndex = t, void 0 === this._startLevel && (this._startLevel = t), -1 !== t && (this.level = t);\n        }\n      }, {\n        key: \"firstLevel\",\n        get: function () {\n          return this._firstLevel;\n        },\n        set: function (t) {\n          this._firstLevel = t;\n        }\n      }, {\n        key: \"startLevel\",\n        get: function () {\n          if (void 0 === this._startLevel) {\n            var t = this.hls.config.startLevel;\n            return void 0 !== t ? t : this._firstLevel;\n          }\n\n          return this._startLevel;\n        },\n        set: function (t) {\n          this._startLevel = t;\n        }\n      }, {\n        key: \"nextLoadLevel\",\n        get: function () {\n          return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel;\n        },\n        set: function (t) {\n          this.level = t, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = t);\n        }\n      }]) && z(a.prototype, o), l && z(a, l), i;\n    }(X);\n\n    !function (t) {\n      t.NOT_LOADED = \"NOT_LOADED\", t.BACKTRACKED = \"BACKTRACKED\", t.APPENDING = \"APPENDING\", t.PARTIAL = \"PARTIAL\", t.OK = \"OK\";\n    }($ || ($ = {}));\n\n    var tt = function () {\n      function t(t) {\n        this.activeFragment = null, this.activeParts = null, this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hls = t, this._registerListeners();\n      }\n\n      var e = t.prototype;\n      return e._registerListeners = function () {\n        var t = this.hls;\n        t.on(n.a.BUFFER_APPENDED, this.onBufferAppended, this), t.on(n.a.FRAG_BUFFERED, this.onFragBuffered, this), t.on(n.a.FRAG_LOADED, this.onFragLoaded, this);\n      }, e._unregisterListeners = function () {\n        var t = this.hls;\n        t.off(n.a.BUFFER_APPENDED, this.onBufferAppended, this), t.off(n.a.FRAG_BUFFERED, this.onFragBuffered, this), t.off(n.a.FRAG_LOADED, this.onFragLoaded, this);\n      }, e.destroy = function () {\n        this._unregisterListeners(), this.fragments = this.timeRanges = null;\n      }, e.getAppendedFrag = function (t, e) {\n        if (e === _.b.MAIN) {\n          var r = this.activeFragment,\n              i = this.activeParts;\n          if (!r) return null;\n          if (i) for (var a = i.length; a--;) {\n            var n = i[a],\n                s = n ? n.end : r.appendedPTS;\n            if (n.start <= t && void 0 !== s && t <= s) return a > 9 && (this.activeParts = i.slice(a - 9)), n;\n          } else if (r.start <= t && void 0 !== r.appendedPTS && t <= r.appendedPTS) return r;\n        }\n\n        return this.getBufferedFrag(t, e);\n      }, e.getBufferedFrag = function (t, e) {\n        for (var r = this.fragments, i = Object.keys(r), a = i.length; a--;) {\n          var n = r[i[a]];\n\n          if ((null == n ? void 0 : n.body.type) === e && n.buffered) {\n            var s = n.body;\n            if (s.start <= t && t <= s.end) return s;\n          }\n        }\n\n        return null;\n      }, e.detectEvictedFragments = function (t, e, r) {\n        var i = this;\n        Object.keys(this.fragments).forEach(function (a) {\n          var n = i.fragments[a];\n          if (n) if (n.buffered) {\n            var s = n.range[t];\n            s && s.time.some(function (t) {\n              var r = !i.isTimeBuffered(t.startPTS, t.endPTS, e);\n              return r && i.removeFragment(n.body), r;\n            });\n          } else n.body.type === r && i.removeFragment(n.body);\n        });\n      }, e.detectPartialFragments = function (t) {\n        var e = this,\n            r = this.timeRanges,\n            i = t.frag,\n            a = t.part;\n\n        if (r && \"initSegment\" !== i.sn) {\n          var n = rt(i),\n              s = this.fragments[n];\n          s && (Object.keys(r).forEach(function (t) {\n            var n = i.elementaryStreams[t];\n\n            if (n) {\n              var o = r[t],\n                  l = null !== a || !0 === n.partial;\n              s.range[t] = e.getBufferedTimes(i, a, l, o);\n            }\n          }), s.backtrack = s.loaded = null, Object.keys(s.range).length ? s.buffered = !0 : this.removeFragment(s.body));\n        }\n      }, e.fragBuffered = function (t) {\n        var e = rt(t),\n            r = this.fragments[e];\n        r && (r.backtrack = r.loaded = null, r.buffered = !0);\n      }, e.getBufferedTimes = function (t, e, r, i) {\n        for (var a = {\n          time: [],\n          partial: r\n        }, n = e ? e.start : t.start, s = e ? e.end : t.end, o = t.minEndPTS || s, l = t.maxStartPTS || n, u = 0; u < i.length; u++) {\n          var d = i.start(u) - this.bufferPadding,\n              h = i.end(u) + this.bufferPadding;\n\n          if (l >= d && o <= h) {\n            a.time.push({\n              startPTS: Math.max(n, i.start(u)),\n              endPTS: Math.min(s, i.end(u))\n            });\n            break;\n          }\n\n          if (n < h && s > d) a.partial = !0, a.time.push({\n            startPTS: Math.max(n, i.start(u)),\n            endPTS: Math.min(s, i.end(u))\n          });else if (s <= d) break;\n        }\n\n        return a;\n      }, e.getPartialFragment = function (t) {\n        var e,\n            r,\n            i,\n            a = null,\n            n = 0,\n            s = this.bufferPadding,\n            o = this.fragments;\n        return Object.keys(o).forEach(function (l) {\n          var u = o[l];\n          u && et(u) && (r = u.body.start - s, i = u.body.end + s, t >= r && t <= i && (e = Math.min(t - r, i - t), n <= e && (a = u.body, n = e)));\n        }), a;\n      }, e.getState = function (t) {\n        var e = rt(t),\n            r = this.fragments[e];\n        return r ? r.buffered ? et(r) ? $.PARTIAL : $.OK : r.backtrack ? $.BACKTRACKED : $.APPENDING : $.NOT_LOADED;\n      }, e.backtrack = function (t, e) {\n        var r = rt(t),\n            i = this.fragments[r];\n        if (!i || i.backtrack) return null;\n        var a = i.backtrack = e || i.loaded;\n        return i.loaded = null, a;\n      }, e.getBacktrackData = function (t) {\n        var e = rt(t),\n            r = this.fragments[e];\n\n        if (r) {\n          var i,\n              a = r.backtrack;\n          if (null != a && null !== (i = a.payload) && void 0 !== i && i.byteLength) return a;\n          this.removeFragment(t);\n        }\n\n        return null;\n      }, e.isTimeBuffered = function (t, e, r) {\n        for (var i, a, n = 0; n < r.length; n++) {\n          if (i = r.start(n) - this.bufferPadding, a = r.end(n) + this.bufferPadding, t >= i && e <= a) return !0;\n          if (e <= i) return !1;\n        }\n\n        return !1;\n      }, e.onFragLoaded = function (t, e) {\n        var r = e.frag,\n            i = e.part;\n\n        if (\"initSegment\" !== r.sn && !r.bitrateTest && !i) {\n          var a = rt(r);\n          this.fragments[a] = {\n            body: r,\n            loaded: e,\n            backtrack: null,\n            buffered: !1,\n            range: Object.create(null)\n          };\n        }\n      }, e.onBufferAppended = function (t, e) {\n        var r = this,\n            i = e.frag,\n            a = e.part,\n            n = e.timeRanges;\n        if (i.type === _.b.MAIN) if (this.activeFragment = i, a) {\n          var s = this.activeParts;\n          s || (this.activeParts = s = []), s.push(a);\n        } else this.activeParts = null;\n        this.timeRanges = n, Object.keys(n).forEach(function (t) {\n          var e = n[t];\n          if (r.detectEvictedFragments(t, e), !a) for (var s = 0; s < e.length; s++) i.appendedPTS = Math.max(e.end(s), i.appendedPTS || 0);\n        });\n      }, e.onFragBuffered = function (t, e) {\n        this.detectPartialFragments(e);\n      }, e.hasFragment = function (t) {\n        var e = rt(t);\n        return !!this.fragments[e];\n      }, e.removeFragmentsInRange = function (t, e, r) {\n        var i = this;\n        Object.keys(this.fragments).forEach(function (a) {\n          var n = i.fragments[a];\n\n          if (n && n.buffered) {\n            var s = n.body;\n            s.type === r && s.start < e && s.end > t && i.removeFragment(s);\n          }\n        });\n      }, e.removeFragment = function (t) {\n        var e = rt(t);\n        t.stats.loaded = 0, t.clearElementaryStreamInfo(), delete this.fragments[e];\n      }, e.removeAllFragments = function () {\n        this.fragments = Object.create(null), this.activeFragment = null, this.activeParts = null;\n      }, t;\n    }();\n\n    function et(t) {\n      var e, r;\n      return t.buffered && ((null === (e = t.range.video) || void 0 === e ? void 0 : e.partial) || (null === (r = t.range.audio) || void 0 === r ? void 0 : r.partial));\n    }\n\n    function rt(t) {\n      return t.type + \"_\" + t.level + \"_\" + t.urlId + \"_\" + t.sn;\n    }\n\n    var it = function () {\n      function t() {\n        this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this);\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        this.onHandlerDestroying(), this.onHandlerDestroyed();\n      }, e.onHandlerDestroying = function () {\n        this.clearNextTick(), this.clearInterval();\n      }, e.onHandlerDestroyed = function () {}, e.hasInterval = function () {\n        return !!this._tickInterval;\n      }, e.hasNextTick = function () {\n        return !!this._tickTimer;\n      }, e.setInterval = function (t) {\n        return !this._tickInterval && (this._tickInterval = self.setInterval(this._boundTick, t), !0);\n      }, e.clearInterval = function () {\n        return !!this._tickInterval && (self.clearInterval(this._tickInterval), this._tickInterval = null, !0);\n      }, e.clearNextTick = function () {\n        return !!this._tickTimer && (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0);\n      }, e.tick = function () {\n        this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0);\n      }, e.tickImmediate = function () {\n        this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0);\n      }, e.doTick = function () {}, t;\n    }(),\n        at = {\n      length: 0,\n      start: function () {\n        return 0;\n      },\n      end: function () {\n        return 0;\n      }\n    },\n        nt = function () {\n      function t() {}\n\n      return t.isBuffered = function (e, r) {\n        try {\n          if (e) for (var i = t.getBuffered(e), a = 0; a < i.length; a++) if (r >= i.start(a) && r <= i.end(a)) return !0;\n        } catch (t) {}\n\n        return !1;\n      }, t.bufferInfo = function (e, r, i) {\n        try {\n          if (e) {\n            var a,\n                n = t.getBuffered(e),\n                s = [];\n\n            for (a = 0; a < n.length; a++) s.push({\n              start: n.start(a),\n              end: n.end(a)\n            });\n\n            return this.bufferedInfo(s, r, i);\n          }\n        } catch (t) {}\n\n        return {\n          len: 0,\n          start: r,\n          end: r,\n          nextStart: void 0\n        };\n      }, t.bufferedInfo = function (t, e, r) {\n        e = Math.max(0, e), t.sort(function (t, e) {\n          var r = t.start - e.start;\n          return r || e.end - t.end;\n        });\n        var i = [];\n        if (r) for (var a = 0; a < t.length; a++) {\n          var n = i.length;\n\n          if (n) {\n            var s = i[n - 1].end;\n            t[a].start - s < r ? t[a].end > s && (i[n - 1].end = t[a].end) : i.push(t[a]);\n          } else i.push(t[a]);\n        } else i = t;\n\n        for (var o, l = 0, u = e, d = e, h = 0; h < i.length; h++) {\n          var f = i[h].start,\n              c = i[h].end;\n          if (e + r >= f && e < c) u = f, l = (d = c) - e;else if (e + r < f) {\n            o = f;\n            break;\n          }\n        }\n\n        return {\n          len: l,\n          start: u || 0,\n          end: d || 0,\n          nextStart: o\n        };\n      }, t.getBuffered = function (t) {\n        try {\n          return t.buffered;\n        } catch (t) {\n          return o.b.log(\"failed to get media.buffered\", t), at;\n        }\n      }, t;\n    }(),\n        st = function (t, e, r, i, a, n) {\n      void 0 === i && (i = 0), void 0 === a && (a = -1), void 0 === n && (n = !1), this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = {\n        start: 0,\n        executeStart: 0,\n        executeEnd: 0,\n        end: 0\n      }, this.buffering = {\n        audio: {\n          start: 0,\n          executeStart: 0,\n          executeEnd: 0,\n          end: 0\n        },\n        video: {\n          start: 0,\n          executeStart: 0,\n          executeEnd: 0,\n          end: 0\n        },\n        audiovideo: {\n          start: 0,\n          executeStart: 0,\n          executeEnd: 0,\n          end: 0\n        }\n      }, this.level = t, this.sn = e, this.id = r, this.size = i, this.part = a, this.partial = n;\n    };\n\n    function ot(t, e) {\n      if (t) {\n        var r = t.start + e;\n        t.start = t.startPTS = r, t.endPTS = r + t.duration;\n      }\n    }\n\n    function lt(t, e) {\n      for (var r = e.fragments, i = 0, a = r.length; i < a; i++) ot(r[i], t);\n\n      e.fragmentHint && ot(e.fragmentHint, t), e.alignedSliding = !0;\n    }\n\n    function ut(t, e, r) {\n      e && (!function (t, e, r) {\n        if (function (t, e, r) {\n          return !(!e.details || !(r.endCC > r.startCC || t && t.cc < r.startCC));\n        }(t, r, e)) {\n          var i = function (t, e) {\n            var r = t.fragments,\n                i = e.fragments;\n\n            if (i.length && r.length) {\n              var a = function (t, e) {\n                for (var r = null, i = 0, a = t.length; i < a; i++) {\n                  var n = t[i];\n\n                  if (n && n.cc === e) {\n                    r = n;\n                    break;\n                  }\n                }\n\n                return r;\n              }(r, i[0].cc);\n\n              if (a && (!a || a.startPTS)) return a;\n              o.b.log(\"No frag in previous level to align on\");\n            } else o.b.log(\"No fragments to align\");\n          }(r.details, e);\n\n          i && Object(a.a)(i.start) && (o.b.log(\"Adjusting PTS using last level due to CC increase within current level \" + e.url), lt(i.start, e));\n        }\n      }(t, r, e), !r.alignedSliding && e.details && function (t, e) {\n        if (!e.fragments.length || !t.hasProgramDateTime || !e.hasProgramDateTime) return;\n        var r = e.fragments[0].programDateTime,\n            i = t.fragments[0].programDateTime,\n            n = (i - r) / 1e3 + e.fragments[0].start;\n        n && Object(a.a)(n) && (o.b.log(\"Adjusting PTS using programDateTime delta \" + (i - r) + \"ms, sliding:\" + n.toFixed(3) + \" \" + t.url + \" \"), lt(n, t));\n      }(r, e.details), r.alignedSliding || !e.details || r.skippedSegments || Y(e.details, r));\n    }\n\n    var dt = {\n      search: function (t, e) {\n        for (var r = 0, i = t.length - 1, a = null, n = null; r <= i;) {\n          var s = e(n = t[a = (r + i) / 2 | 0]);\n          if (s > 0) r = a + 1;else {\n            if (!(s < 0)) return n;\n            i = a - 1;\n          }\n        }\n\n        return null;\n      }\n    };\n\n    function ht(t, e, r) {\n      void 0 === t && (t = 0), void 0 === e && (e = 0);\n      var i = Math.min(e, r.duration + (r.deltaPTS ? r.deltaPTS : 0));\n      return r.start + r.duration - i <= t ? 1 : r.start - i > t && r.start ? -1 : 0;\n    }\n\n    function ft(t, e, r) {\n      var i = 1e3 * Math.min(e, r.duration + (r.deltaPTS ? r.deltaPTS : 0));\n      return (r.endProgramDateTime || 0) - i > t;\n    }\n\n    function ct(t) {\n      var e = \"function\" == typeof Map ? new Map() : void 0;\n      return (ct = function (t) {\n        if (null === t || (r = t, -1 === Function.toString.call(r).indexOf(\"[native code]\"))) return t;\n        var r;\n        if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n\n        if (void 0 !== e) {\n          if (e.has(t)) return e.get(t);\n          e.set(t, i);\n        }\n\n        function i() {\n          return vt(t, arguments, mt(this).constructor);\n        }\n\n        return i.prototype = Object.create(t.prototype, {\n          constructor: {\n            value: i,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), pt(i, t);\n      })(t);\n    }\n\n    function vt(t, e, r) {\n      return (vt = gt() ? Reflect.construct : function (t, e, r) {\n        var i = [null];\n        i.push.apply(i, e);\n        var a = new (Function.bind.apply(t, i))();\n        return r && pt(a, r.prototype), a;\n      }).apply(null, arguments);\n    }\n\n    function gt() {\n      if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n      if (Reflect.construct.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }\n\n    function pt(t, e) {\n      return (pt = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    function mt(t) {\n      return (mt = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n        return t.__proto__ || Object.getPrototypeOf(t);\n      })(t);\n    }\n\n    var yt = Math.pow(2, 17),\n        bt = function () {\n      function t(t) {\n        this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = t;\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        this.loader && (this.loader.destroy(), this.loader = null);\n      }, e.abort = function () {\n        this.loader && this.loader.abort();\n      }, e.load = function (t, e) {\n        var r = this,\n            i = t.url;\n        if (!i) return Promise.reject(new Et({\n          type: s.b.NETWORK_ERROR,\n          details: s.a.FRAG_LOAD_ERROR,\n          fatal: !1,\n          frag: t,\n          networkDetails: null\n        }, \"Fragment does not have a \" + (i ? \"part list\" : \"url\")));\n        this.abort();\n        var a = this.config,\n            n = a.fLoader,\n            o = a.loader;\n        return new Promise(function (i, l) {\n          r.loader && r.loader.destroy();\n          var u = r.loader = t.loader = n ? new n(a) : new o(a),\n              d = Tt(t),\n              h = {\n            timeout: a.fragLoadingTimeOut,\n            maxRetry: 0,\n            retryDelay: 0,\n            maxRetryDelay: a.fragLoadingMaxRetryTimeout,\n            highWaterMark: yt\n          };\n          t.stats = u.stats, u.load(d, h, {\n            onSuccess: function (e, a, n, s) {\n              r.resetLoader(t, u), i({\n                frag: t,\n                part: null,\n                payload: e.data,\n                networkDetails: s\n              });\n            },\n            onError: function (e, i, a) {\n              r.resetLoader(t, u), l(new Et({\n                type: s.b.NETWORK_ERROR,\n                details: s.a.FRAG_LOAD_ERROR,\n                fatal: !1,\n                frag: t,\n                response: e,\n                networkDetails: a\n              }));\n            },\n            onAbort: function (e, i, a) {\n              r.resetLoader(t, u), l(new Et({\n                type: s.b.NETWORK_ERROR,\n                details: s.a.INTERNAL_ABORTED,\n                fatal: !1,\n                frag: t,\n                networkDetails: a\n              }));\n            },\n            onTimeout: function (e, i, a) {\n              r.resetLoader(t, u), l(new Et({\n                type: s.b.NETWORK_ERROR,\n                details: s.a.FRAG_LOAD_TIMEOUT,\n                fatal: !1,\n                frag: t,\n                networkDetails: a\n              }));\n            },\n            onProgress: function (r, i, a, n) {\n              e && e({\n                frag: t,\n                part: null,\n                payload: a,\n                networkDetails: n\n              });\n            }\n          });\n        });\n      }, e.loadPart = function (t, e, r) {\n        var i = this;\n        this.abort();\n        var a = this.config,\n            n = a.fLoader,\n            o = a.loader;\n        return new Promise(function (l, u) {\n          i.loader && i.loader.destroy();\n          var d = i.loader = t.loader = n ? new n(a) : new o(a),\n              h = Tt(t, e),\n              f = {\n            timeout: a.fragLoadingTimeOut,\n            maxRetry: 0,\n            retryDelay: 0,\n            maxRetryDelay: a.fragLoadingMaxRetryTimeout,\n            highWaterMark: yt\n          };\n          e.stats = d.stats, d.load(h, f, {\n            onSuccess: function (a, n, s, o) {\n              i.resetLoader(t, d), i.updateStatsFromPart(t, e);\n              var u = {\n                frag: t,\n                part: e,\n                payload: a.data,\n                networkDetails: o\n              };\n              r(u), l(u);\n            },\n            onError: function (r, a, n) {\n              i.resetLoader(t, d), u(new Et({\n                type: s.b.NETWORK_ERROR,\n                details: s.a.FRAG_LOAD_ERROR,\n                fatal: !1,\n                frag: t,\n                part: e,\n                response: r,\n                networkDetails: n\n              }));\n            },\n            onAbort: function (r, a, n) {\n              t.stats.aborted = e.stats.aborted, i.resetLoader(t, d), u(new Et({\n                type: s.b.NETWORK_ERROR,\n                details: s.a.INTERNAL_ABORTED,\n                fatal: !1,\n                frag: t,\n                part: e,\n                networkDetails: n\n              }));\n            },\n            onTimeout: function (r, a, n) {\n              i.resetLoader(t, d), u(new Et({\n                type: s.b.NETWORK_ERROR,\n                details: s.a.FRAG_LOAD_TIMEOUT,\n                fatal: !1,\n                frag: t,\n                part: e,\n                networkDetails: n\n              }));\n            }\n          });\n        });\n      }, e.updateStatsFromPart = function (t, e) {\n        var r = t.stats,\n            i = e.stats,\n            a = i.total;\n\n        if (r.loaded += i.loaded, a) {\n          var n = Math.round(t.duration / e.duration),\n              s = Math.min(Math.round(r.loaded / a), n),\n              o = (n - s) * Math.round(r.loaded / s);\n          r.total = r.loaded + o;\n        } else r.total = Math.max(r.loaded, r.total);\n\n        var l = r.loading,\n            u = i.loading;\n        l.start ? l.first += u.first - u.start : (l.start = u.start, l.first = u.first), l.end = u.end;\n      }, e.resetLoader = function (t, e) {\n        t.loader = null, this.loader === e && (self.clearTimeout(this.partLoadTimeout), this.loader = null), e.destroy();\n      }, t;\n    }();\n\n    function Tt(t, e) {\n      void 0 === e && (e = null);\n      var r = e || t,\n          i = {\n        frag: t,\n        part: e,\n        responseType: \"arraybuffer\",\n        url: r.url,\n        headers: {},\n        rangeStart: 0,\n        rangeEnd: 0\n      },\n          n = r.byteRangeStartOffset,\n          s = r.byteRangeEndOffset;\n      return Object(a.a)(n) && Object(a.a)(s) && (i.rangeStart = n, i.rangeEnd = s), i;\n    }\n\n    var Et = function (t) {\n      var e, r;\n\n      function i(e) {\n        for (var r, i = arguments.length, a = new Array(i > 1 ? i - 1 : 0), n = 1; n < i; n++) a[n - 1] = arguments[n];\n\n        return (r = t.call.apply(t, [this].concat(a)) || this).data = void 0, r.data = e, r;\n      }\n\n      return r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, pt(e, r), i;\n    }(ct(Error)),\n        St = r(14),\n        Lt = {\n      toString: function (t) {\n        for (var e = \"\", r = t.length, i = 0; i < r; i++) e += \"[\" + t.start(i).toFixed(3) + \",\" + t.end(i).toFixed(3) + \"]\";\n\n        return e;\n      }\n    };\n\n    function At(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    function Rt(t, e) {\n      return (Rt = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    var Dt = \"STOPPED\",\n        _t = \"IDLE\",\n        kt = \"KEY_LOADING\",\n        xt = \"FRAG_LOADING\",\n        Ct = \"FRAG_LOADING_WAITING_RETRY\",\n        wt = \"PARSING\",\n        Ot = \"PARSED\",\n        It = \"BACKTRACKING\",\n        Pt = \"ENDED\",\n        Ft = \"ERROR\",\n        Mt = \"WAITING_LEVEL\",\n        Nt = function (t) {\n      var e, r;\n\n      function i(e, r, i) {\n        var a;\n        return (a = t.call(this) || this).hls = void 0, a.fragPrevious = null, a.fragCurrent = null, a.fragmentTracker = void 0, a.transmuxer = null, a._state = Dt, a.media = void 0, a.mediaBuffer = void 0, a.config = void 0, a.bitrateTest = !1, a.lastCurrentTime = 0, a.nextLoadPosition = 0, a.startPosition = 0, a.loadedmetadata = !1, a.fragLoadError = 0, a.retryDate = 0, a.levels = null, a.fragmentLoader = void 0, a.levelLastLoaded = null, a.startFragRequested = !1, a.decrypter = void 0, a.initPTS = [], a.onvseeking = null, a.onvended = null, a.logPrefix = \"\", a.log = void 0, a.warn = void 0, a.logPrefix = i, a.log = o.b.log.bind(o.b, i + \":\"), a.warn = o.b.warn.bind(o.b, i + \":\"), a.hls = e, a.fragmentLoader = new bt(e.config), a.fragmentTracker = r, a.config = e.config, a.decrypter = new St.a(e, e.config), e.on(n.a.KEY_LOADED, a.onKeyLoaded, function (t) {\n          if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          return t;\n        }(a)), a;\n      }\n\n      r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, Rt(e, r);\n      var u,\n          d,\n          h,\n          f = i.prototype;\n      return f.doTick = function () {\n        this.onTickEnd();\n      }, f.onTickEnd = function () {}, f.startLoad = function (t) {}, f.stopLoad = function () {\n        this.fragmentLoader.abort();\n        var t = this.fragCurrent;\n        t && this.fragmentTracker.removeFragment(t), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = Dt;\n      }, f._streamEnded = function (t, e) {\n        var r = this.fragCurrent,\n            i = this.fragmentTracker;\n\n        if (!e.live && r && r.sn >= e.endSN && !t.nextStart) {\n          var a = e.partList;\n\n          if (null != a && a.length) {\n            var n = a[a.length - 1];\n            return nt.isBuffered(this.media, n.start + n.duration / 2);\n          }\n\n          var s = i.getState(r);\n          return s === $.PARTIAL || s === $.OK;\n        }\n\n        return !1;\n      }, f.onMediaAttached = function (t, e) {\n        var r = this.media = this.mediaBuffer = e.media;\n        this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), r.addEventListener(\"seeking\", this.onvseeking), r.addEventListener(\"ended\", this.onvended);\n        var i = this.config;\n        this.levels && i.autoStartLoad && this.state === Dt && this.startLoad(i.startPosition);\n      }, f.onMediaDetaching = function () {\n        var t = this.media;\n        null != t && t.ended && (this.log(\"MSE detaching and video ended, reset startPosition\"), this.startPosition = this.lastCurrentTime = 0), t && (t.removeEventListener(\"seeking\", this.onvseeking), t.removeEventListener(\"ended\", this.onvended), this.onvseeking = this.onvended = null), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad();\n      }, f.onMediaSeeking = function () {\n        var t = this.config,\n            e = this.fragCurrent,\n            r = this.media,\n            i = this.mediaBuffer,\n            n = this.state,\n            s = r ? r.currentTime : 0,\n            o = nt.bufferInfo(i || r, s, t.maxBufferHole);\n        if (this.log(\"media seeking to \" + (Object(a.a)(s) ? s.toFixed(3) : s) + \", state: \" + n), n === Pt) this.resetLoadingState();else if (e && !o.len) {\n          var l = t.maxFragLookUpTolerance,\n              u = e.start - l,\n              d = s > e.start + e.duration + l;\n          (s < u || d) && (d && e.loader && (this.log(\"seeking outside of buffer while fragment load in progress, cancel fragment load\"), e.loader.abort()), this.resetLoadingState());\n        }\n        r && (this.lastCurrentTime = s), this.loadedmetadata || o.len || (this.nextLoadPosition = this.startPosition = s), this.tickImmediate();\n      }, f.onMediaEnded = function () {\n        this.startPosition = this.lastCurrentTime = 0;\n      }, f.onKeyLoaded = function (t, e) {\n        if (this.state === kt && e.frag === this.fragCurrent && this.levels) {\n          this.state = _t;\n          var r = this.levels[e.frag.level].details;\n          r && this.loadFragment(e.frag, r, e.frag.start);\n        }\n      }, f.onHandlerDestroying = function () {\n        this.stopLoad(), t.prototype.onHandlerDestroying.call(this);\n      }, f.onHandlerDestroyed = function () {\n        this.state = Dt, this.hls.off(n.a.KEY_LOADED, this.onKeyLoaded, this), this.fragmentLoader && this.fragmentLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.fragmentLoader = this.fragmentTracker = null, t.prototype.onHandlerDestroyed.call(this);\n      }, f.loadKey = function (t, e) {\n        this.log(\"Loading key for \" + t.sn + \" of [\" + e.startSN + \"-\" + e.endSN + \"], \" + (\"[stream-controller]\" === this.logPrefix ? \"level\" : \"track\") + \" \" + t.level), this.state = kt, this.fragCurrent = t, this.hls.trigger(n.a.KEY_LOADING, {\n          frag: t\n        });\n      }, f.loadFragment = function (t, e, r) {\n        this._loadFragForPlayback(t, e, r);\n      }, f._loadFragForPlayback = function (t, e, r) {\n        var i = this;\n\n        this._doFragLoad(t, e, r, function (e) {\n          if (i.fragContextChanged(t)) return i.warn(\"Fragment \" + t.sn + (e.part ? \" p: \" + e.part.index : \"\") + \" of level \" + t.level + \" was dropped during download.\"), void i.fragmentTracker.removeFragment(t);\n          t.stats.chunkCount++, i._handleFragmentLoadProgress(e);\n        }).then(function (e) {\n          if (e) {\n            i.fragLoadError = 0;\n            var r = i.state;\n            if (!i.fragContextChanged(t)) return \"payload\" in e && (i.log(\"Loaded fragment \" + t.sn + \" of level \" + t.level), i.hls.trigger(n.a.FRAG_LOADED, e), i.state === It) ? (i.fragmentTracker.backtrack(t, e), void i.resetFragmentLoading(t)) : void i._handleFragmentLoadComplete(e);\n            (r === xt || r === It || !i.fragCurrent && r === wt) && (i.fragmentTracker.removeFragment(t), i.state = _t);\n          }\n        }).catch(function (e) {\n          i.warn(e), i.resetFragmentLoading(t);\n        });\n      }, f.flushMainBuffer = function (t, e, r) {\n        if (void 0 === r && (r = null), t - e) {\n          var i = {\n            startOffset: t,\n            endOffset: e,\n            type: r\n          };\n          this.fragLoadError = 0, this.hls.trigger(n.a.BUFFER_FLUSHING, i);\n        }\n      }, f._loadInitSegment = function (t) {\n        var e = this;\n\n        this._doFragLoad(t).then(function (r) {\n          if (!r || e.fragContextChanged(t) || !e.levels) throw new Error(\"init load aborted\");\n          return r;\n        }).then(function (r) {\n          var i = e.hls,\n              a = r.payload,\n              s = t.decryptdata;\n\n          if (a && a.byteLength > 0 && s && s.key && s.iv && \"AES-128\" === s.method) {\n            var o = self.performance.now();\n            return e.decrypter.webCryptoDecrypt(new Uint8Array(a), s.key.buffer, s.iv.buffer).then(function (e) {\n              var a = self.performance.now();\n              return i.trigger(n.a.FRAG_DECRYPTED, {\n                frag: t,\n                payload: e,\n                stats: {\n                  tstart: o,\n                  tdecrypt: a\n                }\n              }), r.payload = e, r;\n            });\n          }\n\n          return r;\n        }).then(function (r) {\n          var i = e.fragCurrent,\n              a = e.hls,\n              s = e.levels;\n          if (!s) throw new Error(\"init load aborted, missing levels\");\n          s[t.level].details;\n          var o = t.stats;\n          e.state = _t, e.fragLoadError = 0, t.data = new Uint8Array(r.payload), o.parsing.start = o.buffering.start = self.performance.now(), o.parsing.end = o.buffering.end = self.performance.now(), r.frag === i && a.trigger(n.a.FRAG_BUFFERED, {\n            stats: o,\n            frag: i,\n            part: null,\n            id: t.type\n          }), e.tick();\n        }).catch(function (r) {\n          e.warn(r), e.resetFragmentLoading(t);\n        });\n      }, f.fragContextChanged = function (t) {\n        var e = this.fragCurrent;\n        return !t || !e || t.level !== e.level || t.sn !== e.sn || t.urlId !== e.urlId;\n      }, f.fragBufferedComplete = function (t, e) {\n        var r = this.mediaBuffer ? this.mediaBuffer : this.media;\n        this.log(\"Buffered \" + t.type + \" sn: \" + t.sn + (e ? \" part: \" + e.index : \"\") + \" of \" + (\"[stream-controller]\" === this.logPrefix ? \"level\" : \"track\") + \" \" + t.level + \" \" + Lt.toString(nt.getBuffered(r))), this.state = _t, this.tick();\n      }, f._handleFragmentLoadComplete = function (t) {\n        var e = this.transmuxer;\n\n        if (e) {\n          var r = t.frag,\n              i = t.part,\n              a = t.partsLoaded,\n              n = !a || 0 === a.length || a.some(function (t) {\n            return !t;\n          }),\n              s = new st(r.level, r.sn, r.stats.chunkCount + 1, 0, i ? i.index : -1, !n);\n          e.flush(s);\n        }\n      }, f._handleFragmentLoadProgress = function (t) {}, f._doFragLoad = function (t, e, r, i) {\n        var s = this;\n        if (void 0 === r && (r = null), !this.levels) throw new Error(\"frag load aborted, missing levels\");\n\n        if (r = Math.max(t.start, r || 0), this.config.lowLatencyMode && e) {\n          var o = e.partList;\n\n          if (o && i) {\n            r > t.end && e.fragmentHint && (t = e.fragmentHint);\n            var l = this.getNextPart(o, t, r);\n\n            if (l > -1) {\n              var u = o[l];\n              return this.log(\"Loading part sn: \" + t.sn + \" p: \" + u.index + \" cc: \" + t.cc + \" of playlist [\" + e.startSN + \"-\" + e.endSN + \"] parts [0-\" + l + \"-\" + (o.length - 1) + \"] \" + (\"[stream-controller]\" === this.logPrefix ? \"level\" : \"track\") + \": \" + t.level + \", target: \" + parseFloat(r.toFixed(3))), this.nextLoadPosition = u.start + u.duration, this.state = xt, this.hls.trigger(n.a.FRAG_LOADING, {\n                frag: t,\n                part: o[l],\n                targetBufferTime: r\n              }), this.doFragPartsLoad(t, o, l, i).catch(function (t) {\n                return s.handleFragLoadError(t);\n              });\n            }\n\n            if (!t.url || this.loadedEndOfParts(o, r)) return Promise.resolve(null);\n          }\n        }\n\n        return this.log(\"Loading fragment \" + t.sn + \" cc: \" + t.cc + \" \" + (e ? \"of [\" + e.startSN + \"-\" + e.endSN + \"] \" : \"\") + (\"[stream-controller]\" === this.logPrefix ? \"level\" : \"track\") + \": \" + t.level + \", target: \" + parseFloat(r.toFixed(3))), Object(a.a)(t.sn) && !this.bitrateTest && (this.nextLoadPosition = t.start + t.duration), this.state = xt, this.hls.trigger(n.a.FRAG_LOADING, {\n          frag: t,\n          targetBufferTime: r\n        }), this.fragmentLoader.load(t, i).catch(function (t) {\n          return s.handleFragLoadError(t);\n        });\n      }, f.doFragPartsLoad = function (t, e, r, i) {\n        var a = this;\n        return new Promise(function (s, o) {\n          var l = [];\n          !function r(u) {\n            var d = e[u];\n            a.fragmentLoader.loadPart(t, d, i).then(function (i) {\n              l[d.index] = i;\n              var o = i.part;\n              a.hls.trigger(n.a.FRAG_LOADED, i);\n              var h = e[u + 1];\n              if (!h || h.fragment !== t) return s({\n                frag: t,\n                part: o,\n                partsLoaded: l\n              });\n              r(u + 1);\n            }).catch(o);\n          }(r);\n        });\n      }, f.handleFragLoadError = function (t) {\n        var e = t.data;\n        return e && e.details === s.a.INTERNAL_ABORTED ? this.handleFragLoadAborted(e.frag, e.part) : this.hls.trigger(n.a.ERROR, e), null;\n      }, f._handleTransmuxerFlush = function (t) {\n        var e = this.getCurrentContext(t);\n\n        if (e && this.state === wt) {\n          var r = e.frag,\n              i = e.part,\n              a = e.level,\n              n = self.performance.now();\n          r.stats.parsing.end = n, i && (i.stats.parsing.end = n), this.updateLevelTiming(r, i, a, t.partial);\n        } else this.fragCurrent || (this.state = _t);\n      }, f.getCurrentContext = function (t) {\n        var e = this.levels,\n            r = t.level,\n            i = t.sn,\n            a = t.part;\n        if (!e || !e[r]) return this.warn(\"Levels object was unset while buffering fragment \" + i + \" of level \" + r + \". The current chunk will not be buffered.\"), null;\n        var n = e[r],\n            s = a > -1 ? function (t, e, r) {\n          if (!t || !t.details) return null;\n          var i = t.details.partList;\n          if (i) for (var a = i.length; a--;) {\n            var n = i[a];\n            if (n.index === r && n.fragment.sn === e) return n;\n          }\n          return null;\n        }(n, i, a) : null,\n            o = s ? s.fragment : function (t, e, r) {\n          if (!t || !t.details) return null;\n          var i = t.details,\n              a = i.fragments[e - i.startSN];\n          return a || ((a = i.fragmentHint) && a.sn === e ? a : e < i.startSN && r && r.sn === e ? r : null);\n        }(n, i, this.fragCurrent);\n        return o ? {\n          frag: o,\n          part: s,\n          level: n\n        } : null;\n      }, f.bufferFragmentData = function (t, e, r, i) {\n        if (t && this.state === wt) {\n          var a = t.data1,\n              s = t.data2,\n              o = a;\n\n          if (a && s && (o = Object(l.a)(a, s)), o && o.length) {\n            var u = {\n              type: t.type,\n              frag: e,\n              part: r,\n              chunkMeta: i,\n              parent: e.type,\n              data: o\n            };\n            this.hls.trigger(n.a.BUFFER_APPENDING, u), t.dropped && t.independent && !r && this.flushBufferGap(e);\n          }\n        }\n      }, f.flushBufferGap = function (t) {\n        var e = this.media;\n        if (e) if (nt.isBuffered(e, e.currentTime)) {\n          var r = e.currentTime,\n              i = nt.bufferInfo(e, r, 0),\n              a = t.duration,\n              n = Math.min(2 * this.config.maxFragLookUpTolerance, .25 * a),\n              s = Math.max(Math.min(t.start - n, i.end - n), r + n);\n          t.start - s > n && this.flushMainBuffer(s, t.start);\n        } else this.flushMainBuffer(0, t.start);\n      }, f.getFwdBufferInfo = function (t, e) {\n        var r = this.config,\n            i = this.getLoadPosition();\n        if (!Object(a.a)(i)) return null;\n        var n = nt.bufferInfo(t, i, r.maxBufferHole);\n\n        if (0 === n.len && void 0 !== n.nextStart) {\n          var s = this.fragmentTracker.getBufferedFrag(i, e);\n          if (s && n.nextStart < s.end) return nt.bufferInfo(t, i, Math.max(n.nextStart, r.maxBufferHole));\n        }\n\n        return n;\n      }, f.getMaxBufferLength = function (t) {\n        var e,\n            r = this.config;\n        return e = t ? Math.max(8 * r.maxBufferSize / t, r.maxBufferLength) : r.maxBufferLength, Math.min(e, r.maxMaxBufferLength);\n      }, f.reduceMaxBufferLength = function (t) {\n        var e = this.config,\n            r = t || e.maxBufferLength;\n        return e.maxMaxBufferLength >= r && (e.maxMaxBufferLength /= 2, this.warn(\"Reduce max buffer length to \" + e.maxMaxBufferLength + \"s\"), !0);\n      }, f.getNextFragment = function (t, e) {\n        var r,\n            i,\n            a = e.fragments,\n            n = a.length;\n        if (!n) return null;\n        var s,\n            o = this.config,\n            l = a[0].start;\n\n        if (e.live) {\n          var u = o.initialLiveManifestSize;\n          if (n < u) return this.warn(\"Not enough fragments to start playback (have: \" + n + \", need: \" + u + \")\"), null;\n          e.PTSKnown || this.startFragRequested || -1 !== this.startPosition || (s = this.getInitialLiveFragment(e, a), this.startPosition = s ? this.hls.liveSyncPosition || s.start : t);\n        } else t <= l && (s = a[0]);\n\n        if (!s) {\n          var d = o.lowLatencyMode ? e.partEnd : e.fragmentEnd;\n          s = this.getFragmentAtPosition(t, d, e);\n        }\n\n        return null === (r = s) || void 0 === r || !r.initSegment || null !== (i = s) && void 0 !== i && i.initSegment.data || this.bitrateTest || (s = s.initSegment), s;\n      }, f.getNextPart = function (t, e, r) {\n        for (var i = -1, a = !1, n = !0, s = 0, o = t.length; s < o; s++) {\n          var l = t[s];\n          if (n = n && !l.independent, i > -1 && r < l.start) break;\n          var u = l.loaded;\n          !u && (a || l.independent || n) && l.fragment === e && (i = s), a = u;\n        }\n\n        return i;\n      }, f.loadedEndOfParts = function (t, e) {\n        var r = t[t.length - 1];\n        return r && e > r.start && r.loaded;\n      }, f.getInitialLiveFragment = function (t, e) {\n        var r = this.fragPrevious,\n            i = null;\n\n        if (r) {\n          if (t.hasProgramDateTime && (this.log(\"Live playlist, switching playlist, load frag with same PDT: \" + r.programDateTime), i = function (t, e, r) {\n            if (null === e || !Array.isArray(t) || !t.length || !Object(a.a)(e)) return null;\n            if (e < (t[0].programDateTime || 0)) return null;\n            if (e >= (t[t.length - 1].endProgramDateTime || 0)) return null;\n            r = r || 0;\n\n            for (var i = 0; i < t.length; ++i) {\n              var n = t[i];\n              if (ft(e, r, n)) return n;\n            }\n\n            return null;\n          }(e, r.endProgramDateTime, this.config.maxFragLookUpTolerance)), !i) {\n            var n = r.sn + 1;\n\n            if (n >= t.startSN && n <= t.endSN) {\n              var s = e[n - t.startSN];\n              r.cc === s.cc && (i = s, this.log(\"Live playlist, switching playlist, load frag with next SN: \" + i.sn));\n            }\n\n            i || (i = function (t, e) {\n              return dt.search(t, function (t) {\n                return t.cc < e ? 1 : t.cc > e ? -1 : 0;\n              });\n            }(e, r.cc)) && this.log(\"Live playlist, switching playlist, load frag with same CC: \" + i.sn);\n          }\n        } else {\n          var o = this.hls.liveSyncPosition;\n          null !== o && (i = this.getFragmentAtPosition(o, this.bitrateTest ? t.fragmentEnd : t.edge, t));\n        }\n\n        return i;\n      }, f.getFragmentAtPosition = function (t, e, r) {\n        var i,\n            a = this.config,\n            n = this.fragPrevious,\n            s = r.fragments,\n            o = r.endSN,\n            l = r.fragmentHint,\n            u = a.maxFragLookUpTolerance,\n            d = !!(a.lowLatencyMode && r.partList && l);\n        (d && l && !this.bitrateTest && (s = s.concat(l), o = l.sn), t < e) ? i = function (t, e, r, i) {\n          void 0 === r && (r = 0), void 0 === i && (i = 0);\n          var a = null;\n          if (t ? a = e[t.sn - e[0].sn + 1] || null : 0 === r && 0 === e[0].start && (a = e[0]), a && 0 === ht(r, i, a)) return a;\n          var n = dt.search(e, ht.bind(null, r, i));\n          return n || a;\n        }(n, s, t, t > e - u ? 0 : u) : i = s[s.length - 1];\n\n        if (i) {\n          var h = i.sn - r.startSN,\n              f = n && i.level === n.level,\n              c = s[h + 1];\n\n          if (this.fragmentTracker.getState(i) === $.BACKTRACKED) {\n            i = null;\n\n            for (var v = h; s[v] && this.fragmentTracker.getState(s[v]) === $.BACKTRACKED;) i = n ? s[v--] : s[--v];\n\n            i || (i = c);\n          } else n && i.sn === n.sn && !d && f && (i.sn < o && this.fragmentTracker.getState(c) !== $.OK ? (this.log(\"SN \" + i.sn + \" just loaded, load next one: \" + c.sn), i = c) : i = null);\n        }\n\n        return i;\n      }, f.synchronizeToLiveEdge = function (t) {\n        var e = this.config,\n            r = this.media;\n\n        if (r) {\n          var i = this.hls.liveSyncPosition,\n              a = r.currentTime,\n              n = t.fragments[0].start,\n              s = t.edge,\n              o = a >= n - e.maxFragLookUpTolerance && a <= s;\n\n          if (null !== i && r.duration > i && (a < i || !o)) {\n            var l = void 0 !== e.liveMaxLatencyDuration ? e.liveMaxLatencyDuration : e.liveMaxLatencyDurationCount * t.targetduration;\n            (!o && r.readyState < 4 || a < s - l) && (this.loadedmetadata || (this.nextLoadPosition = i), r.readyState && (this.warn(\"Playback: \" + a.toFixed(3) + \" is located too far from the end of live sliding playlist: \" + s + \", reset currentTime to : \" + i.toFixed(3)), r.currentTime = i));\n          }\n        }\n      }, f.alignPlaylists = function (t, e) {\n        var r = this.levels,\n            i = this.levelLastLoaded,\n            n = this.fragPrevious,\n            s = null !== i ? r[i] : null,\n            o = t.fragments.length;\n        if (!o) return this.warn(\"No fragments in live playlist\"), 0;\n        var l = t.fragments[0].start,\n            u = !e,\n            d = t.alignedSliding && Object(a.a)(l);\n\n        if (u || !d && !l) {\n          ut(n, s, t);\n          var h = t.fragments[0].start;\n          return this.log(\"Live playlist sliding: \" + h.toFixed(2) + \" start-sn: \" + (e ? e.startSN : \"na\") + \"->\" + t.startSN + \" prev-sn: \" + (n ? n.sn : \"na\") + \" fragments: \" + o), h;\n        }\n\n        return l;\n      }, f.waitForCdnTuneIn = function (t) {\n        return t.live && t.canBlockReload && t.tuneInGoal > Math.max(t.partHoldBack, 3 * t.partTarget);\n      }, f.setStartPosition = function (t, e) {\n        var r = this.startPosition;\n\n        if (r < e && (r = -1), -1 === r || -1 === this.lastCurrentTime) {\n          var i = t.startTimeOffset;\n          Object(a.a)(i) ? (r = e + i, i < 0 && (r += t.totalduration), r = Math.min(Math.max(e, r), e + t.totalduration), this.log(\"Start time offset \" + i + \" found in playlist, adjust startPosition to \" + r), this.startPosition = r) : t.live ? r = this.hls.liveSyncPosition || e : this.startPosition = r = 0, this.lastCurrentTime = r;\n        }\n\n        this.nextLoadPosition = r;\n      }, f.getLoadPosition = function () {\n        var t = this.media,\n            e = 0;\n        return this.loadedmetadata && t ? e = t.currentTime : this.nextLoadPosition && (e = this.nextLoadPosition), e;\n      }, f.handleFragLoadAborted = function (t, e) {\n        this.transmuxer && \"initSegment\" !== t.sn && t.stats.aborted && (this.warn(\"Fragment \" + t.sn + (e ? \" part\" + e.index : \"\") + \" of level \" + t.level + \" was aborted\"), this.resetFragmentLoading(t));\n      }, f.resetFragmentLoading = function (t) {\n        this.fragCurrent && this.fragContextChanged(t) || (this.state = _t);\n      }, f.onFragmentOrKeyLoadError = function (t, e) {\n        if (!e.fatal) {\n          var r = e.frag;\n\n          if (r && r.type === t) {\n            this.fragCurrent;\n            var i = this.config;\n\n            if (this.fragLoadError + 1 <= i.fragLoadingMaxRetry) {\n              if (this.resetLiveStartWhenNotLoaded(r.level)) return;\n              var a = Math.min(Math.pow(2, this.fragLoadError) * i.fragLoadingRetryDelay, i.fragLoadingMaxRetryTimeout);\n              this.warn(\"Fragment \" + r.sn + \" of \" + t + \" \" + r.level + \" failed to load, retrying in \" + a + \"ms\"), this.retryDate = self.performance.now() + a, this.fragLoadError++, this.state = Ct;\n            } else e.levelRetry ? (t === _.b.AUDIO && (this.fragCurrent = null), this.fragLoadError = 0, this.state = _t) : (o.b.error(e.details + \" reaches max retry, redispatch as fatal ...\"), e.fatal = !0, this.hls.stopLoad(), this.state = Ft);\n          }\n        }\n      }, f.afterBufferFlushed = function (t, e, r) {\n        if (t) {\n          var i = nt.getBuffered(t);\n          this.fragmentTracker.detectEvictedFragments(e, i, r), this.state === Pt && this.resetLoadingState();\n        }\n      }, f.resetLoadingState = function () {\n        this.fragCurrent = null, this.fragPrevious = null, this.state = _t;\n      }, f.resetLiveStartWhenNotLoaded = function (t) {\n        if (!this.loadedmetadata) {\n          this.startFragRequested = !1;\n          var e = this.levels ? this.levels[t].details : null;\n          if (null != e && e.live) return this.startPosition = -1, this.setStartPosition(e, 0), this.resetLoadingState(), !0;\n          this.nextLoadPosition = this.startPosition;\n        }\n\n        return !1;\n      }, f.updateLevelTiming = function (t, e, r, i) {\n        var a = this,\n            s = r.details;\n        Object.keys(t.elementaryStreams).reduce(function (e, o) {\n          var l = t.elementaryStreams[o];\n\n          if (l) {\n            var u = l.endPTS - l.startPTS;\n            if (u <= 0) return a.warn(\"Could not parse fragment \" + t.sn + \" \" + o + \" duration reliably (\" + u + \") resetting transmuxer to fallback to playlist timing\"), a.resetTransmuxer(), e || !1;\n            var d = i ? 0 : V(s, t, l.startPTS, l.endPTS, l.startDTS, l.endDTS);\n            return a.hls.trigger(n.a.LEVEL_PTS_UPDATED, {\n              details: s,\n              level: r,\n              drift: d,\n              type: o,\n              frag: t,\n              start: l.startPTS,\n              end: l.endPTS\n            }), !0;\n          }\n\n          return e;\n        }, !1) ? (this.state = Ot, this.hls.trigger(n.a.FRAG_PARSED, {\n          frag: t,\n          part: e\n        })) : this.resetLoadingState();\n      }, f.resetTransmuxer = function () {\n        this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null);\n      }, u = i, (d = [{\n        key: \"state\",\n        get: function () {\n          return this._state;\n        },\n        set: function (t) {\n          var e = this._state;\n          e !== t && (this._state = t, this.log(e + \"->\" + t));\n        }\n      }]) && At(u.prototype, d), h && At(u, h), i;\n    }(it);\n\n    function Bt() {\n      return self.MediaSource || self.WebKitMediaSource;\n    }\n\n    function Ut() {\n      return self.SourceBuffer || self.WebKitSourceBuffer;\n    }\n\n    var Gt = r(17),\n        jt = r(9),\n        Ht = r(13),\n        Kt = Bt() || {\n      isTypeSupported: function () {\n        return !1;\n      }\n    },\n        Vt = function () {\n      function t(t, e, r, i) {\n        var a = this;\n        this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.worker = void 0, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0, this.hls = t, this.id = e, this.onTransmuxComplete = r, this.onFlush = i;\n\n        var l = t.config,\n            u = function (e, r) {\n          (r = r || {}).frag = a.frag, r.id = a.id, t.trigger(e, r);\n        };\n\n        this.observer = new Ht.EventEmitter(), this.observer.on(n.a.FRAG_DECRYPTED, u), this.observer.on(n.a.ERROR, u);\n        var d = {\n          mp4: Kt.isTypeSupported(\"video/mp4\"),\n          mpeg: Kt.isTypeSupported(\"audio/mpeg\"),\n          mp3: Kt.isTypeSupported('audio/mp4; codecs=\"mp3\"')\n        },\n            h = navigator.vendor;\n\n        if (l.enableWorker && \"undefined\" != typeof Worker) {\n          var f;\n          o.b.log(\"demuxing in webworker\");\n\n          try {\n            f = this.worker = Gt(18), this.onwmsg = this.onWorkerMessage.bind(this), f.addEventListener(\"message\", this.onwmsg), f.onerror = function (e) {\n              t.trigger(n.a.ERROR, {\n                type: s.b.OTHER_ERROR,\n                details: s.a.INTERNAL_EXCEPTION,\n                fatal: !0,\n                event: \"demuxerWorker\",\n                error: new Error(e.message + \"  (\" + e.filename + \":\" + e.lineno + \")\")\n              });\n            }, f.postMessage({\n              cmd: \"init\",\n              typeSupported: d,\n              vendor: h,\n              id: e,\n              config: JSON.stringify(l)\n            });\n          } catch (t) {\n            o.b.warn(\"Error in worker:\", t), o.b.error(\"Error while initializing DemuxerWorker, fallback to inline\"), f && self.URL.revokeObjectURL(f.objectURL), this.transmuxer = new jt.c(this.observer, d, l, h, e), this.worker = null;\n          }\n        } else this.transmuxer = new jt.c(this.observer, d, l, h, e);\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        var t = this.worker;\n        if (t) t.removeEventListener(\"message\", this.onwmsg), t.terminate(), this.worker = null;else {\n          var e = this.transmuxer;\n          e && (e.destroy(), this.transmuxer = null);\n        }\n        var r = this.observer;\n        r && r.removeAllListeners(), this.observer = null;\n      }, e.push = function (t, e, r, i, a, n, s, l, u, d) {\n        var h,\n            f,\n            c = this;\n        u.transmuxing.start = self.performance.now();\n        var v = this.transmuxer,\n            g = this.worker,\n            p = n ? n.start : a.start,\n            m = a.decryptdata,\n            y = this.frag,\n            b = !(y && a.cc === y.cc),\n            T = !(y && u.level === y.level),\n            E = y ? u.sn - y.sn : -1,\n            S = this.part ? u.part - this.part.index : 1,\n            L = !T && (1 === E || 0 === E && 1 === S),\n            A = self.performance.now();\n        (T || E || 0 === a.stats.parsing.start) && (a.stats.parsing.start = A), !n || !S && L || (n.stats.parsing.start = A);\n        var R = !(y && (null === (h = a.initSegment) || void 0 === h ? void 0 : h.url) === (null === (f = y.initSegment) || void 0 === f ? void 0 : f.url)),\n            D = new jt.b(b, L, l, T, p, R);\n\n        if (!L || b || R) {\n          o.b.log(\"[transmuxer-interface, \" + a.type + \"]: Starting new transmux session for sn: \" + u.sn + \" p: \" + u.part + \" level: \" + u.level + \" id: \" + u.id + \"\\n        discontinuity: \" + b + \"\\n        trackSwitch: \" + T + \"\\n        contiguous: \" + L + \"\\n        accurateTimeOffset: \" + l + \"\\n        timeOffset: \" + p + \"\\n        initSegmentChange: \" + R);\n\n          var _ = new jt.a(r, i, e, s, d);\n\n          this.configureTransmuxer(_);\n        }\n\n        if (this.frag = a, this.part = n, g) g.postMessage({\n          cmd: \"demux\",\n          data: t,\n          decryptdata: m,\n          chunkMeta: u,\n          state: D\n        }, t instanceof ArrayBuffer ? [t] : []);else if (v) {\n          var k = v.push(t, m, u, D);\n          Object(jt.d)(k) ? k.then(function (t) {\n            c.handleTransmuxComplete(t);\n          }) : this.handleTransmuxComplete(k);\n        }\n      }, e.flush = function (t) {\n        var e = this;\n        t.transmuxing.start = self.performance.now();\n        var r = this.transmuxer,\n            i = this.worker;\n        if (i) i.postMessage({\n          cmd: \"flush\",\n          chunkMeta: t\n        });else if (r) {\n          var a = r.flush(t);\n          Object(jt.d)(a) ? a.then(function (r) {\n            e.handleFlushResult(r, t);\n          }) : this.handleFlushResult(a, t);\n        }\n      }, e.handleFlushResult = function (t, e) {\n        var r = this;\n        t.forEach(function (t) {\n          r.handleTransmuxComplete(t);\n        }), this.onFlush(e);\n      }, e.onWorkerMessage = function (t) {\n        var e = t.data,\n            r = this.hls;\n\n        switch (e.event) {\n          case \"init\":\n            self.URL.revokeObjectURL(this.worker.objectURL);\n            break;\n\n          case \"transmuxComplete\":\n            this.handleTransmuxComplete(e.data);\n            break;\n\n          case \"flush\":\n            this.onFlush(e.data);\n            break;\n\n          default:\n            e.data = e.data || {}, e.data.frag = this.frag, e.data.id = this.id, r.trigger(e.event, e.data);\n        }\n      }, e.configureTransmuxer = function (t) {\n        var e = this.worker,\n            r = this.transmuxer;\n        e ? e.postMessage({\n          cmd: \"configure\",\n          config: t\n        }) : r && r.configure(t);\n      }, e.handleTransmuxComplete = function (t) {\n        t.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(t);\n      }, t;\n    }(),\n        Wt = function () {\n      function t(t, e, r, i) {\n        this.config = void 0, this.media = void 0, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = t, this.media = e, this.fragmentTracker = r, this.hls = i;\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        this.hls = this.fragmentTracker = this.media = null;\n      }, e.poll = function (t) {\n        var e = this.config,\n            r = this.media,\n            i = this.stalled,\n            a = r.currentTime,\n            n = r.seeking,\n            s = this.seeking && !n,\n            l = !this.seeking && n;\n\n        if (this.seeking = n, a === t) {\n          if ((l || s) && (this.stalled = null), !r.paused && !r.ended && 0 !== r.playbackRate && nt.getBuffered(r).length) {\n            var u = nt.bufferInfo(r, a, 0),\n                d = u.len > 0,\n                h = u.nextStart || 0;\n\n            if (d || h) {\n              if (n) {\n                var f = u.len > 2,\n                    c = !h || h - a > 2 && !this.fragmentTracker.getPartialFragment(a);\n                if (f || c) return;\n                this.moved = !1;\n              }\n\n              if (!this.moved && null !== this.stalled) {\n                var v,\n                    g = Math.max(h, u.start || 0) - a,\n                    p = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null,\n                    m = (null == p || null === (v = p.details) || void 0 === v ? void 0 : v.live) ? 2 * p.details.targetduration : 2;\n                if (g > 0 && g <= m) return void this._trySkipBufferHole(null);\n              }\n\n              var y = self.performance.now();\n\n              if (null !== i) {\n                var b = y - i;\n                !n && b >= 250 && this._reportStall(u.len);\n                var T = nt.bufferInfo(r, a, e.maxBufferHole);\n\n                this._tryFixBufferStall(T, b);\n              } else this.stalled = y;\n            }\n          }\n        } else if (this.moved = !0, null !== i) {\n          if (this.stallReported) {\n            var E = self.performance.now() - i;\n            o.b.warn(\"playback not stuck anymore @\" + a + \", after \" + Math.round(E) + \"ms\"), this.stallReported = !1;\n          }\n\n          this.stalled = null, this.nudgeRetry = 0;\n        }\n      }, e._tryFixBufferStall = function (t, e) {\n        var r = this.config,\n            i = this.fragmentTracker,\n            a = this.media.currentTime,\n            n = i.getPartialFragment(a);\n        if (n && this._trySkipBufferHole(n)) return;\n        t.len > r.maxBufferHole && e > 1e3 * r.highBufferWatchdogPeriod && (o.b.warn(\"Trying to nudge playhead over buffer-hole\"), this.stalled = null, this._tryNudgeBuffer());\n      }, e._reportStall = function (t) {\n        var e = this.hls,\n            r = this.media;\n        this.stallReported || (this.stallReported = !0, o.b.warn(\"Playback stalling at @\" + r.currentTime + \" due to low buffer (buffer=\" + t + \")\"), e.trigger(n.a.ERROR, {\n          type: s.b.MEDIA_ERROR,\n          details: s.a.BUFFER_STALLED_ERROR,\n          fatal: !1,\n          buffer: t\n        }));\n      }, e._trySkipBufferHole = function (t) {\n        for (var e = this.config, r = this.hls, i = this.media, a = i.currentTime, l = 0, u = nt.getBuffered(i), d = 0; d < u.length; d++) {\n          var h = u.start(d);\n\n          if (a + e.maxBufferHole >= l && a < h) {\n            var f = Math.max(h + .05, i.currentTime + .1);\n            return o.b.warn(\"skipping hole, adjusting currentTime from \" + a + \" to \" + f), this.moved = !0, this.stalled = null, i.currentTime = f, t && r.trigger(n.a.ERROR, {\n              type: s.b.MEDIA_ERROR,\n              details: s.a.BUFFER_SEEK_OVER_HOLE,\n              fatal: !1,\n              reason: \"fragment loaded with buffer holes, seeking from \" + a + \" to \" + f,\n              frag: t\n            }), f;\n          }\n\n          l = u.end(d);\n        }\n\n        return 0;\n      }, e._tryNudgeBuffer = function () {\n        var t = this.config,\n            e = this.hls,\n            r = this.media,\n            i = r.currentTime,\n            a = (this.nudgeRetry || 0) + 1;\n\n        if (this.nudgeRetry = a, a < t.nudgeMaxRetry) {\n          var l = i + a * t.nudgeOffset;\n          o.b.warn(\"Nudging 'currentTime' from \" + i + \" to \" + l), r.currentTime = l, e.trigger(n.a.ERROR, {\n            type: s.b.MEDIA_ERROR,\n            details: s.a.BUFFER_NUDGE_ON_STALL,\n            fatal: !1\n          });\n        } else o.b.error(\"Playhead still not moving while enough data buffered @\" + i + \" after \" + t.nudgeMaxRetry + \" nudges\"), e.trigger(n.a.ERROR, {\n          type: s.b.MEDIA_ERROR,\n          details: s.a.BUFFER_STALLED_ERROR,\n          fatal: !0\n        });\n      }, t;\n    }();\n\n    function Yt(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    function Xt(t, e) {\n      return (Xt = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    var qt = function (t) {\n      var e, r;\n\n      function i(e, r) {\n        var i;\n        return (i = t.call(this, e, r, \"[stream-controller]\") || this).audioCodecSwap = !1, i.gapController = null, i.level = -1, i._forceStartLoad = !1, i.altAudio = !1, i.audioOnly = !1, i.fragPlaying = null, i.onvplaying = null, i.onvseeked = null, i.fragLastKbps = 0, i.stalled = !1, i.couldBacktrack = !1, i.audioCodecSwitch = !1, i.videoBuffer = null, i._registerListeners(), i;\n      }\n\n      r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, Xt(e, r);\n      var l,\n          d,\n          h,\n          f = i.prototype;\n      return f._registerListeners = function () {\n        var t = this.hls;\n        t.on(n.a.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(n.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(n.a.MANIFEST_LOADING, this.onManifestLoading, this), t.on(n.a.MANIFEST_PARSED, this.onManifestParsed, this), t.on(n.a.LEVEL_LOADING, this.onLevelLoading, this), t.on(n.a.LEVEL_LOADED, this.onLevelLoaded, this), t.on(n.a.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), t.on(n.a.ERROR, this.onError, this), t.on(n.a.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.on(n.a.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.on(n.a.BUFFER_CREATED, this.onBufferCreated, this), t.on(n.a.BUFFER_FLUSHED, this.onBufferFlushed, this), t.on(n.a.LEVELS_UPDATED, this.onLevelsUpdated, this), t.on(n.a.FRAG_BUFFERED, this.onFragBuffered, this);\n      }, f._unregisterListeners = function () {\n        var t = this.hls;\n        t.off(n.a.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(n.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(n.a.MANIFEST_LOADING, this.onManifestLoading, this), t.off(n.a.MANIFEST_PARSED, this.onManifestParsed, this), t.off(n.a.LEVEL_LOADED, this.onLevelLoaded, this), t.off(n.a.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), t.off(n.a.ERROR, this.onError, this), t.off(n.a.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.off(n.a.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.off(n.a.BUFFER_CREATED, this.onBufferCreated, this), t.off(n.a.BUFFER_FLUSHED, this.onBufferFlushed, this), t.off(n.a.LEVELS_UPDATED, this.onLevelsUpdated, this), t.off(n.a.FRAG_BUFFERED, this.onFragBuffered, this);\n      }, f.onHandlerDestroying = function () {\n        this._unregisterListeners(), this.onMediaDetaching();\n      }, f.startLoad = function (t) {\n        if (this.levels) {\n          var e = this.lastCurrentTime,\n              r = this.hls;\n\n          if (this.stopLoad(), this.setInterval(100), this.level = -1, this.fragLoadError = 0, !this.startFragRequested) {\n            var i = r.startLevel;\n            -1 === i && (r.config.testBandwidth ? (i = 0, this.bitrateTest = !0) : i = r.nextAutoLevel), this.level = r.nextLoadLevel = i, this.loadedmetadata = !1;\n          }\n\n          e > 0 && -1 === t && (this.log(\"Override startPosition with lastCurrentTime @\" + e.toFixed(3)), t = e), this.state = _t, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = t, this.tick();\n        } else this._forceStartLoad = !0, this.state = Dt;\n      }, f.stopLoad = function () {\n        this._forceStartLoad = !1, t.prototype.stopLoad.call(this);\n      }, f.doTick = function () {\n        switch (this.state) {\n          case _t:\n            this.doTickIdle();\n            break;\n\n          case Mt:\n            var t,\n                e = this.levels,\n                r = this.level,\n                i = null == e || null === (t = e[r]) || void 0 === t ? void 0 : t.details;\n\n            if (i && (!i.live || this.levelLastLoaded === this.level)) {\n              if (this.waitForCdnTuneIn(i)) break;\n              this.state = _t;\n              break;\n            }\n\n            break;\n\n          case Ct:\n            var a,\n                n = self.performance.now(),\n                s = this.retryDate;\n            (!s || n >= s || null !== (a = this.media) && void 0 !== a && a.seeking) && (this.log(\"retryDate reached, switch back to IDLE state\"), this.state = _t);\n        }\n\n        this.onTickEnd();\n      }, f.onTickEnd = function () {\n        t.prototype.onTickEnd.call(this), this.checkBuffer(), this.checkFragmentChanged();\n      }, f.doTickIdle = function () {\n        var t,\n            e,\n            r = this.hls,\n            i = this.levelLastLoaded,\n            a = this.levels,\n            s = this.media,\n            o = r.config,\n            l = r.nextLoadLevel;\n\n        if (null !== i && (s || !this.startFragRequested && o.startFragPrefetch) && (!this.altAudio || !this.audioOnly) && a && a[l]) {\n          var d = a[l];\n          this.level = r.nextLoadLevel = l;\n          var h = d.details;\n          if (!h || this.state === Mt || h.live && this.levelLastLoaded !== l) this.state = Mt;else {\n            var f = this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : s, _.b.MAIN);\n            if (null !== f) if (!(f.len >= this.getMaxBufferLength(d.maxBitrate))) {\n              if (this._streamEnded(f, h)) {\n                var c = {};\n                return this.altAudio && (c.type = \"video\"), this.hls.trigger(n.a.BUFFER_EOS, c), void (this.state = Pt);\n              }\n\n              var v = f.end,\n                  g = this.getNextFragment(v, h);\n\n              if (this.couldBacktrack && !this.fragPrevious && g && \"initSegment\" !== g.sn) {\n                var p = g.sn - h.startSN;\n                p > 1 && (g = h.fragments[p - 1], this.fragmentTracker.removeFragment(g));\n              }\n\n              if (g && this.fragmentTracker.getState(g) === $.OK && this.nextLoadPosition > v) {\n                var m = this.audioOnly && !this.altAudio ? u.a.AUDIO : u.a.VIDEO;\n                this.afterBufferFlushed(s, m, _.b.MAIN), g = this.getNextFragment(this.nextLoadPosition, h);\n              }\n\n              g && (!g.initSegment || g.initSegment.data || this.bitrateTest || (g = g.initSegment), \"identity\" !== (null === (t = g.decryptdata) || void 0 === t ? void 0 : t.keyFormat) || null !== (e = g.decryptdata) && void 0 !== e && e.key ? this.loadFragment(g, h, v) : this.loadKey(g, h));\n            }\n          }\n        }\n      }, f.loadFragment = function (e, r, i) {\n        var a,\n            n = this.fragmentTracker.getState(e);\n\n        if (this.fragCurrent = e, n === $.BACKTRACKED) {\n          var s = this.fragmentTracker.getBacktrackData(e);\n          if (s) return this._handleFragmentLoadProgress(s), void this._handleFragmentLoadComplete(s);\n          n = $.NOT_LOADED;\n        }\n\n        n === $.NOT_LOADED || n === $.PARTIAL ? \"initSegment\" === e.sn ? this._loadInitSegment(e) : this.bitrateTest ? (e.bitrateTest = !0, this.log(\"Fragment \" + e.sn + \" of level \" + e.level + \" is being downloaded to test bitrate and will not be buffered\"), this._loadBitrateTestFrag(e)) : (this.startFragRequested = !0, t.prototype.loadFragment.call(this, e, r, i)) : n === $.APPENDING ? this.reduceMaxBufferLength(e.duration) && this.fragmentTracker.removeFragment(e) : 0 === (null === (a = this.media) || void 0 === a ? void 0 : a.buffered.length) && this.fragmentTracker.removeAllFragments();\n      }, f.getAppendedFrag = function (t) {\n        var e = this.fragmentTracker.getAppendedFrag(t, _.b.MAIN);\n        return e && \"fragment\" in e ? e.fragment : e;\n      }, f.getBufferedFrag = function (t) {\n        return this.fragmentTracker.getBufferedFrag(t, _.b.MAIN);\n      }, f.followingBufferedFrag = function (t) {\n        return t ? this.getBufferedFrag(t.end + .5) : null;\n      }, f.immediateLevelSwitch = function () {\n        this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n      }, f.nextLevelSwitch = function () {\n        var t = this.levels,\n            e = this.media;\n\n        if (null != e && e.readyState) {\n          var r,\n              i = this.getAppendedFrag(e.currentTime);\n\n          if (i && i.start > 1 && this.flushMainBuffer(0, i.start - 1), !e.paused && t) {\n            var a = t[this.hls.nextLoadLevel],\n                n = this.fragLastKbps;\n            r = n && this.fragCurrent ? this.fragCurrent.duration * a.maxBitrate / (1e3 * n) + 1 : 0;\n          } else r = 0;\n\n          var s = this.getBufferedFrag(e.currentTime + r);\n\n          if (s) {\n            var o = this.followingBufferedFrag(s);\n\n            if (o) {\n              this.abortCurrentFrag();\n              var l = o.maxStartPTS ? o.maxStartPTS : o.start,\n                  u = o.duration,\n                  d = Math.max(s.end, l + Math.min(Math.max(u - this.config.maxFragLookUpTolerance, .5 * u), .75 * u));\n              this.flushMainBuffer(d, Number.POSITIVE_INFINITY);\n            }\n          }\n        }\n      }, f.abortCurrentFrag = function () {\n        var t = this.fragCurrent;\n        this.fragCurrent = null, null != t && t.loader && t.loader.abort(), this.state === kt && (this.state = _t), this.nextLoadPosition = this.getLoadPosition();\n      }, f.flushMainBuffer = function (e, r) {\n        t.prototype.flushMainBuffer.call(this, e, r, this.altAudio ? \"video\" : null);\n      }, f.onMediaAttached = function (e, r) {\n        t.prototype.onMediaAttached.call(this, e, r);\n        var i = r.media;\n        this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), i.addEventListener(\"playing\", this.onvplaying), i.addEventListener(\"seeked\", this.onvseeked), this.gapController = new Wt(this.config, i, this.fragmentTracker, this.hls);\n      }, f.onMediaDetaching = function () {\n        var e = this.media;\n        e && (e.removeEventListener(\"playing\", this.onvplaying), e.removeEventListener(\"seeked\", this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), t.prototype.onMediaDetaching.call(this);\n      }, f.onMediaPlaying = function () {\n        this.tick();\n      }, f.onMediaSeeked = function () {\n        var t = this.media,\n            e = t ? t.currentTime : null;\n        Object(a.a)(e) && this.log(\"Media seeked to \" + e.toFixed(3)), this.tick();\n      }, f.onManifestLoading = function () {\n        this.log(\"Trigger BUFFER_RESET\"), this.hls.trigger(n.a.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = this.stalled = !1, this.startPosition = this.lastCurrentTime = 0, this.fragPlaying = null;\n      }, f.onManifestParsed = function (t, e) {\n        var r,\n            i,\n            a,\n            n = !1,\n            s = !1;\n        e.levels.forEach(function (t) {\n          (r = t.audioCodec) && (-1 !== r.indexOf(\"mp4a.40.2\") && (n = !0), -1 !== r.indexOf(\"mp4a.40.5\") && (s = !0));\n        }), this.audioCodecSwitch = n && s && !(\"function\" == typeof (null == (a = Ut()) || null === (i = a.prototype) || void 0 === i ? void 0 : i.changeType)), this.audioCodecSwitch && this.log(\"Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC\"), this.levels = e.levels, this.startFragRequested = !1;\n      }, f.onLevelLoading = function (t, e) {\n        var r = this.levels;\n\n        if (r && this.state === _t) {\n          var i = r[e.level];\n          (!i.details || i.details.live && this.levelLastLoaded !== e.level || this.waitForCdnTuneIn(i.details)) && (this.state = Mt);\n        }\n      }, f.onLevelLoaded = function (t, e) {\n        var r,\n            i = this.levels,\n            a = e.level,\n            s = e.details,\n            o = s.totalduration;\n\n        if (i) {\n          this.log(\"Level \" + a + \" loaded [\" + s.startSN + \",\" + s.endSN + \"], cc [\" + s.startCC + \", \" + s.endCC + \"] duration:\" + o);\n          var l = this.fragCurrent;\n          !l || this.state !== xt && this.state !== Ct || l.level !== e.level && l.loader && (this.state = _t, l.loader.abort());\n          var u = i[a],\n              d = 0;\n\n          if (s.live || null !== (r = u.details) && void 0 !== r && r.live) {\n            if (s.fragments[0] || (s.deltaUpdateFailed = !0), s.deltaUpdateFailed) return;\n            d = this.alignPlaylists(s, u.details);\n          }\n\n          if (u.details = s, this.levelLastLoaded = a, this.hls.trigger(n.a.LEVEL_UPDATED, {\n            details: s,\n            level: a\n          }), this.state === Mt) {\n            if (this.waitForCdnTuneIn(s)) return;\n            this.state = _t;\n          }\n\n          this.startFragRequested ? s.live && this.synchronizeToLiveEdge(s) : this.setStartPosition(s, d), this.tick();\n        } else this.warn(\"Levels were reset while loading level \" + a);\n      }, f._handleFragmentLoadProgress = function (t) {\n        var e,\n            r = t.frag,\n            i = t.part,\n            a = t.payload,\n            n = this.levels;\n\n        if (n) {\n          var s = n[r.level],\n              o = s.details;\n\n          if (o) {\n            var l = s.videoCodec,\n                u = o.PTSKnown || !o.live,\n                d = null === (e = r.initSegment) || void 0 === e ? void 0 : e.data,\n                h = this._getAudioCodec(s),\n                f = this.transmuxer = this.transmuxer || new Vt(this.hls, _.b.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)),\n                c = i ? i.index : -1,\n                v = -1 !== c,\n                g = new st(r.level, r.sn, r.stats.chunkCount, a.byteLength, c, v),\n                p = this.initPTS[r.cc];\n\n            f.push(a, d, h, l, r, i, o.totalduration, u, g, p);\n          } else this.warn(\"Dropping fragment \" + r.sn + \" of level \" + r.level + \" after level details were reset\");\n        } else this.warn(\"Levels were reset while fragment load was in progress. Fragment \" + r.sn + \" of level \" + r.level + \" will not be buffered\");\n      }, f.onAudioTrackSwitching = function (t, e) {\n        var r = this.altAudio,\n            i = !!e.url,\n            a = e.id;\n\n        if (!i) {\n          if (this.mediaBuffer !== this.media) {\n            this.log(\"Switching on main audio, use media.buffered to schedule main fragment loading\"), this.mediaBuffer = this.media;\n            var s = this.fragCurrent;\n            null != s && s.loader && (this.log(\"Switching to main audio track, cancel main fragment load\"), s.loader.abort()), this.resetTransmuxer(), this.resetLoadingState();\n          } else this.audioOnly && this.resetTransmuxer();\n\n          var o = this.hls;\n          r && o.trigger(n.a.BUFFER_FLUSHING, {\n            startOffset: 0,\n            endOffset: Number.POSITIVE_INFINITY,\n            type: \"audio\"\n          }), o.trigger(n.a.AUDIO_TRACK_SWITCHED, {\n            id: a\n          });\n        }\n      }, f.onAudioTrackSwitched = function (t, e) {\n        var r = e.id,\n            i = !!this.hls.audioTracks[r].url;\n\n        if (i) {\n          var a = this.videoBuffer;\n          a && this.mediaBuffer !== a && (this.log(\"Switching on alternate audio, use video.buffered to schedule main fragment loading\"), this.mediaBuffer = a);\n        }\n\n        this.altAudio = i, this.tick();\n      }, f.onBufferCreated = function (t, e) {\n        var r,\n            i,\n            a = e.tracks,\n            n = !1;\n\n        for (var s in a) {\n          var o = a[s];\n\n          if (\"main\" === o.id) {\n            if (i = s, r = o, \"video\" === s) {\n              var l = a[s];\n              l && (this.videoBuffer = l.buffer);\n            }\n          } else n = !0;\n        }\n\n        n && r ? (this.log(\"Alternate track found, use \" + i + \".buffered to schedule main fragment loading\"), this.mediaBuffer = r.buffer) : this.mediaBuffer = this.media;\n      }, f.onFragBuffered = function (t, e) {\n        var r = e.frag,\n            i = e.part;\n\n        if (!r || r.type === _.b.MAIN) {\n          if (this.fragContextChanged(r)) return this.warn(\"Fragment \" + r.sn + (i ? \" p: \" + i.index : \"\") + \" of level \" + r.level + \" finished buffering, but was aborted. state: \" + this.state), void (this.state === Ot && (this.state = _t));\n          var a = i ? i.stats : r.stats;\n          this.fragLastKbps = Math.round(8 * a.total / (a.buffering.end - a.loading.first)), \"initSegment\" !== r.sn && (this.fragPrevious = r), this.fragBufferedComplete(r, i);\n        }\n      }, f.onError = function (t, e) {\n        switch (e.details) {\n          case s.a.FRAG_LOAD_ERROR:\n          case s.a.FRAG_LOAD_TIMEOUT:\n          case s.a.KEY_LOAD_ERROR:\n          case s.a.KEY_LOAD_TIMEOUT:\n            this.onFragmentOrKeyLoadError(_.b.MAIN, e);\n            break;\n\n          case s.a.LEVEL_LOAD_ERROR:\n          case s.a.LEVEL_LOAD_TIMEOUT:\n            this.state !== Ft && (e.fatal ? (this.warn(\"\" + e.details), this.state = Ft) : e.levelRetry || this.state !== Mt || (this.state = _t));\n            break;\n\n          case s.a.BUFFER_FULL_ERROR:\n            if (\"main\" === e.parent && (this.state === wt || this.state === Ot)) {\n              var r = !0,\n                  i = this.getFwdBufferInfo(this.media, _.b.MAIN);\n              i && i.len > .5 && (r = !this.reduceMaxBufferLength(i.len)), r && (this.warn(\"buffer full error also media.currentTime is not buffered, flush main\"), this.immediateLevelSwitch()), this.resetLoadingState();\n            }\n\n        }\n      }, f.checkBuffer = function () {\n        var t = this.media,\n            e = this.gapController;\n\n        if (t && e && t.readyState) {\n          var r = nt.getBuffered(t);\n          !this.loadedmetadata && r.length ? (this.loadedmetadata = !0, this.seekToStartPos()) : e.poll(this.lastCurrentTime), this.lastCurrentTime = t.currentTime;\n        }\n      }, f.onFragLoadEmergencyAborted = function () {\n        this.state = _t, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tickImmediate();\n      }, f.onBufferFlushed = function (t, e) {\n        var r = e.type;\n\n        if (r !== u.a.AUDIO || this.audioOnly && !this.altAudio) {\n          var i = (r === u.a.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n          this.afterBufferFlushed(i, r, _.b.MAIN);\n        }\n      }, f.onLevelsUpdated = function (t, e) {\n        this.levels = e.levels;\n      }, f.swapAudioCodec = function () {\n        this.audioCodecSwap = !this.audioCodecSwap;\n      }, f.seekToStartPos = function () {\n        var t = this.media,\n            e = t.currentTime,\n            r = this.startPosition;\n\n        if (r >= 0 && e < r) {\n          if (t.seeking) return void o.b.log(\"could not seek to \" + r + \", already seeking at \" + e);\n          var i = nt.getBuffered(t),\n              a = (i.length ? i.start(0) : 0) - r;\n          a > 0 && (a < this.config.maxBufferHole || a < this.config.maxFragLookUpTolerance) && (o.b.log(\"adjusting start position by \" + a + \" to match buffer start\"), r += a, this.startPosition = r), this.log(\"seek to target start position \" + r + \" from current time \" + e), t.currentTime = r;\n        }\n      }, f._getAudioCodec = function (t) {\n        var e = this.config.defaultAudioCodec || t.audioCodec;\n        return this.audioCodecSwap && e && (this.log(\"Swapping audio codec\"), e = -1 !== e.indexOf(\"mp4a.40.5\") ? \"mp4a.40.2\" : \"mp4a.40.5\"), e;\n      }, f._loadBitrateTestFrag = function (t) {\n        var e = this;\n\n        this._doFragLoad(t).then(function (r) {\n          var i = e.hls;\n\n          if (r && !i.nextLoadLevel && !e.fragContextChanged(t)) {\n            e.fragLoadError = 0, e.state = _t, e.startFragRequested = !1, e.bitrateTest = !1;\n            var a = t.stats;\n            a.parsing.start = a.parsing.end = a.buffering.start = a.buffering.end = self.performance.now(), i.trigger(n.a.FRAG_LOADED, r);\n          }\n        });\n      }, f._handleTransmuxComplete = function (t) {\n        var e,\n            r = \"main\",\n            i = this.hls,\n            s = t.remuxResult,\n            o = t.chunkMeta,\n            l = this.getCurrentContext(o);\n        if (!l) return this.warn(\"The loading context changed while buffering fragment \" + o.sn + \" of level \" + o.level + \". This chunk will not be buffered.\"), void this.resetLiveStartWhenNotLoaded(o.level);\n        var d = l.frag,\n            h = l.part,\n            f = l.level,\n            c = s.video,\n            v = s.text,\n            g = s.id3,\n            p = s.initSegment,\n            m = this.altAudio ? void 0 : s.audio;\n\n        if (!this.fragContextChanged(d)) {\n          if (this.state = wt, p) {\n            p.tracks && (this._bufferInitSegment(f, p.tracks, d, o), i.trigger(n.a.FRAG_PARSING_INIT_SEGMENT, {\n              frag: d,\n              id: r,\n              tracks: p.tracks\n            }));\n            var y = p.initPTS,\n                b = p.timescale;\n            Object(a.a)(y) && (this.initPTS[d.cc] = y, i.trigger(n.a.INIT_PTS_FOUND, {\n              frag: d,\n              id: r,\n              initPTS: y,\n              timescale: b\n            }));\n          }\n\n          if (c && !1 !== s.independent) {\n            if (f.details) {\n              var T = c.startPTS,\n                  E = c.endPTS,\n                  S = c.startDTS,\n                  L = c.endDTS;\n              if (h) h.elementaryStreams[c.type] = {\n                startPTS: T,\n                endPTS: E,\n                startDTS: S,\n                endDTS: L\n              };else if (c.firstKeyFrame && c.independent && (this.couldBacktrack = !0), c.dropped && c.independent) {\n                if (this.getLoadPosition() + this.config.maxBufferHole < T) return void this.backtrack(d);\n                d.setElementaryStreamInfo(c.type, d.start, E, d.start, L, !0);\n              }\n              d.setElementaryStreamInfo(c.type, T, E, S, L), this.bufferFragmentData(c, d, h, o);\n            }\n          } else if (!1 === s.independent) return void this.backtrack(d);\n\n          if (m) {\n            var A = m.startPTS,\n                R = m.endPTS,\n                D = m.startDTS,\n                _ = m.endDTS;\n            h && (h.elementaryStreams[u.a.AUDIO] = {\n              startPTS: A,\n              endPTS: R,\n              startDTS: D,\n              endDTS: _\n            }), d.setElementaryStreamInfo(u.a.AUDIO, A, R, D, _), this.bufferFragmentData(m, d, h, o);\n          }\n\n          if (null != g && null !== (e = g.samples) && void 0 !== e && e.length) {\n            var k = {\n              frag: d,\n              id: r,\n              samples: g.samples\n            };\n            i.trigger(n.a.FRAG_PARSING_METADATA, k);\n          }\n\n          if (v) {\n            var x = {\n              frag: d,\n              id: r,\n              samples: v.samples\n            };\n            i.trigger(n.a.FRAG_PARSING_USERDATA, x);\n          }\n        }\n      }, f._bufferInitSegment = function (t, e, r, i) {\n        var a = this;\n\n        if (this.state === wt) {\n          this.audioOnly = !!e.audio && !e.video, this.altAudio && !this.audioOnly && delete e.audio;\n          var s = e.audio,\n              o = e.video,\n              l = e.audiovideo;\n\n          if (s) {\n            var u = t.audioCodec,\n                d = navigator.userAgent.toLowerCase();\n            this.audioCodecSwitch && (u && (u = -1 !== u.indexOf(\"mp4a.40.5\") ? \"mp4a.40.2\" : \"mp4a.40.5\"), 1 !== s.metadata.channelCount && -1 === d.indexOf(\"firefox\") && (u = \"mp4a.40.5\")), -1 !== d.indexOf(\"android\") && \"audio/mpeg\" !== s.container && (u = \"mp4a.40.2\", this.log(\"Android: force audio codec to \" + u)), t.audioCodec && t.audioCodec !== u && this.log('Swapping manifest audio codec \"' + t.audioCodec + '\" for \"' + u + '\"'), s.levelCodec = u, s.id = \"main\", this.log(\"Init audio buffer, container:\" + s.container + \", codecs[selected/level/parsed]=[\" + (u || \"\") + \"/\" + (t.audioCodec || \"\") + \"/\" + s.codec + \"]\");\n          }\n\n          o && (o.levelCodec = t.videoCodec, o.id = \"main\", this.log(\"Init video buffer, container:\" + o.container + \", codecs[level/parsed]=[\" + (t.videoCodec || \"\") + \"/\" + o.codec + \"]\")), l && this.log(\"Init audiovideo buffer, container:\" + l.container + \", codecs[level/parsed]=[\" + (t.attrs.CODECS || \"\") + \"/\" + l.codec + \"]\"), this.hls.trigger(n.a.BUFFER_CODECS, e), Object.keys(e).forEach(function (t) {\n            var s = e[t].initSegment;\n            null != s && s.byteLength && a.hls.trigger(n.a.BUFFER_APPENDING, {\n              type: t,\n              data: s,\n              frag: r,\n              part: null,\n              chunkMeta: i,\n              parent: r.type\n            });\n          }), this.tick();\n        }\n      }, f.backtrack = function (t) {\n        this.couldBacktrack = !0, this.resetTransmuxer(), this.flushBufferGap(t);\n        var e = this.fragmentTracker.backtrack(t);\n        this.fragPrevious = null, this.nextLoadPosition = t.start, e ? this.resetFragmentLoading(t) : this.state = It;\n      }, f.checkFragmentChanged = function () {\n        var t = this.media,\n            e = null;\n\n        if (t && t.readyState > 1 && !1 === t.seeking) {\n          var r = t.currentTime;\n\n          if (nt.isBuffered(t, r) ? e = this.getAppendedFrag(r) : nt.isBuffered(t, r + .1) && (e = this.getAppendedFrag(r + .1)), e) {\n            var i = this.fragPlaying,\n                a = e.level;\n            i && e.sn === i.sn && i.level === a && e.urlId === i.urlId || (this.hls.trigger(n.a.FRAG_CHANGED, {\n              frag: e\n            }), i && i.level === a || this.hls.trigger(n.a.LEVEL_SWITCHED, {\n              level: a\n            }), this.fragPlaying = e);\n          }\n        }\n      }, l = i, (d = [{\n        key: \"nextLevel\",\n        get: function () {\n          var t = this.nextBufferedFrag;\n          return t ? t.level : -1;\n        }\n      }, {\n        key: \"currentLevel\",\n        get: function () {\n          var t = this.media;\n\n          if (t) {\n            var e = this.getAppendedFrag(t.currentTime);\n            if (e) return e.level;\n          }\n\n          return -1;\n        }\n      }, {\n        key: \"nextBufferedFrag\",\n        get: function () {\n          var t = this.media;\n\n          if (t) {\n            var e = this.getAppendedFrag(t.currentTime);\n            return this.followingBufferedFrag(e);\n          }\n\n          return null;\n        }\n      }, {\n        key: \"forceStartLoad\",\n        get: function () {\n          return this._forceStartLoad;\n        }\n      }]) && Yt(l.prototype, d), h && Yt(l, h), i;\n    }(Nt),\n        zt = function () {\n      function t(t, e, r) {\n        void 0 === e && (e = 0), void 0 === r && (r = 0), this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = t, this.alpha_ = t ? Math.exp(Math.log(.5) / t) : 0, this.estimate_ = e, this.totalWeight_ = r;\n      }\n\n      var e = t.prototype;\n      return e.sample = function (t, e) {\n        var r = Math.pow(this.alpha_, t);\n        this.estimate_ = e * (1 - r) + r * this.estimate_, this.totalWeight_ += t;\n      }, e.getTotalWeight = function () {\n        return this.totalWeight_;\n      }, e.getEstimate = function () {\n        if (this.alpha_) {\n          var t = 1 - Math.pow(this.alpha_, this.totalWeight_);\n          if (t) return this.estimate_ / t;\n        }\n\n        return this.estimate_;\n      }, t;\n    }(),\n        Qt = function () {\n      function t(t, e, r) {\n        this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultEstimate_ = r, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new zt(t), this.fast_ = new zt(e);\n      }\n\n      var e = t.prototype;\n      return e.update = function (t, e) {\n        var r = this.slow_,\n            i = this.fast_;\n        this.slow_.halfLife !== t && (this.slow_ = new zt(t, r.getEstimate(), r.getTotalWeight())), this.fast_.halfLife !== e && (this.fast_ = new zt(e, i.getEstimate(), i.getTotalWeight()));\n      }, e.sample = function (t, e) {\n        var r = (t = Math.max(t, this.minDelayMs_)) / 1e3,\n            i = 8 * e / r;\n        this.fast_.sample(r, i), this.slow_.sample(r, i);\n      }, e.canEstimate = function () {\n        var t = this.fast_;\n        return t && t.getTotalWeight() >= this.minWeight_;\n      }, e.getEstimate = function () {\n        return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_;\n      }, e.destroy = function () {}, t;\n    }();\n\n    function $t(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    var Zt = function () {\n      function t(t) {\n        this.hls = void 0, this.lastLoadedFragLevel = 0, this._nextAutoLevel = -1, this.timer = void 0, this.onCheck = this._abandonRulesCheck.bind(this), this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0, this.hls = t;\n        var e = t.config;\n        this.bwEstimator = new Qt(e.abrEwmaSlowVoD, e.abrEwmaFastVoD, e.abrEwmaDefaultEstimate), this.registerListeners();\n      }\n\n      var e,\n          r,\n          i,\n          l = t.prototype;\n      return l.registerListeners = function () {\n        var t = this.hls;\n        t.on(n.a.FRAG_LOADING, this.onFragLoading, this), t.on(n.a.FRAG_LOADED, this.onFragLoaded, this), t.on(n.a.FRAG_BUFFERED, this.onFragBuffered, this), t.on(n.a.LEVEL_LOADED, this.onLevelLoaded, this), t.on(n.a.ERROR, this.onError, this);\n      }, l.unregisterListeners = function () {\n        var t = this.hls;\n        t.off(n.a.FRAG_LOADING, this.onFragLoading, this), t.off(n.a.FRAG_LOADED, this.onFragLoaded, this), t.off(n.a.FRAG_BUFFERED, this.onFragBuffered, this), t.off(n.a.LEVEL_LOADED, this.onLevelLoaded, this), t.off(n.a.ERROR, this.onError, this);\n      }, l.destroy = function () {\n        this.unregisterListeners(), this.clearTimer(), this.hls = this.onCheck = null, this.fragCurrent = this.partCurrent = null;\n      }, l.onFragLoading = function (t, e) {\n        var r,\n            i = e.frag;\n        i.type === _.b.MAIN && (this.timer || (this.fragCurrent = i, this.partCurrent = null != (r = e.part) ? r : null, this.timer = self.setInterval(this.onCheck, 100)));\n      }, l.onLevelLoaded = function (t, e) {\n        var r = this.hls.config;\n        e.details.live ? this.bwEstimator.update(r.abrEwmaSlowLive, r.abrEwmaFastLive) : this.bwEstimator.update(r.abrEwmaSlowVoD, r.abrEwmaFastVoD);\n      }, l._abandonRulesCheck = function () {\n        var t = this.fragCurrent,\n            e = this.partCurrent,\n            r = this.hls,\n            i = r.autoLevelEnabled,\n            s = r.config,\n            l = r.media;\n\n        if (t && l) {\n          var u = e ? e.stats : t.stats,\n              d = e ? e.duration : t.duration;\n          if (u.aborted) return o.b.warn(\"frag loader destroy or aborted, disarm abandonRules\"), this.clearTimer(), void (this._nextAutoLevel = -1);\n\n          if (i && !l.paused && l.playbackRate && l.readyState) {\n            var h = performance.now() - u.loading.start,\n                f = Math.abs(l.playbackRate);\n\n            if (!(h <= 500 * d / f)) {\n              var c = r.levels,\n                  v = r.minAutoLevel,\n                  g = c[t.level],\n                  p = u.total || Math.max(u.loaded, Math.round(d * g.maxBitrate / 8)),\n                  m = Math.max(1, u.bwEstimate ? u.bwEstimate / 8 : 1e3 * u.loaded / h),\n                  y = (p - u.loaded) / m,\n                  b = l.currentTime,\n                  T = (nt.bufferInfo(l, b, s.maxBufferHole).end - b) / f;\n\n              if (!(T >= 2 * d / f || y <= T)) {\n                var E,\n                    S = Number.POSITIVE_INFINITY;\n\n                for (E = t.level - 1; E > v; E--) {\n                  if ((S = d * c[E].maxBitrate / (6.4 * m)) < T) break;\n                }\n\n                if (!(S >= y)) {\n                  var L = this.bwEstimator.getEstimate();\n                  o.b.warn(\"Fragment \" + t.sn + (e ? \" part \" + e.index : \"\") + \" of level \" + t.level + \" is loading too slowly and will cause an underbuffer; aborting and switching to level \" + E + \"\\n      Current BW estimate: \" + (Object(a.a)(L) ? (L / 1024).toFixed(3) : \"Unknown\") + \" Kb/s\\n      Estimated load time for current fragment: \" + y.toFixed(3) + \" s\\n      Estimated load time for the next fragment: \" + S.toFixed(3) + \" s\\n      Time to underbuffer: \" + T.toFixed(3) + \" s\"), r.nextLoadLevel = E, this.bwEstimator.sample(h, u.loaded), this.clearTimer(), t.loader && (this.fragCurrent = this.partCurrent = null, t.loader.abort()), r.trigger(n.a.FRAG_LOAD_EMERGENCY_ABORTED, {\n                    frag: t,\n                    part: e,\n                    stats: u\n                  });\n                }\n              }\n            }\n          }\n        }\n      }, l.onFragLoaded = function (t, e) {\n        var r = e.frag,\n            i = e.part;\n\n        if (r.type === _.b.MAIN && Object(a.a)(r.sn)) {\n          var s = i ? i.stats : r.stats,\n              o = i ? i.duration : r.duration;\n\n          if (this.clearTimer(), this.lastLoadedFragLevel = r.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate) {\n            var l = this.hls.levels[r.level],\n                u = (l.loaded ? l.loaded.bytes : 0) + s.loaded,\n                d = (l.loaded ? l.loaded.duration : 0) + o;\n            l.loaded = {\n              bytes: u,\n              duration: d\n            }, l.realBitrate = Math.round(8 * u / d);\n          }\n\n          if (r.bitrateTest) {\n            var h = {\n              stats: s,\n              frag: r,\n              part: i,\n              id: r.type\n            };\n            this.onFragBuffered(n.a.FRAG_BUFFERED, h), r.bitrateTest = !1;\n          }\n        }\n      }, l.onFragBuffered = function (t, e) {\n        var r = e.frag,\n            i = e.part,\n            a = i ? i.stats : r.stats;\n\n        if (!a.aborted && r.type === _.b.MAIN && \"initSegment\" !== r.sn) {\n          var n = a.parsing.end - a.loading.start;\n          this.bwEstimator.sample(n, a.loaded), a.bwEstimate = this.bwEstimator.getEstimate(), r.bitrateTest ? this.bitrateTestDelay = n / 1e3 : this.bitrateTestDelay = 0;\n        }\n      }, l.onError = function (t, e) {\n        switch (e.details) {\n          case s.a.FRAG_LOAD_ERROR:\n          case s.a.FRAG_LOAD_TIMEOUT:\n            this.clearTimer();\n        }\n      }, l.clearTimer = function () {\n        self.clearInterval(this.timer), this.timer = void 0;\n      }, l.getNextABRAutoLevel = function () {\n        var t = this.fragCurrent,\n            e = this.partCurrent,\n            r = this.hls,\n            i = r.maxAutoLevel,\n            a = r.config,\n            n = r.minAutoLevel,\n            s = r.media,\n            l = e ? e.duration : t ? t.duration : 0,\n            u = s ? s.currentTime : 0,\n            d = s && 0 !== s.playbackRate ? Math.abs(s.playbackRate) : 1,\n            h = this.bwEstimator ? this.bwEstimator.getEstimate() : a.abrEwmaDefaultEstimate,\n            f = (nt.bufferInfo(s, u, a.maxBufferHole).end - u) / d,\n            c = this.findBestLevel(h, n, i, f, a.abrBandWidthFactor, a.abrBandWidthUpFactor);\n        if (c >= 0) return c;\n        o.b.trace((f ? \"rebuffering expected\" : \"buffer is empty\") + \", finding optimal quality level\");\n        var v = l ? Math.min(l, a.maxStarvationDelay) : a.maxStarvationDelay,\n            g = a.abrBandWidthFactor,\n            p = a.abrBandWidthUpFactor;\n\n        if (!f) {\n          var m = this.bitrateTestDelay;\n          if (m) v = (l ? Math.min(l, a.maxLoadingDelay) : a.maxLoadingDelay) - m, o.b.trace(\"bitrate test took \" + Math.round(1e3 * m) + \"ms, set first fragment max fetchDuration to \" + Math.round(1e3 * v) + \" ms\"), g = p = 1;\n        }\n\n        return c = this.findBestLevel(h, n, i, f + v, g, p), Math.max(c, 0);\n      }, l.findBestLevel = function (t, e, r, i, a, n) {\n        for (var s, l = this.fragCurrent, u = this.partCurrent, d = this.lastLoadedFragLevel, h = this.hls.levels, f = h[d], c = !(null == f || null === (s = f.details) || void 0 === s || !s.live), v = null == f ? void 0 : f.codecSet, g = u ? u.duration : l ? l.duration : 0, p = r; p >= e; p--) {\n          var m = h[p];\n\n          if (m && (!v || m.codecSet === v)) {\n            var y = m.details,\n                b = (u ? null == y ? void 0 : y.partTarget : null == y ? void 0 : y.averagetargetduration) || g,\n                T = void 0;\n            T = p <= d ? a * t : n * t;\n            var E = h[p].maxBitrate,\n                S = E * b / T;\n            if (o.b.trace(\"level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: \" + p + \"/\" + Math.round(T) + \"/\" + E + \"/\" + b + \"/\" + i + \"/\" + S), T > E && (!S || c && !this.bitrateTestDelay || S < i)) return p;\n          }\n        }\n\n        return -1;\n      }, e = t, (r = [{\n        key: \"nextAutoLevel\",\n        get: function () {\n          var t = this._nextAutoLevel,\n              e = this.bwEstimator;\n          if (!(-1 === t || e && e.canEstimate())) return t;\n          var r = this.getNextABRAutoLevel();\n          return -1 !== t && (r = Math.min(t, r)), r;\n        },\n        set: function (t) {\n          this._nextAutoLevel = t;\n        }\n      }]) && $t(e.prototype, r), i && $t(e, i), t;\n    }(),\n        Jt = r(10),\n        te = r.n(Jt),\n        ee = function () {\n      function t(t) {\n        this.buffers = void 0, this.queues = {\n          video: [],\n          audio: [],\n          audiovideo: []\n        }, this.buffers = t;\n      }\n\n      var e = t.prototype;\n      return e.append = function (t, e) {\n        var r = this.queues[e];\n        r.push(t), 1 === r.length && this.buffers[e] && this.executeNext(e);\n      }, e.insertAbort = function (t, e) {\n        this.queues[e].unshift(t), this.executeNext(e);\n      }, e.appendBlocker = function (t) {\n        var e,\n            r = new Promise(function (t) {\n          e = t;\n        }),\n            i = {\n          execute: e,\n          onStart: function () {},\n          onComplete: function () {},\n          onError: function () {}\n        };\n        return this.append(i, t), r;\n      }, e.executeNext = function (t) {\n        var e = this.buffers,\n            r = this.queues,\n            i = e[t],\n            a = r[t];\n\n        if (a.length) {\n          var n = a[0];\n\n          try {\n            n.execute();\n          } catch (e) {\n            o.b.warn(\"[buffer-operation-queue]: Unhandled exception executing the current operation\"), n.onError(e), i && i.updating || (a.shift(), this.executeNext(t));\n          }\n        }\n      }, e.shiftAndExecuteNext = function (t) {\n        this.queues[t].shift(), this.executeNext(t);\n      }, e.current = function (t) {\n        return this.queues[t][0];\n      }, t;\n    }(),\n        re = Bt(),\n        ie = /([ha]vc.)(?:\\.[^.,]+)+/,\n        ae = function () {\n      function t(t) {\n        var e = this;\n        this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.appendError = 0, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this._onMediaSourceOpen = function () {\n          var t = e.hls,\n              r = e.media,\n              i = e.mediaSource;\n          o.b.log(\"[buffer-controller]: Media source opened\"), r && (e.updateMediaElementDuration(), t.trigger(n.a.MEDIA_ATTACHED, {\n            media: r\n          })), i && i.removeEventListener(\"sourceopen\", e._onMediaSourceOpen), e.checkPendingTracks();\n        }, this._onMediaSourceClose = function () {\n          o.b.log(\"[buffer-controller]: Media source closed\");\n        }, this._onMediaSourceEnded = function () {\n          o.b.log(\"[buffer-controller]: Media source ended\");\n        }, this.hls = t, this._initSourceBuffer(), this.registerListeners();\n      }\n\n      var e = t.prototype;\n      return e.hasSourceTypes = function () {\n        return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;\n      }, e.destroy = function () {\n        this.unregisterListeners(), this.details = null;\n      }, e.registerListeners = function () {\n        var t = this.hls;\n        t.on(n.a.MEDIA_ATTACHING, this.onMediaAttaching, this), t.on(n.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(n.a.MANIFEST_PARSED, this.onManifestParsed, this), t.on(n.a.BUFFER_RESET, this.onBufferReset, this), t.on(n.a.BUFFER_APPENDING, this.onBufferAppending, this), t.on(n.a.BUFFER_CODECS, this.onBufferCodecs, this), t.on(n.a.BUFFER_EOS, this.onBufferEos, this), t.on(n.a.BUFFER_FLUSHING, this.onBufferFlushing, this), t.on(n.a.LEVEL_UPDATED, this.onLevelUpdated, this), t.on(n.a.FRAG_PARSED, this.onFragParsed, this), t.on(n.a.FRAG_CHANGED, this.onFragChanged, this);\n      }, e.unregisterListeners = function () {\n        var t = this.hls;\n        t.off(n.a.MEDIA_ATTACHING, this.onMediaAttaching, this), t.off(n.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(n.a.MANIFEST_PARSED, this.onManifestParsed, this), t.off(n.a.BUFFER_RESET, this.onBufferReset, this), t.off(n.a.BUFFER_APPENDING, this.onBufferAppending, this), t.off(n.a.BUFFER_CODECS, this.onBufferCodecs, this), t.off(n.a.BUFFER_EOS, this.onBufferEos, this), t.off(n.a.BUFFER_FLUSHING, this.onBufferFlushing, this), t.off(n.a.LEVEL_UPDATED, this.onLevelUpdated, this), t.off(n.a.FRAG_PARSED, this.onFragParsed, this), t.off(n.a.FRAG_CHANGED, this.onFragChanged, this);\n      }, e._initSourceBuffer = function () {\n        this.sourceBuffer = {}, this.operationQueue = new ee(this.sourceBuffer), this.listeners = {\n          audio: [],\n          video: [],\n          audiovideo: []\n        };\n      }, e.onManifestParsed = function (t, e) {\n        var r = 2;\n        (e.audio && !e.video || !e.altAudio) && (r = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = r, this.details = null, o.b.log(this.bufferCodecEventsExpected + \" bufferCodec event(s) expected\");\n      }, e.onMediaAttaching = function (t, e) {\n        var r = this.media = e.media;\n\n        if (r && re) {\n          var i = this.mediaSource = new re();\n          i.addEventListener(\"sourceopen\", this._onMediaSourceOpen), i.addEventListener(\"sourceended\", this._onMediaSourceEnded), i.addEventListener(\"sourceclose\", this._onMediaSourceClose), r.src = self.URL.createObjectURL(i), this._objectUrl = r.src;\n        }\n      }, e.onMediaDetaching = function () {\n        var t = this.media,\n            e = this.mediaSource,\n            r = this._objectUrl;\n\n        if (e) {\n          if (o.b.log(\"[buffer-controller]: media source detaching\"), \"open\" === e.readyState) try {\n            e.endOfStream();\n          } catch (t) {\n            o.b.warn(\"[buffer-controller]: onMediaDetaching: \" + t.message + \" while calling endOfStream\");\n          }\n          this.onBufferReset(), e.removeEventListener(\"sourceopen\", this._onMediaSourceOpen), e.removeEventListener(\"sourceended\", this._onMediaSourceEnded), e.removeEventListener(\"sourceclose\", this._onMediaSourceClose), t && (r && self.URL.revokeObjectURL(r), t.src === r ? (t.removeAttribute(\"src\"), t.load()) : o.b.warn(\"[buffer-controller]: media.src was changed by a third party - skip cleanup\")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {};\n        }\n\n        this.hls.trigger(n.a.MEDIA_DETACHED, void 0);\n      }, e.onBufferReset = function () {\n        var t = this;\n        this.getSourceBufferTypes().forEach(function (e) {\n          var r = t.sourceBuffer[e];\n\n          try {\n            r && (t.removeBufferListeners(e), t.mediaSource && t.mediaSource.removeSourceBuffer(r), t.sourceBuffer[e] = void 0);\n          } catch (t) {\n            o.b.warn(\"[buffer-controller]: Failed to reset the \" + e + \" buffer\", t);\n          }\n        }), this._initSourceBuffer();\n      }, e.onBufferCodecs = function (t, e) {\n        var r = this,\n            i = this.getSourceBufferTypes().length;\n        Object.keys(e).forEach(function (t) {\n          if (i) {\n            var a = r.tracks[t];\n\n            if (a && \"function\" == typeof a.buffer.changeType) {\n              var n = e[t],\n                  s = n.codec,\n                  o = n.levelCodec,\n                  l = n.container;\n\n              if ((a.levelCodec || a.codec).replace(ie, \"$1\") !== (o || s).replace(ie, \"$1\")) {\n                var u = l + \";codecs=\" + (o || s);\n                r.appendChangeType(t, u);\n              }\n            }\n          } else r.pendingTracks[t] = e[t];\n        }), i || (this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0), this.mediaSource && \"open\" === this.mediaSource.readyState && this.checkPendingTracks());\n      }, e.appendChangeType = function (t, e) {\n        var r = this,\n            i = this.operationQueue,\n            a = {\n          execute: function () {\n            var a = r.sourceBuffer[t];\n            a && (o.b.log(\"[buffer-controller]: changing \" + t + \" sourceBuffer type to \" + e), a.changeType(e)), i.shiftAndExecuteNext(t);\n          },\n          onStart: function () {},\n          onComplete: function () {},\n          onError: function (e) {\n            o.b.warn(\"[buffer-controller]: Failed to change \" + t + \" SourceBuffer type\", e);\n          }\n        };\n        i.append(a, t);\n      }, e.onBufferAppending = function (t, e) {\n        var r = this,\n            i = this.hls,\n            a = this.operationQueue,\n            l = this.tracks,\n            u = e.data,\n            d = e.type,\n            h = e.frag,\n            f = e.part,\n            c = e.chunkMeta,\n            v = c.buffering[d],\n            g = self.performance.now();\n        v.start = g;\n        var p = h.stats.buffering,\n            m = f ? f.stats.buffering : null;\n        0 === p.start && (p.start = g), m && 0 === m.start && (m.start = g);\n        var y = l.audio,\n            b = \"audio\" === d && 1 === c.id && \"audio/mpeg\" === (null == y ? void 0 : y.container),\n            T = {\n          execute: function () {\n            if (v.executeStart = self.performance.now(), b) {\n              var t = r.sourceBuffer[d];\n\n              if (t) {\n                var e = h.start - t.timestampOffset;\n                Math.abs(e) >= .1 && (o.b.log(\"[buffer-controller]: Updating audio SourceBuffer timestampOffset to \" + h.start + \" (delta: \" + e + \") sn: \" + h.sn + \")\"), t.timestampOffset = h.start);\n              }\n            }\n\n            r.appendExecutor(u, d);\n          },\n          onStart: function () {},\n          onComplete: function () {\n            var t = self.performance.now();\n            v.executeEnd = v.end = t, 0 === p.first && (p.first = t), m && 0 === m.first && (m.first = t);\n            var e = r.sourceBuffer,\n                i = {};\n\n            for (var a in e) i[a] = nt.getBuffered(e[a]);\n\n            r.appendError = 0, r.hls.trigger(n.a.BUFFER_APPENDED, {\n              type: d,\n              frag: h,\n              part: f,\n              chunkMeta: c,\n              parent: h.type,\n              timeRanges: i\n            });\n          },\n          onError: function (t) {\n            o.b.error(\"[buffer-controller]: Error encountered while trying to append to the \" + d + \" SourceBuffer\", t);\n            var e = {\n              type: s.b.MEDIA_ERROR,\n              parent: h.type,\n              details: s.a.BUFFER_APPEND_ERROR,\n              err: t,\n              fatal: !1\n            };\n            t.code === DOMException.QUOTA_EXCEEDED_ERR ? e.details = s.a.BUFFER_FULL_ERROR : (r.appendError++, e.details = s.a.BUFFER_APPEND_ERROR, r.appendError > i.config.appendErrorMaxRetry && (o.b.error(\"[buffer-controller]: Failed \" + i.config.appendErrorMaxRetry + \" times to append segment in sourceBuffer\"), e.fatal = !0)), i.trigger(n.a.ERROR, e);\n          }\n        };\n        a.append(T, d);\n      }, e.onBufferFlushing = function (t, e) {\n        var r = this,\n            i = this.operationQueue,\n            a = function (t) {\n          return {\n            execute: r.removeExecutor.bind(r, t, e.startOffset, e.endOffset),\n            onStart: function () {},\n            onComplete: function () {\n              r.hls.trigger(n.a.BUFFER_FLUSHED, {\n                type: t\n              });\n            },\n            onError: function (e) {\n              o.b.warn(\"[buffer-controller]: Failed to remove from \" + t + \" SourceBuffer\", e);\n            }\n          };\n        };\n\n        e.type ? i.append(a(e.type), e.type) : this.getSourceBufferTypes().forEach(function (t) {\n          i.append(a(t), t);\n        });\n      }, e.onFragParsed = function (t, e) {\n        var r = this,\n            i = e.frag,\n            a = e.part,\n            s = [],\n            l = a ? a.elementaryStreams : i.elementaryStreams;\n        l[u.a.AUDIOVIDEO] ? s.push(\"audiovideo\") : (l[u.a.AUDIO] && s.push(\"audio\"), l[u.a.VIDEO] && s.push(\"video\"));\n        0 === s.length && o.b.warn(\"Fragments must have at least one ElementaryStreamType set. type: \" + i.type + \" level: \" + i.level + \" sn: \" + i.sn), this.blockBuffers(function () {\n          var t = self.performance.now();\n          i.stats.buffering.end = t, a && (a.stats.buffering.end = t);\n          var e = a ? a.stats : i.stats;\n          r.hls.trigger(n.a.FRAG_BUFFERED, {\n            frag: i,\n            part: a,\n            stats: e,\n            id: i.type\n          });\n        }, s);\n      }, e.onFragChanged = function (t, e) {\n        this.flushBackBuffer();\n      }, e.onBufferEos = function (t, e) {\n        var r = this;\n        this.getSourceBufferTypes().reduce(function (t, i) {\n          var a = r.sourceBuffer[i];\n          return e.type && e.type !== i || a && !a.ended && (a.ended = !0, o.b.log(\"[buffer-controller]: \" + i + \" sourceBuffer now EOS\")), t && !(a && !a.ended);\n        }, !0) && this.blockBuffers(function () {\n          var t = r.mediaSource;\n          t && \"open\" === t.readyState && t.endOfStream();\n        });\n      }, e.onLevelUpdated = function (t, e) {\n        var r = e.details;\n        r.fragments.length && (this.details = r, this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration());\n      }, e.flushBackBuffer = function () {\n        var t = this.hls,\n            e = this.details,\n            r = this.media,\n            i = this.sourceBuffer;\n\n        if (r && null !== e) {\n          var s = this.getSourceBufferTypes();\n\n          if (s.length) {\n            var o = e.live && null !== t.config.liveBackBufferLength ? t.config.liveBackBufferLength : t.config.backBufferLength;\n\n            if (Object(a.a)(o) && !(o < 0)) {\n              var l = r.currentTime,\n                  u = e.levelTargetDuration,\n                  d = Math.max(o, u),\n                  h = Math.floor(l / u) * u - d;\n              s.forEach(function (r) {\n                var a = i[r];\n\n                if (a) {\n                  var s = nt.getBuffered(a);\n                  s.length > 0 && h > s.start(0) && (t.trigger(n.a.BACK_BUFFER_REACHED, {\n                    bufferEnd: h\n                  }), e.live && t.trigger(n.a.LIVE_BACK_BUFFER_REACHED, {\n                    bufferEnd: h\n                  }), t.trigger(n.a.BUFFER_FLUSHING, {\n                    startOffset: 0,\n                    endOffset: h,\n                    type: r\n                  }));\n                }\n              });\n            }\n          }\n        }\n      }, e.updateMediaElementDuration = function () {\n        if (this.details && this.media && this.mediaSource && \"open\" === this.mediaSource.readyState) {\n          var t = this.details,\n              e = this.hls,\n              r = this.media,\n              i = this.mediaSource,\n              n = t.fragments[0].start + t.totalduration,\n              s = r.duration,\n              l = Object(a.a)(i.duration) ? i.duration : 0;\n          t.live && e.config.liveDurationInfinity ? (o.b.log(\"[buffer-controller]: Media Source duration is set to Infinity\"), i.duration = 1 / 0, this.updateSeekableRange(t)) : (n > l && n > s || !Object(a.a)(s)) && (o.b.log(\"[buffer-controller]: Updating Media Source duration to \" + n.toFixed(3)), i.duration = n);\n        }\n      }, e.updateSeekableRange = function (t) {\n        var e = this.mediaSource,\n            r = t.fragments;\n\n        if (r.length && t.live && null != e && e.setLiveSeekableRange) {\n          var i = Math.max(0, r[0].start),\n              a = Math.max(i, i + t.totalduration);\n          e.setLiveSeekableRange(i, a);\n        }\n      }, e.checkPendingTracks = function () {\n        var t = this.bufferCodecEventsExpected,\n            e = this.operationQueue,\n            r = this.pendingTracks,\n            i = Object.keys(r).length;\n\n        if (i && !t || 2 === i) {\n          this.createSourceBuffers(r), this.pendingTracks = {};\n          var a = this.getSourceBufferTypes();\n          if (0 === a.length) return void this.hls.trigger(n.a.ERROR, {\n            type: s.b.MEDIA_ERROR,\n            details: s.a.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n            fatal: !0,\n            reason: \"could not create source buffer for media codec(s)\"\n          });\n          a.forEach(function (t) {\n            e.executeNext(t);\n          });\n        }\n      }, e.createSourceBuffers = function (t) {\n        var e = this.sourceBuffer,\n            r = this.mediaSource;\n        if (!r) throw Error(\"createSourceBuffers called when mediaSource was null\");\n        var i = 0;\n\n        for (var a in t) if (!e[a]) {\n          var l = t[a];\n          if (!l) throw Error(\"source buffer exists for track \" + a + \", however track does not\");\n          var u = l.levelCodec || l.codec,\n              d = l.container + \";codecs=\" + u;\n          o.b.log(\"[buffer-controller]: creating sourceBuffer(\" + d + \")\");\n\n          try {\n            var h = e[a] = r.addSourceBuffer(d),\n                f = a;\n            this.addBufferListener(f, \"updatestart\", this._onSBUpdateStart), this.addBufferListener(f, \"updateend\", this._onSBUpdateEnd), this.addBufferListener(f, \"error\", this._onSBUpdateError), this.tracks[a] = {\n              buffer: h,\n              codec: u,\n              container: l.container,\n              levelCodec: l.levelCodec,\n              id: l.id\n            }, i++;\n          } catch (t) {\n            o.b.error(\"[buffer-controller]: error while trying to add sourceBuffer: \" + t.message), this.hls.trigger(n.a.ERROR, {\n              type: s.b.MEDIA_ERROR,\n              details: s.a.BUFFER_ADD_CODEC_ERROR,\n              fatal: !1,\n              error: t,\n              mimeType: d\n            });\n          }\n        }\n\n        i && this.hls.trigger(n.a.BUFFER_CREATED, {\n          tracks: this.tracks\n        });\n      }, e._onSBUpdateStart = function (t) {\n        this.operationQueue.current(t).onStart();\n      }, e._onSBUpdateEnd = function (t) {\n        var e = this.operationQueue;\n        e.current(t).onComplete(), e.shiftAndExecuteNext(t);\n      }, e._onSBUpdateError = function (t, e) {\n        o.b.error(\"[buffer-controller]: \" + t + \" SourceBuffer error\", e), this.hls.trigger(n.a.ERROR, {\n          type: s.b.MEDIA_ERROR,\n          details: s.a.BUFFER_APPENDING_ERROR,\n          fatal: !1\n        });\n        var r = this.operationQueue.current(t);\n        r && r.onError(e);\n      }, e.removeExecutor = function (t, e, r) {\n        var i = this.media,\n            n = this.mediaSource,\n            s = this.operationQueue,\n            l = this.sourceBuffer[t];\n        if (!i || !n || !l) return o.b.warn(\"[buffer-controller]: Attempting to remove from the \" + t + \" SourceBuffer, but it does not exist\"), void s.shiftAndExecuteNext(t);\n        var u = Object(a.a)(i.duration) ? i.duration : 1 / 0,\n            d = Object(a.a)(n.duration) ? n.duration : 1 / 0,\n            h = Math.max(0, e),\n            f = Math.min(r, u, d);\n        f > h ? (o.b.log(\"[buffer-controller]: Removing [\" + h + \",\" + f + \"] from the \" + t + \" SourceBuffer\"), l.remove(h, f)) : s.shiftAndExecuteNext(t);\n      }, e.appendExecutor = function (t, e) {\n        var r = this.operationQueue,\n            i = this.sourceBuffer[e];\n        if (!i) return o.b.warn(\"[buffer-controller]: Attempting to append to the \" + e + \" SourceBuffer, but it does not exist\"), void r.shiftAndExecuteNext(e);\n        i.ended = !1, i.appendBuffer(t);\n      }, e.blockBuffers = function (t, e) {\n        var r = this;\n        if (void 0 === e && (e = this.getSourceBufferTypes()), !e.length) return o.b.log(\"[buffer-controller]: Blocking operation requested, but no SourceBuffers exist\"), void Promise.resolve(t);\n        var i = this.operationQueue,\n            a = e.map(function (t) {\n          return i.appendBlocker(t);\n        });\n        Promise.all(a).then(function () {\n          t(), e.forEach(function (t) {\n            var e = r.sourceBuffer[t];\n            e && e.updating || i.shiftAndExecuteNext(t);\n          });\n        });\n      }, e.getSourceBufferTypes = function () {\n        return Object.keys(this.sourceBuffer);\n      }, e.addBufferListener = function (t, e, r) {\n        var i = this.sourceBuffer[t];\n\n        if (i) {\n          var a = r.bind(this, t);\n          this.listeners[t].push({\n            event: e,\n            listener: a\n          }), i.addEventListener(e, a);\n        }\n      }, e.removeBufferListeners = function (t) {\n        var e = this.sourceBuffer[t];\n        e && this.listeners[t].forEach(function (t) {\n          e.removeEventListener(t.event, t.listener);\n        });\n      }, t;\n    }();\n\n    function ne(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    var se = function () {\n      function t(t) {\n        this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.hls = void 0, this.streamController = void 0, this.clientRect = void 0, this.hls = t, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners();\n      }\n\n      var e,\n          r,\n          i,\n          a = t.prototype;\n      return a.setStreamController = function (t) {\n        this.streamController = t;\n      }, a.destroy = function () {\n        this.unregisterListener(), this.hls.config.capLevelToPlayerSize && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null;\n      }, a.registerListeners = function () {\n        var t = this.hls;\n        t.on(n.a.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), t.on(n.a.MEDIA_ATTACHING, this.onMediaAttaching, this), t.on(n.a.MANIFEST_PARSED, this.onManifestParsed, this), t.on(n.a.BUFFER_CODECS, this.onBufferCodecs, this), t.on(n.a.MEDIA_DETACHING, this.onMediaDetaching, this);\n      }, a.unregisterListener = function () {\n        var t = this.hls;\n        t.off(n.a.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), t.off(n.a.MEDIA_ATTACHING, this.onMediaAttaching, this), t.off(n.a.MANIFEST_PARSED, this.onManifestParsed, this), t.off(n.a.BUFFER_CODECS, this.onBufferCodecs, this), t.off(n.a.MEDIA_DETACHING, this.onMediaDetaching, this);\n      }, a.onFpsDropLevelCapping = function (e, r) {\n        t.isLevelAllowed(r.droppedLevel, this.restrictedLevels) && this.restrictedLevels.push(r.droppedLevel);\n      }, a.onMediaAttaching = function (t, e) {\n        this.media = e.media instanceof HTMLVideoElement ? e.media : null;\n      }, a.onManifestParsed = function (t, e) {\n        var r = this.hls;\n        this.restrictedLevels = [], this.firstLevel = e.firstLevel, r.config.capLevelToPlayerSize && e.video && this.startCapping();\n      }, a.onBufferCodecs = function (t, e) {\n        this.hls.config.capLevelToPlayerSize && e.video && this.startCapping();\n      }, a.onMediaDetaching = function () {\n        this.stopCapping();\n      }, a.detectPlayerSize = function () {\n        if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {\n          var t = this.hls.levels;\n\n          if (t.length) {\n            var e = this.hls;\n            e.autoLevelCapping = this.getMaxLevel(t.length - 1), e.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = e.autoLevelCapping;\n          }\n        }\n      }, a.getMaxLevel = function (e) {\n        var r = this,\n            i = this.hls.levels;\n        if (!i.length) return -1;\n        var a = i.filter(function (i, a) {\n          return t.isLevelAllowed(a, r.restrictedLevels) && a <= e;\n        });\n        return this.clientRect = null, t.getMaxLevelByMediaSize(a, this.mediaWidth, this.mediaHeight);\n      }, a.startCapping = function () {\n        this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.hls.firstLevel = this.getMaxLevel(this.firstLevel), self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize());\n      }, a.stopCapping = function () {\n        this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0);\n      }, a.getDimensions = function () {\n        if (this.clientRect) return this.clientRect;\n        var t = this.media,\n            e = {\n          width: 0,\n          height: 0\n        };\n\n        if (t) {\n          var r = t.getBoundingClientRect();\n          e.width = r.width, e.height = r.height, e.width || e.height || (e.width = r.right - r.left || t.width || 0, e.height = r.bottom - r.top || t.height || 0);\n        }\n\n        return this.clientRect = e, e;\n      }, t.isLevelAllowed = function (t, e) {\n        return void 0 === e && (e = []), -1 === e.indexOf(t);\n      }, t.getMaxLevelByMediaSize = function (t, e, r) {\n        if (!t || !t.length) return -1;\n\n        for (var i, a, n = t.length - 1, s = 0; s < t.length; s += 1) {\n          var o = t[s];\n\n          if ((o.width >= e || o.height >= r) && (i = o, !(a = t[s + 1]) || i.width !== a.width || i.height !== a.height)) {\n            n = s;\n            break;\n          }\n        }\n\n        return n;\n      }, e = t, i = [{\n        key: \"contentScaleFactor\",\n        get: function () {\n          var t = 1;\n\n          try {\n            t = self.devicePixelRatio;\n          } catch (t) {}\n\n          return t;\n        }\n      }], (r = [{\n        key: \"mediaWidth\",\n        get: function () {\n          return this.getDimensions().width * t.contentScaleFactor;\n        }\n      }, {\n        key: \"mediaHeight\",\n        get: function () {\n          return this.getDimensions().height * t.contentScaleFactor;\n        }\n      }]) && ne(e.prototype, r), i && ne(e, i), t;\n    }(),\n        oe = function () {\n      function t(t) {\n        this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = t, this.registerListeners();\n      }\n\n      var e = t.prototype;\n      return e.setStreamController = function (t) {\n        this.streamController = t;\n      }, e.registerListeners = function () {\n        this.hls.on(n.a.MEDIA_ATTACHING, this.onMediaAttaching, this);\n      }, e.unregisterListeners = function () {\n        this.hls.off(n.a.MEDIA_ATTACHING, this.onMediaAttaching);\n      }, e.destroy = function () {\n        this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null;\n      }, e.onMediaAttaching = function (t, e) {\n        var r = this.hls.config;\n\n        if (r.capLevelOnFPSDrop) {\n          var i = e.media instanceof self.HTMLVideoElement ? e.media : null;\n          this.media = i, i && \"function\" == typeof i.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), r.fpsDroppedMonitoringPeriod);\n        }\n      }, e.checkFPS = function (t, e, r) {\n        var i = performance.now();\n\n        if (e) {\n          if (this.lastTime) {\n            var a = i - this.lastTime,\n                s = r - this.lastDroppedFrames,\n                l = e - this.lastDecodedFrames,\n                u = 1e3 * s / a,\n                d = this.hls;\n\n            if (d.trigger(n.a.FPS_DROP, {\n              currentDropped: s,\n              currentDecoded: l,\n              totalDroppedFrames: r\n            }), u > 0 && s > d.config.fpsDroppedMonitoringThreshold * l) {\n              var h = d.currentLevel;\n              o.b.warn(\"drop FPS ratio greater than max allowed value for currentLevel: \" + h), h > 0 && (-1 === d.autoLevelCapping || d.autoLevelCapping >= h) && (h -= 1, d.trigger(n.a.FPS_DROP_LEVEL_CAPPING, {\n                level: h,\n                droppedLevel: d.currentLevel\n              }), d.autoLevelCapping = h, this.streamController.nextLevelSwitch());\n            }\n          }\n\n          this.lastTime = i, this.lastDroppedFrames = r, this.lastDecodedFrames = e;\n        }\n      }, e.checkFPSInterval = function () {\n        var t = this.media;\n        if (t) if (this.isVideoPlaybackQualityAvailable) {\n          var e = t.getVideoPlaybackQuality();\n          this.checkFPS(t, e.totalVideoFrames, e.droppedVideoFrames);\n        } else this.checkFPS(t, t.webkitDecodedFrameCount, t.webkitDroppedFrameCount);\n      }, t;\n    }(),\n        le = r(12),\n        ue = /^age:\\s*[\\d.]+\\s*$/m,\n        de = function () {\n      function t(t) {\n        this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = void 0, this.loader = null, this.stats = void 0, this.xhrSetup = t ? t.xhrSetup : null, this.stats = new le.a(), this.retryDelay = 0;\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null;\n      }, e.abortInternal = function () {\n        var t = this.loader;\n        self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), t && (t.onreadystatechange = null, t.onprogress = null, 4 !== t.readyState && (this.stats.aborted = !0, t.abort()));\n      }, e.abort = function () {\n        var t;\n        this.abortInternal(), null !== (t = this.callbacks) && void 0 !== t && t.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader);\n      }, e.load = function (t, e, r) {\n        if (this.stats.loading.start) throw new Error(\"Loader can only be used once.\");\n        this.stats.loading.start = self.performance.now(), this.context = t, this.config = e, this.callbacks = r, this.retryDelay = e.retryDelay, this.loadInternal();\n      }, e.loadInternal = function () {\n        var t = this.config,\n            e = this.context;\n\n        if (t) {\n          var r = this.loader = new self.XMLHttpRequest(),\n              i = this.stats;\n          i.loading.first = 0, i.loaded = 0;\n          var a = this.xhrSetup;\n\n          try {\n            if (a) try {\n              a(r, e.url);\n            } catch (t) {\n              r.open(\"GET\", e.url, !0), a(r, e.url);\n            }\n            r.readyState || r.open(\"GET\", e.url, !0);\n            var n = this.context.headers;\n            if (n) for (var s in n) r.setRequestHeader(s, n[s]);\n          } catch (t) {\n            return void this.callbacks.onError({\n              code: r.status,\n              text: t.message\n            }, e, r);\n          }\n\n          e.rangeEnd && r.setRequestHeader(\"Range\", \"bytes=\" + e.rangeStart + \"-\" + (e.rangeEnd - 1)), r.onreadystatechange = this.readystatechange.bind(this), r.onprogress = this.loadprogress.bind(this), r.responseType = e.responseType, self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), t.timeout), r.send();\n        }\n      }, e.readystatechange = function () {\n        var t = this.context,\n            e = this.loader,\n            r = this.stats;\n\n        if (t && e) {\n          var i = e.readyState,\n              a = this.config;\n          if (!r.aborted && i >= 2) if (self.clearTimeout(this.requestTimeout), 0 === r.loading.first && (r.loading.first = Math.max(self.performance.now(), r.loading.start)), 4 === i) {\n            e.onreadystatechange = null, e.onprogress = null;\n            var n = e.status;\n\n            if (n >= 200 && n < 300) {\n              var s, l;\n              if (r.loading.end = Math.max(self.performance.now(), r.loading.first), l = \"arraybuffer\" === t.responseType ? (s = e.response).byteLength : (s = e.responseText).length, r.loaded = r.total = l, !this.callbacks) return;\n              var u = this.callbacks.onProgress;\n              if (u && u(r, t, s, e), !this.callbacks) return;\n              var d = {\n                url: e.responseURL,\n                data: s\n              };\n              this.callbacks.onSuccess(d, r, t, e);\n            } else r.retry >= a.maxRetry || n >= 400 && n < 499 ? (o.b.error(n + \" while loading \" + t.url), this.callbacks.onError({\n              code: n,\n              text: e.statusText\n            }, t, e)) : (o.b.warn(n + \" while loading \" + t.url + \", retrying in \" + this.retryDelay + \"...\"), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay), this.retryDelay = Math.min(2 * this.retryDelay, a.maxRetryDelay), r.retry++);\n          } else self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), a.timeout);\n        }\n      }, e.loadtimeout = function () {\n        o.b.warn(\"timeout while loading \" + this.context.url);\n        var t = this.callbacks;\n        t && (this.abortInternal(), t.onTimeout(this.stats, this.context, this.loader));\n      }, e.loadprogress = function (t) {\n        var e = this.stats;\n        e.loaded = t.loaded, t.lengthComputable && (e.total = t.total);\n      }, e.getCacheAge = function () {\n        var t = null;\n\n        if (this.loader && ue.test(this.loader.getAllResponseHeaders())) {\n          var e = this.loader.getResponseHeader(\"age\");\n          t = e ? parseFloat(e) : null;\n        }\n\n        return t;\n      }, t;\n    }(),\n        he = r(16);\n\n    function fe(t) {\n      var e = \"function\" == typeof Map ? new Map() : void 0;\n      return (fe = function (t) {\n        if (null === t || (r = t, -1 === Function.toString.call(r).indexOf(\"[native code]\"))) return t;\n        var r;\n        if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n\n        if (void 0 !== e) {\n          if (e.has(t)) return e.get(t);\n          e.set(t, i);\n        }\n\n        function i() {\n          return ce(t, arguments, pe(this).constructor);\n        }\n\n        return i.prototype = Object.create(t.prototype, {\n          constructor: {\n            value: i,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), ge(i, t);\n      })(t);\n    }\n\n    function ce(t, e, r) {\n      return (ce = ve() ? Reflect.construct : function (t, e, r) {\n        var i = [null];\n        i.push.apply(i, e);\n        var a = new (Function.bind.apply(t, i))();\n        return r && ge(a, r.prototype), a;\n      }).apply(null, arguments);\n    }\n\n    function ve() {\n      if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n      if (Reflect.construct.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }\n\n    function ge(t, e) {\n      return (ge = Object.setPrototypeOf || function (t, e) {\n        return t.__proto__ = e, t;\n      })(t, e);\n    }\n\n    function pe(t) {\n      return (pe = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n        return t.__proto__ || Object.getPrototypeOf(t);\n      })(t);\n    }\n\n    function me() {\n      return (me = Object.assign || function (t) {\n        for (var e = 1; e < arguments.length; e++) {\n          var r = arguments[e];\n\n          for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);\n        }\n\n        return t;\n      }).apply(this, arguments);\n    }\n\n    var ye = function () {\n      function t(t) {\n        this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = void 0, this.response = void 0, this.controller = void 0, this.context = void 0, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = t.fetchSetup || be, this.controller = new self.AbortController(), this.stats = new le.a();\n      }\n\n      var e = t.prototype;\n      return e.destroy = function () {\n        this.loader = this.callbacks = null, this.abortInternal();\n      }, e.abortInternal = function () {\n        var t = this.response;\n        t && t.ok || (this.stats.aborted = !0, this.controller.abort());\n      }, e.abort = function () {\n        var t;\n        this.abortInternal(), null !== (t = this.callbacks) && void 0 !== t && t.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response);\n      }, e.load = function (t, e, r) {\n        var i = this,\n            n = this.stats;\n        if (n.loading.start) throw new Error(\"Loader can only be used once.\");\n        n.loading.start = self.performance.now();\n\n        var s = function (t, e) {\n          var r = {\n            method: \"GET\",\n            mode: \"cors\",\n            credentials: \"same-origin\",\n            signal: e,\n            headers: new self.Headers(me({}, t.headers))\n          };\n          t.rangeEnd && r.headers.set(\"Range\", \"bytes=\" + t.rangeStart + \"-\" + String(t.rangeEnd - 1));\n          return r;\n        }(t, this.controller.signal),\n            o = r.onProgress,\n            l = \"arraybuffer\" === t.responseType,\n            u = l ? \"byteLength\" : \"length\";\n\n        this.context = t, this.config = e, this.callbacks = r, this.request = this.fetchSetup(t, s), self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(function () {\n          i.abortInternal(), r.onTimeout(n, t, i.response);\n        }, e.timeout), self.fetch(this.request).then(function (r) {\n          if (i.response = i.loader = r, !r.ok) {\n            var s = r.status,\n                u = r.statusText;\n            throw new Ee(u || \"fetch, bad network response\", s, r);\n          }\n\n          return n.loading.first = Math.max(self.performance.now(), n.loading.start), n.total = parseInt(r.headers.get(\"Content-Length\") || \"0\"), o && Object(a.a)(e.highWaterMark) ? i.loadProgressively(r, n, t, e.highWaterMark, o) : l ? r.arrayBuffer() : r.text();\n        }).then(function (s) {\n          var l = i.response;\n          self.clearTimeout(i.requestTimeout), n.loading.end = Math.max(self.performance.now(), n.loading.first), n.loaded = n.total = s[u];\n          var d = {\n            url: l.url,\n            data: s\n          };\n          o && !Object(a.a)(e.highWaterMark) && o(n, t, s, l), r.onSuccess(d, n, t, l);\n        }).catch(function (e) {\n          if (self.clearTimeout(i.requestTimeout), !n.aborted) {\n            var a = e.code || 0;\n            r.onError({\n              code: a,\n              text: e.message\n            }, t, e.details);\n          }\n        });\n      }, e.getCacheAge = function () {\n        var t = null;\n\n        if (this.response) {\n          var e = this.response.headers.get(\"age\");\n          t = e ? parseFloat(e) : null;\n        }\n\n        return t;\n      }, e.loadProgressively = function (t, e, r, i, a) {\n        void 0 === i && (i = 0);\n        var n = new he.a(),\n            s = t.body.getReader();\n        return function o() {\n          return s.read().then(function (s) {\n            if (s.done) return n.dataLength && a(e, r, n.flush(), t), Promise.resolve(new ArrayBuffer(0));\n            var l = s.value,\n                u = l.length;\n            return e.loaded += u, u < i || n.dataLength ? (n.push(l), n.dataLength >= i && a(e, r, n.flush(), t)) : a(e, r, l, t), o();\n          }).catch(function () {\n            return Promise.reject();\n          });\n        }();\n      }, t;\n    }();\n\n    function be(t, e) {\n      return new self.Request(t.url, e);\n    }\n\n    var Te,\n        Ee = function (t) {\n      var e, r;\n\n      function i(e, r, i) {\n        var a;\n        return (a = t.call(this, e) || this).code = void 0, a.details = void 0, a.code = r, a.details = i, a;\n      }\n\n      return r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, ge(e, r), i;\n    }(fe(Error)),\n        Se = ye;\n\n    !function (t) {\n      t.WIDEVINE = \"com.widevine.alpha\", t.PLAYREADY = \"com.microsoft.playready\";\n    }(Te || (Te = {}));\n    var Le = \"undefined\" != typeof self && self.navigator && self.navigator.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null;\n\n    function Ae() {\n      return (Ae = Object.assign || function (t) {\n        for (var e = 1; e < arguments.length; e++) {\n          var r = arguments[e];\n\n          for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);\n        }\n\n        return t;\n      }).apply(this, arguments);\n    }\n\n    function Re(t, e) {\n      var r = Object.keys(t);\n\n      if (Object.getOwnPropertySymbols) {\n        var i = Object.getOwnPropertySymbols(t);\n        e && (i = i.filter(function (e) {\n          return Object.getOwnPropertyDescriptor(t, e).enumerable;\n        })), r.push.apply(r, i);\n      }\n\n      return r;\n    }\n\n    function De(t) {\n      for (var e = 1; e < arguments.length; e++) {\n        var r = null != arguments[e] ? arguments[e] : {};\n        e % 2 ? Re(Object(r), !0).forEach(function (e) {\n          _e(t, e, r[e]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Re(Object(r)).forEach(function (e) {\n          Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e));\n        });\n      }\n\n      return t;\n    }\n\n    function _e(t, e, r) {\n      return e in t ? Object.defineProperty(t, e, {\n        value: r,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : t[e] = r, t;\n    }\n\n    var ke = De(De({\n      autoStartLoad: !0,\n      startPosition: -1,\n      defaultAudioCodec: void 0,\n      debug: !1,\n      capLevelOnFPSDrop: !1,\n      capLevelToPlayerSize: !1,\n      initialLiveManifestSize: 1,\n      maxBufferLength: 30,\n      backBufferLength: 1 / 0,\n      maxBufferSize: 6e7,\n      maxBufferHole: .1,\n      highBufferWatchdogPeriod: 2,\n      nudgeOffset: .1,\n      nudgeMaxRetry: 3,\n      maxFragLookUpTolerance: .25,\n      liveSyncDurationCount: 3,\n      liveMaxLatencyDurationCount: 1 / 0,\n      liveSyncDuration: void 0,\n      liveMaxLatencyDuration: void 0,\n      maxLiveSyncPlaybackRate: 1,\n      liveDurationInfinity: !1,\n      liveBackBufferLength: null,\n      maxMaxBufferLength: 600,\n      enableWorker: !0,\n      enableSoftwareAES: !0,\n      manifestLoadingTimeOut: 1e4,\n      manifestLoadingMaxRetry: 1,\n      manifestLoadingRetryDelay: 1e3,\n      manifestLoadingMaxRetryTimeout: 64e3,\n      startLevel: void 0,\n      levelLoadingTimeOut: 1e4,\n      levelLoadingMaxRetry: 4,\n      levelLoadingRetryDelay: 1e3,\n      levelLoadingMaxRetryTimeout: 64e3,\n      fragLoadingTimeOut: 2e4,\n      fragLoadingMaxRetry: 6,\n      fragLoadingRetryDelay: 1e3,\n      fragLoadingMaxRetryTimeout: 64e3,\n      startFragPrefetch: !1,\n      fpsDroppedMonitoringPeriod: 5e3,\n      fpsDroppedMonitoringThreshold: .2,\n      appendErrorMaxRetry: 3,\n      loader: de,\n      fLoader: void 0,\n      pLoader: void 0,\n      xhrSetup: void 0,\n      licenseXhrSetup: void 0,\n      licenseResponseCallback: void 0,\n      abrController: Zt,\n      bufferController: ae,\n      capLevelController: se,\n      fpsController: oe,\n      stretchShortVideoTrack: !1,\n      maxAudioFramesDrift: 1,\n      forceKeyFrameOnDiscontinuity: !0,\n      abrEwmaFastLive: 3,\n      abrEwmaSlowLive: 9,\n      abrEwmaFastVoD: 3,\n      abrEwmaSlowVoD: 9,\n      abrEwmaDefaultEstimate: 5e5,\n      abrBandWidthFactor: .95,\n      abrBandWidthUpFactor: .7,\n      abrMaxWithRealBitrate: !1,\n      maxStarvationDelay: 4,\n      maxLoadingDelay: 4,\n      minAutoBitrate: 0,\n      emeEnabled: !1,\n      widevineLicenseUrl: void 0,\n      drmSystemOptions: {},\n      requestMediaKeySystemAccessFunc: Le,\n      testBandwidth: !0,\n      progressive: !1,\n      lowLatencyMode: !0,\n      cmcd: void 0\n    }, {\n      cueHandler: te.a,\n      enableCEA708Captions: !1,\n      enableWebVTT: !1,\n      enableIMSC1: !1,\n      captionsTextTrack1Label: \"English\",\n      captionsTextTrack1LanguageCode: \"en\",\n      captionsTextTrack2Label: \"Spanish\",\n      captionsTextTrack2LanguageCode: \"es\",\n      captionsTextTrack3Label: \"Unknown CC\",\n      captionsTextTrack3LanguageCode: \"\",\n      captionsTextTrack4Label: \"Unknown CC\",\n      captionsTextTrack4LanguageCode: \"\",\n      renderTextTracksNatively: !0\n    }), {}, {\n      subtitleStreamController: void 0,\n      subtitleTrackController: void 0,\n      timelineController: void 0,\n      audioStreamController: void 0,\n      audioTrackController: void 0,\n      emeController: void 0,\n      cmcdController: void 0\n    });\n\n    function xe(t) {\n      var e = t.loader;\n      e !== Se && e !== de ? (o.b.log(\"[config]: Custom loader detected, cannot enable progressive streaming\"), t.progressive = !1) : function () {\n        if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try {\n          return new self.ReadableStream({}), !0;\n        } catch (t) {}\n        return !1;\n      }() && (t.loader = Se, t.progressive = !0, t.enableSoftwareAES = !0, o.b.log(\"[config]: Progressive streaming enabled, using FetchLoader\"));\n    }\n\n    function Ce(t, e) {\n      for (var r = 0; r < e.length; r++) {\n        var i = e[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    var we = function () {\n      function t(e) {\n        void 0 === e && (e = {}), this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new Ht.EventEmitter(), this._autoLevelCapping = void 0, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null;\n\n        var r = this.config = function (t, e) {\n          if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration)) throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n          if (void 0 !== e.liveMaxLatencyDurationCount && (void 0 === e.liveSyncDurationCount || e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount)) throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n          if (void 0 !== e.liveMaxLatencyDuration && (void 0 === e.liveSyncDuration || e.liveMaxLatencyDuration <= e.liveSyncDuration)) throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n          return Ae({}, t, e);\n        }(t.DefaultConfig, e);\n\n        this.userConfig = e, Object(o.a)(r.debug), this._autoLevelCapping = -1, r.progressive && xe(r);\n        var i = r.abrController,\n            a = r.bufferController,\n            n = r.capLevelController,\n            s = r.fpsController,\n            l = this.abrController = new i(this),\n            u = this.bufferController = new a(this),\n            d = this.capLevelController = new n(this),\n            h = new s(this),\n            f = new x(this),\n            c = new C(this),\n            v = new P(this),\n            g = this.levelController = new J(this),\n            p = new tt(this),\n            m = this.streamController = new qt(this, p);\n        d.setStreamController(m), h.setStreamController(m);\n        var y = [g, m];\n        this.networkControllers = y;\n        var b = [f, c, l, u, d, h, v, p];\n        this.audioTrackController = this.createController(r.audioTrackController, null, y), this.createController(r.audioStreamController, p, y), this.subtitleTrackController = this.createController(r.subtitleTrackController, null, y), this.createController(r.subtitleStreamController, p, y), this.createController(r.timelineController, null, b), this.emeController = this.createController(r.emeController, null, b), this.cmcdController = this.createController(r.cmcdController, null, b), this.latencyController = this.createController(N, null, b), this.coreComponents = b;\n      }\n\n      t.isSupported = function () {\n        return function () {\n          var t = Bt();\n          if (!t) return !1;\n          var e = Ut(),\n              r = t && \"function\" == typeof t.isTypeSupported && t.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"'),\n              i = !e || e.prototype && \"function\" == typeof e.prototype.appendBuffer && \"function\" == typeof e.prototype.remove;\n          return !!r && !!i;\n        }();\n      };\n\n      var e,\n          r,\n          a,\n          l = t.prototype;\n      return l.createController = function (t, e, r) {\n        if (t) {\n          var i = e ? new t(this, e) : new t(this);\n          return r && r.push(i), i;\n        }\n\n        return null;\n      }, l.on = function (t, e, r) {\n        void 0 === r && (r = this), this._emitter.on(t, e, r);\n      }, l.once = function (t, e, r) {\n        void 0 === r && (r = this), this._emitter.once(t, e, r);\n      }, l.removeAllListeners = function (t) {\n        this._emitter.removeAllListeners(t);\n      }, l.off = function (t, e, r, i) {\n        void 0 === r && (r = this), this._emitter.off(t, e, r, i);\n      }, l.listeners = function (t) {\n        return this._emitter.listeners(t);\n      }, l.emit = function (t, e, r) {\n        return this._emitter.emit(t, e, r);\n      }, l.trigger = function (t, e) {\n        if (this.config.debug) return this.emit(t, t, e);\n\n        try {\n          return this.emit(t, t, e);\n        } catch (e) {\n          o.b.error(\"An internal error happened while handling event \" + t + '. Error message: \"' + e.message + '\". Here is a stacktrace:', e), this.trigger(n.a.ERROR, {\n            type: s.b.OTHER_ERROR,\n            details: s.a.INTERNAL_EXCEPTION,\n            fatal: !1,\n            event: t,\n            error: e\n          });\n        }\n\n        return !1;\n      }, l.listenerCount = function (t) {\n        return this._emitter.listenerCount(t);\n      }, l.destroy = function () {\n        o.b.log(\"destroy\"), this.trigger(n.a.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach(function (t) {\n          return t.destroy();\n        }), this.networkControllers.length = 0, this.coreComponents.forEach(function (t) {\n          return t.destroy();\n        }), this.coreComponents.length = 0;\n      }, l.attachMedia = function (t) {\n        o.b.log(\"attachMedia\"), this._media = t, this.trigger(n.a.MEDIA_ATTACHING, {\n          media: t\n        });\n      }, l.detachMedia = function () {\n        o.b.log(\"detachMedia\"), this.trigger(n.a.MEDIA_DETACHING, void 0), this._media = null;\n      }, l.loadSource = function (t) {\n        this.stopLoad();\n        var e = this.media,\n            r = this.url,\n            a = this.url = i.buildAbsoluteURL(self.location.href, t, {\n          alwaysNormalize: !0\n        });\n        o.b.log(\"loadSource:\" + a), e && r && r !== a && this.bufferController.hasSourceTypes() && (this.detachMedia(), this.attachMedia(e)), this.trigger(n.a.MANIFEST_LOADING, {\n          url: t\n        });\n      }, l.startLoad = function (t) {\n        void 0 === t && (t = -1), o.b.log(\"startLoad(\" + t + \")\"), this.networkControllers.forEach(function (e) {\n          e.startLoad(t);\n        });\n      }, l.stopLoad = function () {\n        o.b.log(\"stopLoad\"), this.networkControllers.forEach(function (t) {\n          t.stopLoad();\n        });\n      }, l.swapAudioCodec = function () {\n        o.b.log(\"swapAudioCodec\"), this.streamController.swapAudioCodec();\n      }, l.recoverMediaError = function () {\n        o.b.log(\"recoverMediaError\");\n        var t = this._media;\n        this.detachMedia(), t && this.attachMedia(t);\n      }, l.removeLevel = function (t, e) {\n        void 0 === e && (e = 0), this.levelController.removeLevel(t, e);\n      }, e = t, a = [{\n        key: \"version\",\n        get: function () {\n          return \"1.1.5\";\n        }\n      }, {\n        key: \"Events\",\n        get: function () {\n          return n.a;\n        }\n      }, {\n        key: \"ErrorTypes\",\n        get: function () {\n          return s.b;\n        }\n      }, {\n        key: \"ErrorDetails\",\n        get: function () {\n          return s.a;\n        }\n      }, {\n        key: \"DefaultConfig\",\n        get: function () {\n          return t.defaultConfig ? t.defaultConfig : ke;\n        },\n        set: function (e) {\n          t.defaultConfig = e;\n        }\n      }], (r = [{\n        key: \"levels\",\n        get: function () {\n          var t = this.levelController.levels;\n          return t || [];\n        }\n      }, {\n        key: \"currentLevel\",\n        get: function () {\n          return this.streamController.currentLevel;\n        },\n        set: function (t) {\n          o.b.log(\"set currentLevel:\" + t), this.loadLevel = t, this.abrController.clearTimer(), this.streamController.immediateLevelSwitch();\n        }\n      }, {\n        key: \"nextLevel\",\n        get: function () {\n          return this.streamController.nextLevel;\n        },\n        set: function (t) {\n          o.b.log(\"set nextLevel:\" + t), this.levelController.manualLevel = t, this.streamController.nextLevelSwitch();\n        }\n      }, {\n        key: \"loadLevel\",\n        get: function () {\n          return this.levelController.level;\n        },\n        set: function (t) {\n          o.b.log(\"set loadLevel:\" + t), this.levelController.manualLevel = t;\n        }\n      }, {\n        key: \"nextLoadLevel\",\n        get: function () {\n          return this.levelController.nextLoadLevel;\n        },\n        set: function (t) {\n          this.levelController.nextLoadLevel = t;\n        }\n      }, {\n        key: \"firstLevel\",\n        get: function () {\n          return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n        },\n        set: function (t) {\n          o.b.log(\"set firstLevel:\" + t), this.levelController.firstLevel = t;\n        }\n      }, {\n        key: \"startLevel\",\n        get: function () {\n          return this.levelController.startLevel;\n        },\n        set: function (t) {\n          o.b.log(\"set startLevel:\" + t), -1 !== t && (t = Math.max(t, this.minAutoLevel)), this.levelController.startLevel = t;\n        }\n      }, {\n        key: \"capLevelToPlayerSize\",\n        get: function () {\n          return this.config.capLevelToPlayerSize;\n        },\n        set: function (t) {\n          var e = !!t;\n          e !== this.config.capLevelToPlayerSize && (e ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = e);\n        }\n      }, {\n        key: \"autoLevelCapping\",\n        get: function () {\n          return this._autoLevelCapping;\n        },\n        set: function (t) {\n          this._autoLevelCapping !== t && (o.b.log(\"set autoLevelCapping:\" + t), this._autoLevelCapping = t);\n        }\n      }, {\n        key: \"bandwidthEstimate\",\n        get: function () {\n          var t = this.abrController.bwEstimator;\n          return t ? t.getEstimate() : NaN;\n        }\n      }, {\n        key: \"autoLevelEnabled\",\n        get: function () {\n          return -1 === this.levelController.manualLevel;\n        }\n      }, {\n        key: \"manualLevel\",\n        get: function () {\n          return this.levelController.manualLevel;\n        }\n      }, {\n        key: \"minAutoLevel\",\n        get: function () {\n          var t = this.levels,\n              e = this.config.minAutoBitrate;\n          if (!t) return 0;\n\n          for (var r = t.length, i = 0; i < r; i++) if (t[i].maxBitrate > e) return i;\n\n          return 0;\n        }\n      }, {\n        key: \"maxAutoLevel\",\n        get: function () {\n          var t = this.levels,\n              e = this.autoLevelCapping;\n          return -1 === e && t && t.length ? t.length - 1 : e;\n        }\n      }, {\n        key: \"nextAutoLevel\",\n        get: function () {\n          return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);\n        },\n        set: function (t) {\n          this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, t);\n        }\n      }, {\n        key: \"audioTracks\",\n        get: function () {\n          var t = this.audioTrackController;\n          return t ? t.audioTracks : [];\n        }\n      }, {\n        key: \"audioTrack\",\n        get: function () {\n          var t = this.audioTrackController;\n          return t ? t.audioTrack : -1;\n        },\n        set: function (t) {\n          var e = this.audioTrackController;\n          e && (e.audioTrack = t);\n        }\n      }, {\n        key: \"subtitleTracks\",\n        get: function () {\n          var t = this.subtitleTrackController;\n          return t ? t.subtitleTracks : [];\n        }\n      }, {\n        key: \"subtitleTrack\",\n        get: function () {\n          var t = this.subtitleTrackController;\n          return t ? t.subtitleTrack : -1;\n        },\n        set: function (t) {\n          var e = this.subtitleTrackController;\n          e && (e.subtitleTrack = t);\n        }\n      }, {\n        key: \"media\",\n        get: function () {\n          return this._media;\n        }\n      }, {\n        key: \"subtitleDisplay\",\n        get: function () {\n          var t = this.subtitleTrackController;\n          return !!t && t.subtitleDisplay;\n        },\n        set: function (t) {\n          var e = this.subtitleTrackController;\n          e && (e.subtitleDisplay = t);\n        }\n      }, {\n        key: \"lowLatencyMode\",\n        get: function () {\n          return this.config.lowLatencyMode;\n        },\n        set: function (t) {\n          this.config.lowLatencyMode = t;\n        }\n      }, {\n        key: \"liveSyncPosition\",\n        get: function () {\n          return this.latencyController.liveSyncPosition;\n        }\n      }, {\n        key: \"latency\",\n        get: function () {\n          return this.latencyController.latency;\n        }\n      }, {\n        key: \"maxLatency\",\n        get: function () {\n          return this.latencyController.maxLatency;\n        }\n      }, {\n        key: \"targetLatency\",\n        get: function () {\n          return this.latencyController.targetLatency;\n        }\n      }, {\n        key: \"drift\",\n        get: function () {\n          return this.latencyController.drift;\n        }\n      }, {\n        key: \"forceStartLoad\",\n        get: function () {\n          return this.streamController.forceStartLoad;\n        }\n      }]) && Ce(e.prototype, r), a && Ce(e, a), t;\n    }();\n\n    we.defaultConfig = void 0;\n  }]).default;\n});\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/hls.js/dist/hls.light.min.js?");

/***/ }),

/***/ "./node_modules/sdp/sdp.js":
/*!*********************************!*\
  !*** ./node_modules/sdp/sdp.js ***!
  \*********************************/
/***/ ((module) => {

"use strict";
eval("/* eslint-env node */\n // SDP helpers.\n\nconst SDPUtils = {}; // Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\n\nSDPUtils.generateIdentifier = function () {\n  return Math.random().toString(36).substr(2, 10);\n}; // The RTCP CNAME used by all peerconnections from the same JS.\n\n\nSDPUtils.localCName = SDPUtils.generateIdentifier(); // Splits SDP into lines, dealing with both CRLF and LF.\n\nSDPUtils.splitLines = function (blob) {\n  return blob.trim().split('\\n').map(line => line.trim());\n}; // Splits SDP into sessionpart and mediasections. Ensures CRLF.\n\n\nSDPUtils.splitSections = function (blob) {\n  const parts = blob.split('\\nm=');\n  return parts.map((part, index) => (index > 0 ? 'm=' + part : part).trim() + '\\r\\n');\n}; // Returns the session description.\n\n\nSDPUtils.getDescription = function (blob) {\n  const sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n}; // Returns the individual media sections.\n\n\nSDPUtils.getMediaSections = function (blob) {\n  const sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n}; // Returns lines that start with a certain prefix.\n\n\nSDPUtils.matchPrefix = function (blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);\n}; // Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\n// Input can be prefixed with a=.\n\n\nSDPUtils.parseCandidate = function (line) {\n  let parts; // Parse both variants.\n\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  const candidate = {\n    foundation: parts[0],\n    component: {\n      1: 'rtp',\n      2: 'rtcp'\n    }[parts[1]] || parts[1],\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    address: parts[4],\n    // address is an alias for ip.\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7]\n  };\n\n  for (let i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compatibility.\n\n        candidate.usernameFragment = parts[i + 1];\n        break;\n\n      default:\n        // extension handling, in particular ufrag. Don't overwrite.\n        if (candidate[parts[i]] === undefined) {\n          candidate[parts[i]] = parts[i + 1];\n        }\n\n        break;\n    }\n  }\n\n  return candidate;\n}; // Translates a candidate object into SDP candidate attribute.\n// This does not include the a= prefix!\n\n\nSDPUtils.writeCandidate = function (candidate) {\n  const sdp = [];\n  sdp.push(candidate.foundation);\n  const component = candidate.component;\n\n  if (component === 'rtp') {\n    sdp.push(1);\n  } else if (component === 'rtcp') {\n    sdp.push(2);\n  } else {\n    sdp.push(component);\n  }\n\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.address || candidate.ip);\n  sdp.push(candidate.port);\n  const type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n\n  if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n\n  return 'candidate:' + sdp.join(' ');\n}; // Parses an ice-options line, returns an array of option tags.\n// Sample input:\n// a=ice-options:foo bar\n\n\nSDPUtils.parseIceOptions = function (line) {\n  return line.substr(14).split(' ');\n}; // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\n\n\nSDPUtils.parseRtpMap = function (line) {\n  let parts = line.substr(9).split(' ');\n  const parsed = {\n    payloadType: parseInt(parts.shift(), 10) // was: id\n\n  };\n  parts = parts[0].split('/');\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1; // legacy alias, got renamed back to channels in ORTC.\n\n  parsed.numChannels = parsed.channels;\n  return parsed;\n}; // Generates a rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\n\n\nSDPUtils.writeRtpMap = function (codec) {\n  let pt = codec.payloadType;\n\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n\n  const channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n}; // Parses a extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\n\n\nSDPUtils.parseExtmap = function (line) {\n  const parts = line.substr(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1]\n  };\n}; // Generates an extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\n\n\nSDPUtils.writeExtmap = function (headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + '\\r\\n';\n}; // Parses a fmtp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\n\n\nSDPUtils.parseFmtp = function (line) {\n  const parsed = {};\n  let kv;\n  const parts = line.substr(line.indexOf(' ') + 1).split(';');\n\n  for (let j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n\n  return parsed;\n}; // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\n\n\nSDPUtils.writeFmtp = function (codec) {\n  let line = '';\n  let pt = codec.payloadType;\n\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    const params = [];\n    Object.keys(codec.parameters).forEach(param => {\n      if (codec.parameters[param] !== undefined) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n\n  return line;\n}; // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\n\n\nSDPUtils.parseRtcpFb = function (line) {\n  const parts = line.substr(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' ')\n  };\n}; // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\n\n\nSDPUtils.writeRtcpFb = function (codec) {\n  let lines = '';\n  let pt = codec.payloadType;\n\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(fb => {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\\r\\n';\n    });\n  }\n\n  return lines;\n}; // Parses a RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\n\n\nSDPUtils.parseSsrcMedia = function (line) {\n  const sp = line.indexOf(' ');\n  const parts = {\n    ssrc: parseInt(line.substr(7, sp - 7), 10)\n  };\n  const colon = line.indexOf(':', sp);\n\n  if (colon > -1) {\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\n    parts.value = line.substr(colon + 1);\n  } else {\n    parts.attribute = line.substr(sp + 1);\n  }\n\n  return parts;\n}; // Parse a ssrc-group line (see RFC 5576). Sample input:\n// a=ssrc-group:semantics 12 34\n\n\nSDPUtils.parseSsrcGroup = function (line) {\n  const parts = line.substr(13).split(' ');\n  return {\n    semantics: parts.shift(),\n    ssrcs: parts.map(ssrc => parseInt(ssrc, 10))\n  };\n}; // Extracts the MID (RFC 5888) from a media section.\n// Returns the MID or undefined if no mid line was found.\n\n\nSDPUtils.getMid = function (mediaSection) {\n  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n\n  if (mid) {\n    return mid.substr(6);\n  }\n}; // Parses a fingerprint line for DTLS-SRTP.\n\n\nSDPUtils.parseFingerprint = function (line) {\n  const parts = line.substr(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(),\n    // algorithm is case-sensitive in Edge.\n    value: parts[1].toUpperCase() // the definition is upper-case in RFC 4572.\n\n  };\n}; // Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\n\n\nSDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:'); // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint)\n  };\n}; // Serializes DTLS parameters to SDP.\n\n\nSDPUtils.writeDtlsParameters = function (params, setupType) {\n  let sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(fp => {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n}; // Parses a=crypto lines into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\n\n\nSDPUtils.parseCryptoLine = function (line) {\n  const parts = line.substr(9).split(' ');\n  return {\n    tag: parseInt(parts[0], 10),\n    cryptoSuite: parts[1],\n    keyParams: parts[2],\n    sessionParams: parts.slice(3)\n  };\n};\n\nSDPUtils.writeCryptoLine = function (parameters) {\n  return 'a=crypto:' + parameters.tag + ' ' + parameters.cryptoSuite + ' ' + (typeof parameters.keyParams === 'object' ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') + '\\r\\n';\n}; // Parses the crypto key parameters into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\n\n\nSDPUtils.parseCryptoKeyParams = function (keyParams) {\n  if (keyParams.indexOf('inline:') !== 0) {\n    return null;\n  }\n\n  const parts = keyParams.substr(7).split('|');\n  return {\n    keyMethod: 'inline',\n    keySalt: parts[0],\n    lifeTime: parts[1],\n    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined\n  };\n};\n\nSDPUtils.writeCryptoKeyParams = function (keyParams) {\n  return keyParams.keyMethod + ':' + keyParams.keySalt + (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') + (keyParams.mkiValue && keyParams.mkiLength ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength : '');\n}; // Extracts all SDES parameters.\n\n\nSDPUtils.getCryptoParameters = function (mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=crypto:');\n  return lines.map(SDPUtils.parseCryptoLine);\n}; // Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\n\n\nSDPUtils.getIceParameters = function (mediaSection, sessionpart) {\n  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-ufrag:')[0];\n  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-pwd:')[0];\n\n  if (!(ufrag && pwd)) {\n    return null;\n  }\n\n  return {\n    usernameFragment: ufrag.substr(12),\n    password: pwd.substr(10)\n  };\n}; // Serializes ICE parameters to SDP.\n\n\nSDPUtils.writeIceParameters = function (params) {\n  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' + 'a=ice-pwd:' + params.password + '\\r\\n';\n\n  if (params.iceLite) {\n    sdp += 'a=ice-lite\\r\\n';\n  }\n\n  return sdp;\n}; // Parses the SDP media section and returns RTCRtpParameters.\n\n\nSDPUtils.parseRtpParameters = function (mediaSection) {\n  const description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: []\n  };\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n\n  for (let i = 3; i < mline.length; i++) {\n    // find all codecs from mline[3..]\n    const pt = mline[i];\n    const rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n\n    if (rtpmapline) {\n      const codec = SDPUtils.parseRtpMap(rtpmapline);\n      const fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' '); // Only the first a=fmtp:<pt> is considered.\n\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec); // parse FEC mechanisms from rtpmap lines.\n\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n\n        default:\n          // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  }); // FIXME: parse rtcp.\n\n  return description;\n}; // Generates parts of the SDP media section describing the capabilities /\n// parameters.\n\n\nSDPUtils.writeRtpDescription = function (kind, caps) {\n  let sdp = ''; // Build the mline.\n\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n\n  sdp += ' UDP/TLS/RTP/SAVPF ';\n  sdp += caps.codecs.map(codec => {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n'; // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n\n  caps.codecs.forEach(codec => {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  let maxptime = 0;\n  caps.codecs.forEach(codec => {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(extension => {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  } // FIXME: write fecMechanisms.\n\n\n  return sdp;\n}; // Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\n\n\nSDPUtils.parseRtpEncodingParameters = function (mediaSection) {\n  const encodingParameters = [];\n  const description = SDPUtils.parseRtpParameters(mediaSection);\n  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1; // filter a=ssrc:... cname:, ignore PlanB-msid\n\n  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(parts => parts.attribute === 'cname');\n  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  let secondarySsrc;\n  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map(line => {\n    const parts = line.substr(17).split(' ');\n    return parts.map(part => parseInt(part, 10));\n  });\n\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(codec => {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      let encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10)\n      };\n\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {\n          ssrc: secondarySsrc\n        };\n      }\n\n      encodingParameters.push(encParam);\n\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: primarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc\n    });\n  } // we support both b=AS and b=TIAS but interpret AS as TIAS.\n\n\n  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\n    } else {\n      bandwidth = undefined;\n    }\n\n    encodingParameters.forEach(params => {\n      params.maxBitrate = bandwidth;\n    });\n  }\n\n  return encodingParameters;\n}; // parses http://draft.ortc.org/#rtcrtcpparameters*\n\n\nSDPUtils.parseRtcpParameters = function (mediaSection) {\n  const rtcpParameters = {}; // Gets the first SSRC. Note that with RTX there might be multiple\n  // SSRCs.\n\n  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(obj => obj.attribute === 'cname')[0];\n\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  } // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n\n\n  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0; // parses the rtcp-mux attrbute.\n  // Note that Edge does not support unmuxed RTCP.\n\n  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n  return rtcpParameters;\n};\n\nSDPUtils.writeRtcpParameters = function (rtcpParameters) {\n  let sdp = '';\n\n  if (rtcpParameters.reducedSize) {\n    sdp += 'a=rtcp-rsize\\r\\n';\n  }\n\n  if (rtcpParameters.mux) {\n    sdp += 'a=rtcp-mux\\r\\n';\n  }\n\n  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n    sdp += 'a=ssrc:' + rtcpParameters.ssrc + ' cname:' + rtcpParameters.cname + '\\r\\n';\n  }\n\n  return sdp;\n}; // parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\n\n\nSDPUtils.parseMsid = function (mediaSection) {\n  let parts;\n  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n\n  if (spec.length === 1) {\n    parts = spec[0].substr(7).split(' ');\n    return {\n      stream: parts[0],\n      track: parts[1]\n    };\n  }\n\n  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(msidParts => msidParts.attribute === 'msid');\n\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {\n      stream: parts[0],\n      track: parts[1]\n    };\n  }\n}; // SCTP\n// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n// to draft-ietf-mmusic-sctp-sdp-05\n\n\nSDPUtils.parseSctpDescription = function (mediaSection) {\n  const mline = SDPUtils.parseMLine(mediaSection);\n  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n  let maxMessageSize;\n\n  if (maxSizeLine.length > 0) {\n    maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);\n  }\n\n  if (isNaN(maxMessageSize)) {\n    maxMessageSize = 65536;\n  }\n\n  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n\n  if (sctpPort.length > 0) {\n    return {\n      port: parseInt(sctpPort[0].substr(12), 10),\n      protocol: mline.fmt,\n      maxMessageSize\n    };\n  }\n\n  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n\n  if (sctpMapLines.length > 0) {\n    const parts = sctpMapLines[0].substr(10).split(' ');\n    return {\n      port: parseInt(parts[0], 10),\n      protocol: parts[1],\n      maxMessageSize\n    };\n  }\n}; // SCTP\n// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n// support by now receiving in this format, unless we originally parsed\n// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n// protocol of DTLS/SCTP -- without UDP/ or TCP/)\n\n\nSDPUtils.writeSctpDescription = function (media, sctp) {\n  let output = [];\n\n  if (media.protocol !== 'DTLS/SCTP') {\n    output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctp-port:' + sctp.port + '\\r\\n'];\n  } else {\n    output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n'];\n  }\n\n  if (sctp.maxMessageSize !== undefined) {\n    output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n  }\n\n  return output.join('');\n}; // Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\n\n\nSDPUtils.generateSessionId = function () {\n  return Math.random().toString().substr(2, 21);\n}; // Write boiler plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\n// sessUser is optional and defaults to 'thisisadapterortc'\n\n\nSDPUtils.writeSessionBoilerplate = function (sessId, sessVer, sessUser) {\n  let sessionId;\n  const version = sessVer !== undefined ? sessVer : 2;\n\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n\n  const user = sessUser || 'thisisadapterortc'; // FIXME: sess-id should be an NTP timestamp.\n\n  return 'v=0\\r\\n' + 'o=' + user + ' ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\\r\\n' + 's=-\\r\\n' + 't=0 0\\r\\n';\n}; // Gets the direction from the mediaSection or the sessionpart.\n\n\nSDPUtils.getDirection = function (mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  const lines = SDPUtils.splitLines(mediaSection);\n\n  for (let i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substr(2);\n\n      default: // FIXME: What should happen here?\n\n    }\n  }\n\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function (mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  return mline[0].substr(2);\n};\n\nSDPUtils.isRejected = function (mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function (mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const parts = lines[0].substr(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' ')\n  };\n};\n\nSDPUtils.parseOLine = function (mediaSection) {\n  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  const parts = line.substr(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5]\n  };\n}; // a very naive interpretation of a valid SDP.\n\n\nSDPUtils.isValidSDP = function (blob) {\n  if (typeof blob !== 'string' || blob.length === 0) {\n    return false;\n  }\n\n  const lines = SDPUtils.splitLines(blob);\n\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n      return false;\n    } // TODO: check the modifier a bit more.\n\n  }\n\n  return true;\n}; // Expose public methods.\n\n\nif (true) {\n  module.exports = SDPUtils;\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/sdp/sdp.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/adapter_core.js":
/*!************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/adapter_core.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _adapter_factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapter_factory.js */ \"./node_modules/webrtc-adapter/src/js/adapter_factory.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n/* eslint-env node */\n\n\n\nconst adapter = (0,_adapter_factory_js__WEBPACK_IMPORTED_MODULE_0__.adapterFactory)({\n  window: typeof window === 'undefined' ? undefined : window\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (adapter);\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/adapter_core.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/adapter_factory.js":
/*!***************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/adapter_factory.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"adapterFactory\": () => (/* binding */ adapterFactory)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/* harmony import */ var _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chrome/chrome_shim */ \"./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js\");\n/* harmony import */ var _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./firefox/firefox_shim */ \"./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js\");\n/* harmony import */ var _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./safari/safari_shim */ \"./node_modules/webrtc-adapter/src/js/safari/safari_shim.js\");\n/* harmony import */ var _common_shim__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common_shim */ \"./node_modules/webrtc-adapter/src/js/common_shim.js\");\n/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! sdp */ \"./node_modules/sdp/sdp.js\");\n/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(sdp__WEBPACK_IMPORTED_MODULE_5__);\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n // Browser shims.\n\n\n\n\n\n // Shimming starts here.\n\nfunction adapterFactory() {\n  let {\n    window\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    shimChrome: true,\n    shimFirefox: true,\n    shimSafari: true\n  };\n  // Utils.\n  const logging = _utils__WEBPACK_IMPORTED_MODULE_0__.log;\n  const browserDetails = _utils__WEBPACK_IMPORTED_MODULE_0__.detectBrowser(window);\n  const adapter = {\n    browserDetails,\n    commonShim: _common_shim__WEBPACK_IMPORTED_MODULE_4__,\n    extractVersion: _utils__WEBPACK_IMPORTED_MODULE_0__.extractVersion,\n    disableLog: _utils__WEBPACK_IMPORTED_MODULE_0__.disableLog,\n    disableWarnings: _utils__WEBPACK_IMPORTED_MODULE_0__.disableWarnings,\n    // Expose sdp as a convenience. For production apps include directly.\n    sdp: sdp__WEBPACK_IMPORTED_MODULE_5__\n  }; // Shim browser if found.\n\n  switch (browserDetails.browser) {\n    case 'chrome':\n      if (!_chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__ || !_chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimPeerConnection || !options.shimChrome) {\n        logging('Chrome shim is not included in this adapter release.');\n        return adapter;\n      }\n\n      if (browserDetails.version === null) {\n        logging('Chrome shim can not determine version, not shimming.');\n        return adapter;\n      }\n\n      logging('adapter.js shimming chrome.'); // Export to the adapter global object visible in the browser.\n\n      adapter.browserShim = _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__; // Must be called before shimPeerConnection.\n\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimMediaStream(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimPeerConnection(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimOnTrack(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimAddTrackRemoveTrack(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimGetSendersWithDtmf(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimGetStats(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimSenderReceiverGetStats(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.fixNegotiationNeeded(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimConnectionState(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.removeExtmapAllowMixed(window, browserDetails);\n      break;\n\n    case 'firefox':\n      if (!_firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__ || !_firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimPeerConnection || !options.shimFirefox) {\n        logging('Firefox shim is not included in this adapter release.');\n        return adapter;\n      }\n\n      logging('adapter.js shimming firefox.'); // Export to the adapter global object visible in the browser.\n\n      adapter.browserShim = _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__; // Must be called before shimPeerConnection.\n\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimGetUserMedia(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimPeerConnection(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimOnTrack(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimRemoveStream(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimSenderGetStats(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimReceiverGetStats(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimRTCDataChannel(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimAddTransceiver(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimGetParameters(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimCreateOffer(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimCreateAnswer(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimConnectionState(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);\n      break;\n\n    case 'safari':\n      if (!_safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__ || !options.shimSafari) {\n        logging('Safari shim is not included in this adapter release.');\n        return adapter;\n      }\n\n      logging('adapter.js shimming safari.'); // Export to the adapter global object visible in the browser.\n\n      adapter.browserShim = _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__; // Must be called before shimCallbackAPI.\n\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimRTCIceServerUrls(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimCreateOfferLegacy(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimCallbacksAPI(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimLocalStreamsAPI(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimRemoteStreamsAPI(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimTrackEventTransceiver(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimGetUserMedia(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimAudioContext(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.removeExtmapAllowMixed(window, browserDetails);\n      break;\n\n    default:\n      logging('Unsupported browser!');\n      break;\n  }\n\n  return adapter;\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/adapter_factory.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fixNegotiationNeeded\": () => (/* binding */ fixNegotiationNeeded),\n/* harmony export */   \"shimAddTrackRemoveTrack\": () => (/* binding */ shimAddTrackRemoveTrack),\n/* harmony export */   \"shimAddTrackRemoveTrackWithNative\": () => (/* binding */ shimAddTrackRemoveTrackWithNative),\n/* harmony export */   \"shimGetDisplayMedia\": () => (/* reexport safe */ _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__.shimGetDisplayMedia),\n/* harmony export */   \"shimGetSendersWithDtmf\": () => (/* binding */ shimGetSendersWithDtmf),\n/* harmony export */   \"shimGetStats\": () => (/* binding */ shimGetStats),\n/* harmony export */   \"shimGetUserMedia\": () => (/* reexport safe */ _getusermedia__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia),\n/* harmony export */   \"shimMediaStream\": () => (/* binding */ shimMediaStream),\n/* harmony export */   \"shimOnTrack\": () => (/* binding */ shimOnTrack),\n/* harmony export */   \"shimPeerConnection\": () => (/* binding */ shimPeerConnection),\n/* harmony export */   \"shimSenderReceiverGetStats\": () => (/* binding */ shimSenderReceiverGetStats)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/* harmony import */ var _getusermedia__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getusermedia */ \"./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js\");\n/* harmony import */ var _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getdisplaymedia */ \"./node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n/* eslint-env node */\n\n\n\n\n\nfunction shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\nfunction shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n\n        this.addEventListener('track', this._ontrack = f);\n      },\n\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      if (!this._ontrackpoly) {\n        this._ontrackpoly = e => {\n          // onaddstream does not fire when a track is added to an existing\n          // stream. But stream.onaddtrack is implemented so we use that.\n          e.stream.addEventListener('addtrack', te => {\n            let receiver;\n\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find(r => r.track && r.track.id === te.track.id);\n            } else {\n              receiver = {\n                track: te.track\n              };\n            }\n\n            const event = new Event('track');\n            event.track = te.track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n          e.stream.getTracks().forEach(track => {\n            let receiver;\n\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find(r => r.track && r.track.id === track.id);\n            } else {\n              receiver = {\n                track\n              };\n            }\n\n            const event = new Event('track');\n            event.track = track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n        };\n\n        this.addEventListener('addstream', this._ontrackpoly);\n      }\n\n      return origSetRemoteDescription.apply(this, arguments);\n    };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver', {\n          value: {\n            receiver: e.receiver\n          }\n        });\n      }\n\n      return e;\n    });\n  }\n}\nfunction shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function (pc, track) {\n      return {\n        track,\n\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n\n          return this._dtmf;\n        },\n\n        _pc: pc\n      };\n    }; // augment addTrack when getSenders is not available.\n\n\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n\n      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        let sender = origAddTrack.apply(this, arguments);\n\n        if (!sender) {\n          sender = shimSenderWithDtmf(this, track);\n\n          this._senders.push(sender);\n        }\n\n        return sender;\n      };\n\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n\n      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        origRemoveTrack.apply(this, arguments);\n\n        const idx = this._senders.indexOf(sender);\n\n        if (idx !== -1) {\n          this._senders.splice(idx, 1);\n        }\n      };\n    }\n\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      this._senders = this._senders || [];\n      origRemoveStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        const sender = this._senders.find(s => s.track === track);\n\n        if (sender) {\n          // remove sender\n          this._senders.splice(this._senders.indexOf(sender), 1);\n        }\n      });\n    };\n  } else if (typeof window === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n\n        return this._dtmf;\n      }\n\n    });\n  }\n}\nfunction shimGetStats(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments; // If selector is a function then we are in the old style stats so just\n    // pass back the original getStats format to avoid breaking old users.\n\n    if (arguments.length > 0 && typeof selector === 'function') {\n      return origGetStats.apply(this, arguments);\n    } // When spec-style getStats is supported, return those when called with\n    // either no arguments or the selector argument is null.\n\n\n    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {\n      return origGetStats.apply(this, []);\n    }\n\n    const fixChromeStats_ = function (response) {\n      const standardReport = {};\n      const reports = response.result();\n      reports.forEach(report => {\n        const standardStats = {\n          id: report.id,\n          timestamp: report.timestamp,\n          type: {\n            localcandidate: 'local-candidate',\n            remotecandidate: 'remote-candidate'\n          }[report.type] || report.type\n        };\n        report.names().forEach(name => {\n          standardStats[name] = report.stat(name);\n        });\n        standardReport[standardStats.id] = standardStats;\n      });\n      return standardReport;\n    }; // shim getStats with maplike support\n\n\n    const makeMapStats = function (stats) {\n      return new Map(Object.keys(stats).map(key => [key, stats[key]]));\n    };\n\n    if (arguments.length >= 2) {\n      const successCallbackWrapper_ = function (response) {\n        onSucc(makeMapStats(fixChromeStats_(response)));\n      };\n\n      return origGetStats.apply(this, [successCallbackWrapper_, selector]);\n    } // promise-support\n\n\n    return new Promise((resolve, reject) => {\n      origGetStats.apply(this, [function (response) {\n        resolve(makeMapStats(fixChromeStats_(response)));\n      }, reject]);\n    }).then(onSucc, onErr);\n  };\n}\nfunction shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  } // shim sender stats.\n\n\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n      /* Note: this will include stats of all senders that\n       *   send a track with the same id as sender.track as\n       *   it is not possible to identify the RTCRtpSender.\n       */\n      _utils_js__WEBPACK_IMPORTED_MODULE_0__.filterStats(result, sender.track, true));\n    };\n  } // shim receiver stats.\n\n\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n        const receivers = origGetReceivers.apply(this, []);\n        receivers.forEach(receiver => receiver._pc = this);\n        return receivers;\n      };\n    }\n\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result => _utils_js__WEBPACK_IMPORTED_MODULE_0__.filterStats(result, receiver.track, false));\n    };\n  }\n\n  if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  } // shim RTCPeerConnection.getStats(track).\n\n\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n\n        return r.track === track;\n      });\n\n      if (err || sender && receiver) {\n        return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n\n      return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));\n    }\n\n    return origGetStats.apply(this, arguments);\n  };\n}\nfunction shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    return Object.keys(this._shimmedLocalStreams).map(streamId => this._shimmedLocalStreams[streamId][0]);\n  };\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (!stream) {\n      return origAddTrack.apply(this, arguments);\n    }\n\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    const sender = origAddTrack.apply(this, arguments);\n\n    if (!this._shimmedLocalStreams[stream.id]) {\n      this._shimmedLocalStreams[stream.id] = [stream, sender];\n    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n      this._shimmedLocalStreams[stream.id].push(sender);\n    }\n\n    return sender;\n  };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders().filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    delete this._shimmedLocalStreams[stream.id];\n    return origRemoveStream.apply(this, arguments);\n  };\n\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n    if (sender) {\n      Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n\n        if (idx !== -1) {\n          this._shimmedLocalStreams[streamId].splice(idx, 1);\n        }\n\n        if (this._shimmedLocalStreams[streamId].length === 1) {\n          delete this._shimmedLocalStreams[streamId];\n        }\n      });\n    }\n\n    return origRemoveTrack.apply(this, arguments);\n  };\n}\nfunction shimAddTrackRemoveTrack(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  } // shim addTrack and removeTrack.\n\n\n  if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  } // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n\n\n  const origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;\n\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    const nativeStreams = origGetLocalStreams.apply(this);\n    this._reverseStreams = this._reverseStreams || {};\n    return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n  };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    }); // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n\n    origAddStream.apply(this, [stream]);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);\n    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n    delete this._streams[stream.id];\n  };\n\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    }\n\n    const streams = [].slice.call(arguments, 1);\n\n    if (streams.length !== 1 || !streams[0].getTracks().find(t => t === track)) {\n      // this is not fully correct but all we can manage without\n      // [[associated MediaStreams]] internal slot.\n      throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');\n    }\n\n    const alreadyExists = this.getSenders().find(s => s.track === track);\n\n    if (alreadyExists) {\n      throw new DOMException('Track already exists.', 'InvalidAccessError');\n    }\n\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    const oldStream = this._streams[stream.id];\n\n    if (oldStream) {\n      // this is using odd Chrome behaviour, use with caution:\n      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n      // Note: we rely on the high-level addTrack/dtmf shim to\n      // create the sender with a dtmf sender.\n      oldStream.addTrack(track); // Trigger ONN async.\n\n      Promise.resolve().then(() => {\n        this.dispatchEvent(new Event('negotiationneeded'));\n      });\n    } else {\n      const newStream = new window.MediaStream([track]);\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      this.addStream(newStream);\n    }\n\n    return this.getSenders().find(s => s.track === track);\n  }; // replace the internal stream id with the external one and\n  // vice versa.\n\n\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n\n  ['createOffer', 'createAnswer'].forEach(function (method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {\n      [method]() {\n        const args = arguments;\n        const isLegacyCall = arguments.length && typeof arguments[0] === 'function';\n\n        if (isLegacyCall) {\n          return nativeMethod.apply(this, [description => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          }, err => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]]);\n        }\n\n        return nativeMethod.apply(this, arguments).then(description => replaceInternalStreamId(this, description));\n      }\n\n    };\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n  const origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\n\n  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    if (!arguments.length || !arguments[0].type) {\n      return origSetLocalDescription.apply(this, arguments);\n    }\n\n    arguments[0] = replaceExternalStreamId(this, arguments[0]);\n    return origSetLocalDescription.apply(this, arguments);\n  }; // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {\n    get() {\n      const description = origLocalDescription.get.apply(this);\n\n      if (description.type === '') {\n        return description;\n      }\n\n      return replaceInternalStreamId(this, description);\n    }\n\n  });\n\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    } // We can not yet check for sender instanceof RTCRtpSender\n    // since we shim RTPSender. So we check if sender._pc is set.\n\n\n    if (!sender._pc) {\n      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');\n    }\n\n    const isLocal = sender._pc === this;\n\n    if (!isLocal) {\n      throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');\n    } // Search for the native stream the senders track belongs to.\n\n\n    this._streams = this._streams || {};\n    let stream;\n    Object.keys(this._streams).forEach(streamid => {\n      const hasTrack = this._streams[streamid].getTracks().find(track => sender.track === track);\n\n      if (hasTrack) {\n        stream = this._streams[streamid];\n      }\n    });\n\n    if (stream) {\n      if (stream.getTracks().length === 1) {\n        // if this is the last track of the stream, remove the stream. This\n        // takes care of any shimmed _senders.\n        this.removeStream(this._reverseStreams[stream.id]);\n      } else {\n        // relying on the same odd chrome behaviour as above.\n        stream.removeTrack(sender.track);\n      }\n\n      this.dispatchEvent(new Event('negotiationneeded'));\n    }\n  };\n}\nfunction shimPeerConnection(window, browserDetails) {\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n\n  if (!window.RTCPeerConnection) {\n    return;\n  } // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n\n\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n      const nativeMethod = window.RTCPeerConnection.prototype[method];\n      const methodObj = {\n        [method]() {\n          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }\n\n      };\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n} // Attempt to fix ONN in plan-b mode.\n\nfunction fixNegotiationNeeded(window, browserDetails) {\n  _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n\n    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === 'plan-b') {\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n    }\n\n    return e;\n  });\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js":
/*!**********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"shimGetDisplayMedia\": () => (/* binding */ shimGetDisplayMedia)\n/* harmony export */ });\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n/* eslint-env node */\n\n\nfunction shimGetDisplayMedia(window, getSourceId) {\n  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n\n  if (!window.navigator.mediaDevices) {\n    return;\n  } // getSourceId is a function that returns a promise resolving with\n  // the sourceId of the screen/window/tab to be shared.\n\n\n  if (typeof getSourceId !== 'function') {\n    console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');\n    return;\n  }\n\n  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n    return getSourceId(constraints).then(sourceId => {\n      const widthSpecified = constraints.video && constraints.video.width;\n      const heightSpecified = constraints.video && constraints.video.height;\n      const frameRateSpecified = constraints.video && constraints.video.frameRate;\n      constraints.video = {\n        mandatory: {\n          chromeMediaSource: 'desktop',\n          chromeMediaSourceId: sourceId,\n          maxFrameRate: frameRateSpecified || 3\n        }\n      };\n\n      if (widthSpecified) {\n        constraints.video.mandatory.maxWidth = widthSpecified;\n      }\n\n      if (heightSpecified) {\n        constraints.video.mandatory.maxHeight = heightSpecified;\n      }\n\n      return window.navigator.mediaDevices.getUserMedia(constraints);\n    });\n  };\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"shimGetUserMedia\": () => (/* binding */ shimGetUserMedia)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n/* eslint-env node */\n\n\n\nconst logging = _utils_js__WEBPACK_IMPORTED_MODULE_0__.log;\nfunction shimGetUserMedia(window, browserDetails) {\n  const navigator = window && window.navigator;\n\n  if (!navigator.mediaDevices) {\n    return;\n  }\n\n  const constraintsToChrome_ = function (c) {\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\n      return c;\n    }\n\n    const cc = {};\n    Object.keys(c).forEach(key => {\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n        return;\n      }\n\n      const r = typeof c[key] === 'object' ? c[key] : {\n        ideal: c[key]\n      };\n\n      if (r.exact !== undefined && typeof r.exact === 'number') {\n        r.min = r.max = r.exact;\n      }\n\n      const oldname_ = function (prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n\n        return name === 'deviceId' ? 'sourceId' : name;\n      };\n\n      if (r.ideal !== undefined) {\n        cc.optional = cc.optional || [];\n        let oc = {};\n\n        if (typeof r.ideal === 'number') {\n          oc[oldname_('min', key)] = r.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_('max', key)] = r.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_('', key)] = r.ideal;\n          cc.optional.push(oc);\n        }\n      }\n\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_('', key)] = r.exact;\n      } else {\n        ['min', 'max'].forEach(mix => {\n          if (r[mix] !== undefined) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r[mix];\n          }\n        });\n      }\n    });\n\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n\n    return cc;\n  };\n\n  const shimConstraints_ = function (constraints, func) {\n    if (browserDetails.version >= 61) {\n      return func(constraints);\n    }\n\n    constraints = JSON.parse(JSON.stringify(constraints));\n\n    if (constraints && typeof constraints.audio === 'object') {\n      const remap = function (obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n\n    if (constraints && typeof constraints.video === 'object') {\n      // Shim facingMode for mobile & surface pro.\n      let face = constraints.video.facingMode;\n      face = face && (typeof face === 'object' ? face : {\n        ideal: face\n      });\n      const getSupportedFacingModeLies = browserDetails.version < 66;\n\n      if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        let matches;\n\n        if (face.exact === 'environment' || face.ideal === 'environment') {\n          matches = ['back', 'rear'];\n        } else if (face.exact === 'user' || face.ideal === 'user') {\n          matches = ['front'];\n        }\n\n        if (matches) {\n          // Look for matches in label, or use last cam for back (typical).\n          return navigator.mediaDevices.enumerateDevices().then(devices => {\n            devices = devices.filter(d => d.kind === 'videoinput');\n            let dev = devices.find(d => matches.some(match => d.label.toLowerCase().includes(match)));\n\n            if (!dev && devices.length && matches.includes('back')) {\n              dev = devices[devices.length - 1]; // more likely the back cam\n            }\n\n            if (dev) {\n              constraints.video.deviceId = face.exact ? {\n                exact: dev.deviceId\n              } : {\n                ideal: dev.deviceId\n              };\n            }\n\n            constraints.video = constraintsToChrome_(constraints.video);\n            logging('chrome: ' + JSON.stringify(constraints));\n            return func(constraints);\n          });\n        }\n      }\n\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n\n    logging('chrome: ' + JSON.stringify(constraints));\n    return func(constraints);\n  };\n\n  const shimError_ = function (e) {\n    if (browserDetails.version >= 64) {\n      return e;\n    }\n\n    return {\n      name: {\n        PermissionDeniedError: 'NotAllowedError',\n        PermissionDismissedError: 'NotAllowedError',\n        InvalidStateError: 'NotAllowedError',\n        DevicesNotFoundError: 'NotFoundError',\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\n        TrackStartError: 'NotReadableError',\n        MediaDeviceFailedDueToShutdown: 'NotAllowedError',\n        MediaDeviceKillSwitchOn: 'NotAllowedError',\n        TabCaptureError: 'AbortError',\n        ScreenCaptureError: 'AbortError',\n        DeviceCaptureError: 'AbortError'\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint || e.constraintName,\n\n      toString() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n\n    };\n  };\n\n  const getUserMedia_ = function (constraints, onSuccess, onError) {\n    shimConstraints_(constraints, c => {\n      navigator.webkitGetUserMedia(c, onSuccess, e => {\n        if (onError) {\n          onError(shimError_(e));\n        }\n      });\n    });\n  };\n\n  navigator.getUserMedia = getUserMedia_.bind(navigator); // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n  // function which returns a Promise, it does not accept spec-style\n  // constraints.\n\n  if (navigator.mediaDevices.getUserMedia) {\n    const origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n\n    navigator.mediaDevices.getUserMedia = function (cs) {\n      return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {\n        if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\n          stream.getTracks().forEach(track => {\n            track.stop();\n          });\n          throw new DOMException('', 'NotFoundError');\n        }\n\n        return stream;\n      }, e => Promise.reject(shimError_(e))));\n    };\n  }\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/common_shim.js":
/*!***********************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/common_shim.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"removeExtmapAllowMixed\": () => (/* binding */ removeExtmapAllowMixed),\n/* harmony export */   \"shimAddIceCandidateNullOrEmpty\": () => (/* binding */ shimAddIceCandidateNullOrEmpty),\n/* harmony export */   \"shimConnectionState\": () => (/* binding */ shimConnectionState),\n/* harmony export */   \"shimMaxMessageSize\": () => (/* binding */ shimMaxMessageSize),\n/* harmony export */   \"shimParameterlessSetLocalDescription\": () => (/* binding */ shimParameterlessSetLocalDescription),\n/* harmony export */   \"shimRTCIceCandidate\": () => (/* binding */ shimRTCIceCandidate),\n/* harmony export */   \"shimSendThrowTypeError\": () => (/* binding */ shimSendThrowTypeError)\n/* harmony export */ });\n/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sdp */ \"./node_modules/sdp/sdp.js\");\n/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sdp__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n/* eslint-env node */\n\n\n\n\nfunction shimRTCIceCandidate(window) {\n  // foundation is arbitrarily chosen as an indicator for full support for\n  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {\n    return;\n  }\n\n  const NativeRTCIceCandidate = window.RTCIceCandidate;\n\n  window.RTCIceCandidate = function RTCIceCandidate(args) {\n    // Remove the a= which shouldn't be part of the candidate string.\n    if (typeof args === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {\n      args = JSON.parse(JSON.stringify(args));\n      args.candidate = args.candidate.substr(2);\n    }\n\n    if (args.candidate && args.candidate.length) {\n      // Augment the native candidate with the parsed fields.\n      const nativeCandidate = new NativeRTCIceCandidate(args);\n      const parsedCandidate = sdp__WEBPACK_IMPORTED_MODULE_0___default().parseCandidate(args.candidate);\n      const augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate); // Add a serializer that does not serialize the extra attributes.\n\n      augmentedCandidate.toJSON = function toJSON() {\n        return {\n          candidate: augmentedCandidate.candidate,\n          sdpMid: augmentedCandidate.sdpMid,\n          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,\n          usernameFragment: augmentedCandidate.usernameFragment\n        };\n      };\n\n      return augmentedCandidate;\n    }\n\n    return new NativeRTCIceCandidate(args);\n  };\n\n  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype; // Hook up the augmented candidate in onicecandidate and\n  // addEventListener('icecandidate', ...)\n\n  _utils__WEBPACK_IMPORTED_MODULE_1__.wrapPeerConnectionEvent(window, 'icecandidate', e => {\n    if (e.candidate) {\n      Object.defineProperty(e, 'candidate', {\n        value: new window.RTCIceCandidate(e.candidate),\n        writable: 'false'\n      });\n    }\n\n    return e;\n  });\n}\nfunction shimMaxMessageSize(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  if (!('sctp' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {\n      get() {\n        return typeof this._sctp === 'undefined' ? null : this._sctp;\n      }\n\n    });\n  }\n\n  const sctpInDescription = function (description) {\n    if (!description || !description.sdp) {\n      return false;\n    }\n\n    const sections = sdp__WEBPACK_IMPORTED_MODULE_0___default().splitSections(description.sdp);\n    sections.shift();\n    return sections.some(mediaSection => {\n      const mLine = sdp__WEBPACK_IMPORTED_MODULE_0___default().parseMLine(mediaSection);\n      return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;\n    });\n  };\n\n  const getRemoteFirefoxVersion = function (description) {\n    // TODO: Is there a better solution for detecting Firefox?\n    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n\n    if (match === null || match.length < 2) {\n      return -1;\n    }\n\n    const version = parseInt(match[1], 10); // Test for NaN (yes, this is ugly)\n\n    return version !== version ? -1 : version;\n  };\n\n  const getCanSendMaxMessageSize = function (remoteIsFirefox) {\n    // Every implementation we know can send at least 64 KiB.\n    // Note: Although Chrome is technically able to send up to 256 KiB, the\n    //       data does not reach the other peer reliably.\n    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n    let canSendMaxMessageSize = 65536;\n\n    if (browserDetails.browser === 'firefox') {\n      if (browserDetails.version < 57) {\n        if (remoteIsFirefox === -1) {\n          // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n          // fragmentation.\n          canSendMaxMessageSize = 16384;\n        } else {\n          // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n          // messages. Thus, supporting ~2 GiB when sending.\n          canSendMaxMessageSize = 2147483637;\n        }\n      } else if (browserDetails.version < 60) {\n        // Currently, all FF >= 57 will reset the remote maximum message size\n        // to the default value when a data channel is created at a later\n        // stage. :(\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\n      } else {\n        // FF >= 60 supports sending ~2 GiB\n        canSendMaxMessageSize = 2147483637;\n      }\n    }\n\n    return canSendMaxMessageSize;\n  };\n\n  const getMaxMessageSize = function (description, remoteIsFirefox) {\n    // Note: 65536 bytes is the default value from the SDP spec. Also,\n    //       every implementation we know supports receiving 65536 bytes.\n    let maxMessageSize = 65536; // FF 57 has a slightly incorrect default remote max message size, so\n    // we need to adjust it here to avoid a failure when sending.\n    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n\n    if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {\n      maxMessageSize = 65535;\n    }\n\n    const match = sdp__WEBPACK_IMPORTED_MODULE_0___default().matchPrefix(description.sdp, 'a=max-message-size:');\n\n    if (match.length > 0) {\n      maxMessageSize = parseInt(match[0].substr(19), 10);\n    } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {\n      // If the maximum message size is not present in the remote SDP and\n      // both local and remote are Firefox, the remote peer can receive\n      // ~2 GiB.\n      maxMessageSize = 2147483637;\n    }\n\n    return maxMessageSize;\n  };\n\n  const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n\n  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n    this._sctp = null; // Chrome decided to not expose .sctp in plan-b mode.\n    // As usual, adapter.js has to do an 'ugly worakaround'\n    // to cover up the mess.\n\n    if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {\n      const {\n        sdpSemantics\n      } = this.getConfiguration();\n\n      if (sdpSemantics === 'plan-b') {\n        Object.defineProperty(this, 'sctp', {\n          get() {\n            return typeof this._sctp === 'undefined' ? null : this._sctp;\n          },\n\n          enumerable: true,\n          configurable: true\n        });\n      }\n    }\n\n    if (sctpInDescription(arguments[0])) {\n      // Check if the remote is FF.\n      const isFirefox = getRemoteFirefoxVersion(arguments[0]); // Get the maximum message size the local peer is capable of sending\n\n      const canSendMMS = getCanSendMaxMessageSize(isFirefox); // Get the maximum message size of the remote peer.\n\n      const remoteMMS = getMaxMessageSize(arguments[0], isFirefox); // Determine final maximum message size\n\n      let maxMessageSize;\n\n      if (canSendMMS === 0 && remoteMMS === 0) {\n        maxMessageSize = Number.POSITIVE_INFINITY;\n      } else if (canSendMMS === 0 || remoteMMS === 0) {\n        maxMessageSize = Math.max(canSendMMS, remoteMMS);\n      } else {\n        maxMessageSize = Math.min(canSendMMS, remoteMMS);\n      } // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n      // attribute.\n\n\n      const sctp = {};\n      Object.defineProperty(sctp, 'maxMessageSize', {\n        get() {\n          return maxMessageSize;\n        }\n\n      });\n      this._sctp = sctp;\n    }\n\n    return origSetRemoteDescription.apply(this, arguments);\n  };\n}\nfunction shimSendThrowTypeError(window) {\n  if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {\n    return;\n  } // Note: Although Firefox >= 57 has a native implementation, the maximum\n  //       message size can be reset for all data channels at a later stage.\n  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n\n\n  function wrapDcSend(dc, pc) {\n    const origDataChannelSend = dc.send;\n\n    dc.send = function send() {\n      const data = arguments[0];\n      const length = data.length || data.size || data.byteLength;\n\n      if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {\n        throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');\n      }\n\n      return origDataChannelSend.apply(dc, arguments);\n    };\n  }\n\n  const origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;\n\n  window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {\n    const dataChannel = origCreateDataChannel.apply(this, arguments);\n    wrapDcSend(dataChannel, this);\n    return dataChannel;\n  };\n\n  _utils__WEBPACK_IMPORTED_MODULE_1__.wrapPeerConnectionEvent(window, 'datachannel', e => {\n    wrapDcSend(e.channel, e.target);\n    return e;\n  });\n}\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */\n\nfunction shimConnectionState(window) {\n  if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n\n  const proto = window.RTCPeerConnection.prototype;\n  Object.defineProperty(proto, 'connectionState', {\n    get() {\n      return {\n        completed: 'connected',\n        checking: 'connecting'\n      }[this.iceConnectionState] || this.iceConnectionState;\n    },\n\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(proto, 'onconnectionstatechange', {\n    get() {\n      return this._onconnectionstatechange || null;\n    },\n\n    set(cb) {\n      if (this._onconnectionstatechange) {\n        this.removeEventListener('connectionstatechange', this._onconnectionstatechange);\n        delete this._onconnectionstatechange;\n      }\n\n      if (cb) {\n        this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);\n      }\n    },\n\n    enumerable: true,\n    configurable: true\n  });\n  ['setLocalDescription', 'setRemoteDescription'].forEach(method => {\n    const origMethod = proto[method];\n\n    proto[method] = function () {\n      if (!this._connectionstatechangepoly) {\n        this._connectionstatechangepoly = e => {\n          const pc = e.target;\n\n          if (pc._lastConnectionState !== pc.connectionState) {\n            pc._lastConnectionState = pc.connectionState;\n            const newEvent = new Event('connectionstatechange', e);\n            pc.dispatchEvent(newEvent);\n          }\n\n          return e;\n        };\n\n        this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);\n      }\n\n      return origMethod.apply(this, arguments);\n    };\n  });\n}\nfunction removeExtmapAllowMixed(window, browserDetails) {\n  /* remove a=extmap-allow-mixed for webrtc.org < M71 */\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {\n    return;\n  }\n\n  if (browserDetails.browser === 'safari' && browserDetails.version >= 605) {\n    return;\n  }\n\n  const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;\n\n  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {\n    if (desc && desc.sdp && desc.sdp.indexOf('\\na=extmap-allow-mixed') !== -1) {\n      const sdp = desc.sdp.split('\\n').filter(line => {\n        return line.trim() !== 'a=extmap-allow-mixed';\n      }).join('\\n'); // Safari enforces read-only-ness of RTCSessionDescription fields.\n\n      if (window.RTCSessionDescription && desc instanceof window.RTCSessionDescription) {\n        arguments[0] = new window.RTCSessionDescription({\n          type: desc.type,\n          sdp\n        });\n      } else {\n        desc.sdp = sdp;\n      }\n    }\n\n    return nativeSRD.apply(this, arguments);\n  };\n}\nfunction shimAddIceCandidateNullOrEmpty(window, browserDetails) {\n  // Support for addIceCandidate(null or undefined)\n  // as well as addIceCandidate({candidate: \"\", ...})\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n  // Note: must be called before other polyfills which change the signature.\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\n    return;\n  }\n\n  const nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;\n\n  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\n    return;\n  }\n\n  window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\n    if (!arguments[0]) {\n      if (arguments[1]) {\n        arguments[1].apply(null);\n      }\n\n      return Promise.resolve();\n    } // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n    // in older versions.\n    // Native support for ignoring exists for Chrome M77+.\n    // Safari ignores as well, exact version unknown but works in the same\n    // version that also ignores addIceCandidate(null).\n\n\n    if ((browserDetails.browser === 'chrome' && browserDetails.version < 78 || browserDetails.browser === 'firefox' && browserDetails.version < 68 || browserDetails.browser === 'safari') && arguments[0] && arguments[0].candidate === '') {\n      return Promise.resolve();\n    }\n\n    return nativeAddIceCandidate.apply(this, arguments);\n  };\n} // Note: Make sure to call this ahead of APIs that modify\n// setLocalDescription.length\n\nfunction shimParameterlessSetLocalDescription(window, browserDetails) {\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\n    return;\n  }\n\n  const nativeSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\n\n  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\n    return;\n  }\n\n  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    let desc = arguments[0] || {};\n\n    if (typeof desc !== 'object' || desc.type && desc.sdp) {\n      return nativeSetLocalDescription.apply(this, arguments);\n    } // The remaining steps should technically happen when SLD comes off the\n    // RTCPeerConnection's operations chain (not ahead of going on it), but\n    // this is too difficult to shim. Instead, this shim only covers the\n    // common case where the operations chain is empty. This is imperfect, but\n    // should cover many cases. Rationale: Even if we can't reduce the glare\n    // window to zero on imperfect implementations, there's value in tapping\n    // into the perfect negotiation pattern that several browsers support.\n\n\n    desc = {\n      type: desc.type,\n      sdp: desc.sdp\n    };\n\n    if (!desc.type) {\n      switch (this.signalingState) {\n        case 'stable':\n        case 'have-local-offer':\n        case 'have-remote-pranswer':\n          desc.type = 'offer';\n          break;\n\n        default:\n          desc.type = 'answer';\n          break;\n      }\n    }\n\n    if (desc.sdp || desc.type !== 'offer' && desc.type !== 'answer') {\n      return nativeSetLocalDescription.apply(this, [desc]);\n    }\n\n    const func = desc.type === 'offer' ? this.createOffer : this.createAnswer;\n    return func.apply(this).then(d => nativeSetLocalDescription.apply(this, [d]));\n  };\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/common_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js":
/*!********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"shimAddTransceiver\": () => (/* binding */ shimAddTransceiver),\n/* harmony export */   \"shimCreateAnswer\": () => (/* binding */ shimCreateAnswer),\n/* harmony export */   \"shimCreateOffer\": () => (/* binding */ shimCreateOffer),\n/* harmony export */   \"shimGetDisplayMedia\": () => (/* reexport safe */ _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__.shimGetDisplayMedia),\n/* harmony export */   \"shimGetParameters\": () => (/* binding */ shimGetParameters),\n/* harmony export */   \"shimGetUserMedia\": () => (/* reexport safe */ _getusermedia__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia),\n/* harmony export */   \"shimOnTrack\": () => (/* binding */ shimOnTrack),\n/* harmony export */   \"shimPeerConnection\": () => (/* binding */ shimPeerConnection),\n/* harmony export */   \"shimRTCDataChannel\": () => (/* binding */ shimRTCDataChannel),\n/* harmony export */   \"shimReceiverGetStats\": () => (/* binding */ shimReceiverGetStats),\n/* harmony export */   \"shimRemoveStream\": () => (/* binding */ shimRemoveStream),\n/* harmony export */   \"shimSenderGetStats\": () => (/* binding */ shimSenderGetStats)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/* harmony import */ var _getusermedia__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getusermedia */ \"./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js\");\n/* harmony import */ var _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getdisplaymedia */ \"./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n/* eslint-env node */\n\n\n\n\n\nfunction shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n\n    });\n  }\n}\nfunction shimPeerConnection(window, browserDetails) {\n  if (typeof window !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {\n    return; // probably media.peerconnection.enabled=false in about:config\n  }\n\n  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.mozRTCPeerConnection;\n  }\n\n  if (browserDetails.version < 53) {\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n      const nativeMethod = window.RTCPeerConnection.prototype[method];\n      const methodObj = {\n        [method]() {\n          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }\n\n      };\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n\n  const modernStatsTypes = {\n    inboundrtp: 'inbound-rtp',\n    outboundrtp: 'outbound-rtp',\n    candidatepair: 'candidate-pair',\n    localcandidate: 'local-candidate',\n    remotecandidate: 'remote-candidate'\n  };\n  const nativeGetStats = window.RTCPeerConnection.prototype.getStats;\n\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n    return nativeGetStats.apply(this, [selector || null]).then(stats => {\n      if (browserDetails.version < 53 && !onSucc) {\n        // Shim only promise getStats with spec-hyphens in type names\n        // Leave callback version alone; misc old uses of forEach before Map\n        try {\n          stats.forEach(stat => {\n            stat.type = modernStatsTypes[stat.type] || stat.type;\n          });\n        } catch (e) {\n          if (e.name !== 'TypeError') {\n            throw e;\n          } // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n\n\n          stats.forEach((stat, i) => {\n            stats.set(i, Object.assign({}, stat, {\n              type: modernStatsTypes[stat.type] || stat.type\n            }));\n          });\n        }\n      }\n\n      return stats;\n    }).then(onSucc, onErr);\n  };\n}\nfunction shimSenderGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {\n    return;\n  }\n\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {\n    return;\n  }\n\n  const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n\n  if (origGetSenders) {\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n  }\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n\n  if (origAddTrack) {\n    window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n      const sender = origAddTrack.apply(this, arguments);\n      sender._pc = this;\n      return sender;\n    };\n  }\n\n  window.RTCRtpSender.prototype.getStats = function getStats() {\n    return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());\n  };\n}\nfunction shimReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {\n    return;\n  }\n\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {\n    return;\n  }\n\n  const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n\n  if (origGetReceivers) {\n    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n      const receivers = origGetReceivers.apply(this, []);\n      receivers.forEach(receiver => receiver._pc = this);\n      return receivers;\n    };\n  }\n\n  _utils__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {\n    e.receiver._pc = e.srcElement;\n    return e;\n  });\n\n  window.RTCRtpReceiver.prototype.getStats = function getStats() {\n    return this._pc.getStats(this.track);\n  };\n}\nfunction shimRemoveStream(window) {\n  if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('removeStream', 'removeTrack');\n    this.getSenders().forEach(sender => {\n      if (sender.track && stream.getTracks().includes(sender.track)) {\n        this.removeTrack(sender);\n      }\n    });\n  };\n}\nfunction shimRTCDataChannel(window) {\n  // rename DataChannel to RTCDataChannel (native fix in FF60):\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n  if (window.DataChannel && !window.RTCDataChannel) {\n    window.RTCDataChannel = window.DataChannel;\n  }\n}\nfunction shimAddTransceiver(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n\n  const origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;\n\n  if (origAddTransceiver) {\n    window.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\n      this.setParametersPromises = [];\n      const initParameters = arguments[1];\n      const shouldPerformCheck = initParameters && 'sendEncodings' in initParameters;\n\n      if (shouldPerformCheck) {\n        // If sendEncodings params are provided, validate grammar\n        initParameters.sendEncodings.forEach(encodingParam => {\n          if ('rid' in encodingParam) {\n            const ridRegex = /^[a-z0-9]{0,16}$/i;\n\n            if (!ridRegex.test(encodingParam.rid)) {\n              throw new TypeError('Invalid RID value provided.');\n            }\n          }\n\n          if ('scaleResolutionDownBy' in encodingParam) {\n            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\n              throw new RangeError('scale_resolution_down_by must be >= 1.0');\n            }\n          }\n\n          if ('maxFramerate' in encodingParam) {\n            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n              throw new RangeError('max_framerate must be >= 0.0');\n            }\n          }\n        });\n      }\n\n      const transceiver = origAddTransceiver.apply(this, arguments);\n\n      if (shouldPerformCheck) {\n        // Check if the init options were applied. If not we do this in an\n        // asynchronous way and save the promise reference in a global object.\n        // This is an ugly hack, but at the same time is way more robust than\n        // checking the sender parameters before and after the createOffer\n        // Also note that after the createoffer we are not 100% sure that\n        // the params were asynchronously applied so we might miss the\n        // opportunity to recreate offer.\n        const {\n          sender\n        } = transceiver;\n        const params = sender.getParameters();\n\n        if (!('encodings' in params) || // Avoid being fooled by patched getParameters() below.\n        params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {\n          params.encodings = initParameters.sendEncodings;\n          sender.sendEncodings = initParameters.sendEncodings;\n          this.setParametersPromises.push(sender.setParameters(params).then(() => {\n            delete sender.sendEncodings;\n          }).catch(() => {\n            delete sender.sendEncodings;\n          }));\n        }\n      }\n\n      return transceiver;\n    };\n  }\n}\nfunction shimGetParameters(window) {\n  if (!(typeof window === 'object' && window.RTCRtpSender)) {\n    return;\n  }\n\n  const origGetParameters = window.RTCRtpSender.prototype.getParameters;\n\n  if (origGetParameters) {\n    window.RTCRtpSender.prototype.getParameters = function getParameters() {\n      const params = origGetParameters.apply(this, arguments);\n\n      if (!('encodings' in params)) {\n        params.encodings = [].concat(this.sendEncodings || [{}]);\n      }\n\n      return params;\n    };\n  }\n}\nfunction shimCreateOffer(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n\n  window.RTCPeerConnection.prototype.createOffer = function createOffer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises).then(() => {\n        return origCreateOffer.apply(this, arguments);\n      }).finally(() => {\n        this.setParametersPromises = [];\n      });\n    }\n\n    return origCreateOffer.apply(this, arguments);\n  };\n}\nfunction shimCreateAnswer(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n\n  const origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;\n\n  window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises).then(() => {\n        return origCreateAnswer.apply(this, arguments);\n      }).finally(() => {\n        this.setParametersPromises = [];\n      });\n    }\n\n    return origCreateAnswer.apply(this, arguments);\n  };\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js":
/*!***********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"shimGetDisplayMedia\": () => (/* binding */ shimGetDisplayMedia)\n/* harmony export */ });\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n/* eslint-env node */\n\n\nfunction shimGetDisplayMedia(window, preferredMediaSource) {\n  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n\n  if (!window.navigator.mediaDevices) {\n    return;\n  }\n\n  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n    if (!(constraints && constraints.video)) {\n      const err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');\n      err.name = 'NotFoundError'; // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n\n      err.code = 8;\n      return Promise.reject(err);\n    }\n\n    if (constraints.video === true) {\n      constraints.video = {\n        mediaSource: preferredMediaSource\n      };\n    } else {\n      constraints.video.mediaSource = preferredMediaSource;\n    }\n\n    return window.navigator.mediaDevices.getUserMedia(constraints);\n  };\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js":
/*!********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"shimGetUserMedia\": () => (/* binding */ shimGetUserMedia)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n/* eslint-env node */\n\n\n\nfunction shimGetUserMedia(window, browserDetails) {\n  const navigator = window && window.navigator;\n  const MediaStreamTrack = window && window.MediaStreamTrack;\n\n  navigator.getUserMedia = function (constraints, onSuccess, onError) {\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\n    _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n  };\n\n  if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\n    const remap = function (obj, a, b) {\n      if (a in obj && !(b in obj)) {\n        obj[b] = obj[a];\n        delete obj[a];\n      }\n    };\n\n    const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n\n    navigator.mediaDevices.getUserMedia = function (c) {\n      if (typeof c === 'object' && typeof c.audio === 'object') {\n        c = JSON.parse(JSON.stringify(c));\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\n      }\n\n      return nativeGetUserMedia(c);\n    };\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\n      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;\n\n      MediaStreamTrack.prototype.getSettings = function () {\n        const obj = nativeGetSettings.apply(this, arguments);\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\n        return obj;\n      };\n    }\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\n      const nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;\n\n      MediaStreamTrack.prototype.applyConstraints = function (c) {\n        if (this.kind === 'audio' && typeof c === 'object') {\n          c = JSON.parse(JSON.stringify(c));\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\n        }\n\n        return nativeApplyConstraints.apply(this, [c]);\n      };\n    }\n  }\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/safari/safari_shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/safari/safari_shim.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"shimAudioContext\": () => (/* binding */ shimAudioContext),\n/* harmony export */   \"shimCallbacksAPI\": () => (/* binding */ shimCallbacksAPI),\n/* harmony export */   \"shimConstraints\": () => (/* binding */ shimConstraints),\n/* harmony export */   \"shimCreateOfferLegacy\": () => (/* binding */ shimCreateOfferLegacy),\n/* harmony export */   \"shimGetUserMedia\": () => (/* binding */ shimGetUserMedia),\n/* harmony export */   \"shimLocalStreamsAPI\": () => (/* binding */ shimLocalStreamsAPI),\n/* harmony export */   \"shimRTCIceServerUrls\": () => (/* binding */ shimRTCIceServerUrls),\n/* harmony export */   \"shimRemoteStreamsAPI\": () => (/* binding */ shimRemoteStreamsAPI),\n/* harmony export */   \"shimTrackEventTransceiver\": () => (/* binding */ shimTrackEventTransceiver)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n\n\nfunction shimLocalStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n\n  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n\n      return this._localStreams;\n    };\n  }\n\n  if (!('addStream' in window.RTCPeerConnection.prototype)) {\n    const _addTrack = window.RTCPeerConnection.prototype.addTrack;\n\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n\n      if (!this._localStreams.includes(stream)) {\n        this._localStreams.push(stream);\n      } // Try to emulate Chrome's behaviour of adding in audio-video order.\n      // Safari orders by track id.\n\n\n      stream.getAudioTracks().forEach(track => _addTrack.call(this, track, stream));\n      stream.getVideoTracks().forEach(track => _addTrack.call(this, track, stream));\n    };\n\n    window.RTCPeerConnection.prototype.addTrack = function addTrack(track) {\n      for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        streams[_key - 1] = arguments[_key];\n      }\n\n      if (streams) {\n        streams.forEach(stream => {\n          if (!this._localStreams) {\n            this._localStreams = [stream];\n          } else if (!this._localStreams.includes(stream)) {\n            this._localStreams.push(stream);\n          }\n        });\n      }\n\n      return _addTrack.apply(this, arguments);\n    };\n  }\n\n  if (!('removeStream' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n\n      const index = this._localStreams.indexOf(stream);\n\n      if (index === -1) {\n        return;\n      }\n\n      this._localStreams.splice(index, 1);\n\n      const tracks = stream.getTracks();\n      this.getSenders().forEach(sender => {\n        if (tracks.includes(sender.track)) {\n          this.removeTrack(sender);\n        }\n      });\n    };\n  }\n}\nfunction shimRemoteStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n\n  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {\n      return this._remoteStreams ? this._remoteStreams : [];\n    };\n  }\n\n  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\n      get() {\n        return this._onaddstream;\n      },\n\n      set(f) {\n        if (this._onaddstream) {\n          this.removeEventListener('addstream', this._onaddstream);\n          this.removeEventListener('track', this._onaddstreampoly);\n        }\n\n        this.addEventListener('addstream', this._onaddstream = f);\n        this.addEventListener('track', this._onaddstreampoly = e => {\n          e.streams.forEach(stream => {\n            if (!this._remoteStreams) {\n              this._remoteStreams = [];\n            }\n\n            if (this._remoteStreams.includes(stream)) {\n              return;\n            }\n\n            this._remoteStreams.push(stream);\n\n            const event = new Event('addstream');\n            event.stream = stream;\n            this.dispatchEvent(event);\n          });\n        });\n      }\n\n    });\n    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      const pc = this;\n\n      if (!this._onaddstreampoly) {\n        this.addEventListener('track', this._onaddstreampoly = function (e) {\n          e.streams.forEach(stream => {\n            if (!pc._remoteStreams) {\n              pc._remoteStreams = [];\n            }\n\n            if (pc._remoteStreams.indexOf(stream) >= 0) {\n              return;\n            }\n\n            pc._remoteStreams.push(stream);\n\n            const event = new Event('addstream');\n            event.stream = stream;\n            pc.dispatchEvent(event);\n          });\n        });\n      }\n\n      return origSetRemoteDescription.apply(pc, arguments);\n    };\n  }\n}\nfunction shimCallbacksAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n\n  const prototype = window.RTCPeerConnection.prototype;\n  const origCreateOffer = prototype.createOffer;\n  const origCreateAnswer = prototype.createAnswer;\n  const setLocalDescription = prototype.setLocalDescription;\n  const setRemoteDescription = prototype.setRemoteDescription;\n  const addIceCandidate = prototype.addIceCandidate;\n\n  prototype.createOffer = function createOffer(successCallback, failureCallback) {\n    const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n    const promise = origCreateOffer.apply(this, [options]);\n\n    if (!failureCallback) {\n      return promise;\n    }\n\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n\n  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {\n    const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n    const promise = origCreateAnswer.apply(this, [options]);\n\n    if (!failureCallback) {\n      return promise;\n    }\n\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n\n  let withCallback = function (description, successCallback, failureCallback) {\n    const promise = setLocalDescription.apply(this, [description]);\n\n    if (!failureCallback) {\n      return promise;\n    }\n\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n\n  prototype.setLocalDescription = withCallback;\n\n  withCallback = function (description, successCallback, failureCallback) {\n    const promise = setRemoteDescription.apply(this, [description]);\n\n    if (!failureCallback) {\n      return promise;\n    }\n\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n\n  prototype.setRemoteDescription = withCallback;\n\n  withCallback = function (candidate, successCallback, failureCallback) {\n    const promise = addIceCandidate.apply(this, [candidate]);\n\n    if (!failureCallback) {\n      return promise;\n    }\n\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n\n  prototype.addIceCandidate = withCallback;\n}\nfunction shimGetUserMedia(window) {\n  const navigator = window && window.navigator;\n\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    // shim not needed in Safari 12.1\n    const mediaDevices = navigator.mediaDevices;\n\n    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n\n    navigator.mediaDevices.getUserMedia = constraints => {\n      return _getUserMedia(shimConstraints(constraints));\n    };\n  }\n\n  if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {\n      navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);\n    }.bind(navigator);\n  }\n}\nfunction shimConstraints(constraints) {\n  if (constraints && constraints.video !== undefined) {\n    return Object.assign({}, constraints, {\n      video: _utils__WEBPACK_IMPORTED_MODULE_0__.compactObject(constraints.video)\n    });\n  }\n\n  return constraints;\n}\nfunction shimRTCIceServerUrls(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  } // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n\n\n  const OrigPeerConnection = window.RTCPeerConnection;\n\n  window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {\n    if (pcConfig && pcConfig.iceServers) {\n      const newIceServers = [];\n\n      for (let i = 0; i < pcConfig.iceServers.length; i++) {\n        let server = pcConfig.iceServers[i];\n\n        if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {\n          _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n          server = JSON.parse(JSON.stringify(server));\n          server.urls = server.url;\n          delete server.url;\n          newIceServers.push(server);\n        } else {\n          newIceServers.push(pcConfig.iceServers[i]);\n        }\n      }\n\n      pcConfig.iceServers = newIceServers;\n    }\n\n    return new OrigPeerConnection(pcConfig, pcConstraints);\n  };\n\n  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype; // wrap static methods. Currently just generateCertificate.\n\n  if ('generateCertificate' in OrigPeerConnection) {\n    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n      get() {\n        return OrigPeerConnection.generateCertificate;\n      }\n\n    });\n  }\n}\nfunction shimTrackEventTransceiver(window) {\n  // Add event.transceiver member over deprecated event.receiver\n  if (typeof window === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n\n    });\n  }\n}\nfunction shimCreateOfferLegacy(window) {\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n\n  window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {\n    if (offerOptions) {\n      if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n        // support bit values\n        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n      }\n\n      const audioTransceiver = this.getTransceivers().find(transceiver => transceiver.receiver.track.kind === 'audio');\n\n      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n        if (audioTransceiver.direction === 'sendrecv') {\n          if (audioTransceiver.setDirection) {\n            audioTransceiver.setDirection('sendonly');\n          } else {\n            audioTransceiver.direction = 'sendonly';\n          }\n        } else if (audioTransceiver.direction === 'recvonly') {\n          if (audioTransceiver.setDirection) {\n            audioTransceiver.setDirection('inactive');\n          } else {\n            audioTransceiver.direction = 'inactive';\n          }\n        }\n      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\n        this.addTransceiver('audio', {\n          direction: 'recvonly'\n        });\n      }\n\n      if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {\n        // support bit values\n        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n      }\n\n      const videoTransceiver = this.getTransceivers().find(transceiver => transceiver.receiver.track.kind === 'video');\n\n      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n        if (videoTransceiver.direction === 'sendrecv') {\n          if (videoTransceiver.setDirection) {\n            videoTransceiver.setDirection('sendonly');\n          } else {\n            videoTransceiver.direction = 'sendonly';\n          }\n        } else if (videoTransceiver.direction === 'recvonly') {\n          if (videoTransceiver.setDirection) {\n            videoTransceiver.setDirection('inactive');\n          } else {\n            videoTransceiver.direction = 'inactive';\n          }\n        }\n      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\n        this.addTransceiver('video', {\n          direction: 'recvonly'\n        });\n      }\n    }\n\n    return origCreateOffer.apply(this, arguments);\n  };\n}\nfunction shimAudioContext(window) {\n  if (typeof window !== 'object' || window.AudioContext) {\n    return;\n  }\n\n  window.AudioContext = window.webkitAudioContext;\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/safari/safari_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"compactObject\": () => (/* binding */ compactObject),\n/* harmony export */   \"deprecated\": () => (/* binding */ deprecated),\n/* harmony export */   \"detectBrowser\": () => (/* binding */ detectBrowser),\n/* harmony export */   \"disableLog\": () => (/* binding */ disableLog),\n/* harmony export */   \"disableWarnings\": () => (/* binding */ disableWarnings),\n/* harmony export */   \"extractVersion\": () => (/* binding */ extractVersion),\n/* harmony export */   \"filterStats\": () => (/* binding */ filterStats),\n/* harmony export */   \"log\": () => (/* binding */ log),\n/* harmony export */   \"walkStats\": () => (/* binding */ walkStats),\n/* harmony export */   \"wrapPeerConnectionEvent\": () => (/* binding */ wrapPeerConnectionEvent)\n/* harmony export */ });\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n/* eslint-env node */\n\n\nlet logDisabled_ = true;\nlet deprecationWarnings_ = true;\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */\n\nfunction extractVersion(uastring, expr, pos) {\n  const match = uastring.match(expr);\n  return match && match.length >= pos && parseInt(match[pos], 10);\n} // Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\n\nfunction wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  const proto = window.RTCPeerConnection.prototype;\n  const nativeAddEventListener = proto.addEventListener;\n\n  proto.addEventListener = function (nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap) {\n      return nativeAddEventListener.apply(this, arguments);\n    }\n\n    const wrappedCallback = e => {\n      const modifiedEvent = wrapper(e);\n\n      if (modifiedEvent) {\n        if (cb.handleEvent) {\n          cb.handleEvent(modifiedEvent);\n        } else {\n          cb(modifiedEvent);\n        }\n      }\n    };\n\n    this._eventMap = this._eventMap || {};\n\n    if (!this._eventMap[eventNameToWrap]) {\n      this._eventMap[eventNameToWrap] = new Map();\n    }\n\n    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n\n    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);\n  };\n\n  const nativeRemoveEventListener = proto.removeEventListener;\n\n  proto.removeEventListener = function (nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n\n    if (!this._eventMap[eventNameToWrap].has(cb)) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n\n    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n\n    this._eventMap[eventNameToWrap].delete(cb);\n\n    if (this._eventMap[eventNameToWrap].size === 0) {\n      delete this._eventMap[eventNameToWrap];\n    }\n\n    if (Object.keys(this._eventMap).length === 0) {\n      delete this._eventMap;\n    }\n\n    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);\n  };\n\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\n    get() {\n      return this['_on' + eventNameToWrap];\n    },\n\n    set(cb) {\n      if (this['_on' + eventNameToWrap]) {\n        this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);\n        delete this['_on' + eventNameToWrap];\n      }\n\n      if (cb) {\n        this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);\n      }\n    },\n\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction disableLog(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\n  }\n\n  logDisabled_ = bool;\n  return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';\n}\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */\n\nfunction disableWarnings(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\n  }\n\n  deprecationWarnings_ = !bool;\n  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n}\nfunction log() {\n  if (typeof window === 'object') {\n    if (logDisabled_) {\n      return;\n    }\n\n    if (typeof console !== 'undefined' && typeof console.log === 'function') {\n      console.log.apply(console, arguments);\n    }\n  }\n}\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */\n\nfunction deprecated(oldMethod, newMethod) {\n  if (!deprecationWarnings_) {\n    return;\n  }\n\n  console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');\n}\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */\n\nfunction detectBrowser(window) {\n  // Returned result object.\n  const result = {\n    browser: null,\n    version: null\n  }; // Fail early if it's not a browser\n\n  if (typeof window === 'undefined' || !window.navigator) {\n    result.browser = 'Not a browser.';\n    return result;\n  }\n\n  const {\n    navigator\n  } = window;\n\n  if (navigator.mozGetUserMedia) {\n    // Firefox.\n    result.browser = 'firefox';\n    result.version = extractVersion(navigator.userAgent, /Firefox\\/(\\d+)\\./, 1);\n  } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection && !window.RTCIceGatherer) {\n    // Chrome, Chromium, Webview, Opera.\n    // Version matches Chrome/WebRTC version.\n    // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n    // more complicated fallback to webkitRTCPeerConnection.\n    result.browser = 'chrome';\n    result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n  } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n    // Safari.\n    result.browser = 'safari';\n    result.version = extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n    result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;\n  } else {\n    // Default fallthrough: not supported.\n    result.browser = 'Not a supported browser.';\n    return result;\n  }\n\n  return result;\n}\n/**\n * Checks if something is an object.\n *\n * @param {*} val The something you want to check.\n * @return true if val is an object, false otherwise.\n */\n\nfunction isObject(val) {\n  return Object.prototype.toString.call(val) === '[object Object]';\n}\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash's `compact`.\n */\n\n\nfunction compactObject(data) {\n  if (!isObject(data)) {\n    return data;\n  }\n\n  return Object.keys(data).reduce(function (accumulator, key) {\n    const isObj = isObject(data[key]);\n    const value = isObj ? compactObject(data[key]) : data[key];\n    const isEmptyObject = isObj && !Object.keys(value).length;\n\n    if (value === undefined || isEmptyObject) {\n      return accumulator;\n    }\n\n    return Object.assign(accumulator, {\n      [key]: value\n    });\n  }, {});\n}\n/* iterates the stats graph recursively. */\n\nfunction walkStats(stats, base, resultSet) {\n  if (!base || resultSet.has(base.id)) {\n    return;\n  }\n\n  resultSet.set(base.id, base);\n  Object.keys(base).forEach(name => {\n    if (name.endsWith('Id')) {\n      walkStats(stats, stats.get(base[name]), resultSet);\n    } else if (name.endsWith('Ids')) {\n      base[name].forEach(id => {\n        walkStats(stats, stats.get(id), resultSet);\n      });\n    }\n  });\n}\n/* filter getStats for a sender/receiver track. */\n\nfunction filterStats(result, track, outbound) {\n  const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\n  const filteredResult = new Map();\n\n  if (track === null) {\n    return filteredResult;\n  }\n\n  const trackStats = [];\n  result.forEach(value => {\n    if (value.type === 'track' && value.trackIdentifier === track.id) {\n      trackStats.push(value);\n    }\n  });\n  trackStats.forEach(trackStat => {\n    result.forEach(stats => {\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n        walkStats(result, stats, filteredResult);\n      }\n    });\n  });\n  return filteredResult;\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/utils.js?");

/***/ }),

/***/ "./src/rtsp-to-web-player.js":
/*!***********************************!*\
  !*** ./src/rtsp-to-web-player.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RTSPtoWEBPlayer)\n/* harmony export */ });\n/* harmony import */ var webrtc_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webrtc-adapter */ \"./node_modules/webrtc-adapter/src/js/adapter_core.js\");\n/* harmony import */ var hls_js_dist_hls_light_min_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hls.js/dist/hls.light.min.js */ \"./node_modules/hls.js/dist/hls.light.min.js\");\n/* harmony import */ var hls_js_dist_hls_light_min_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(hls_js_dist_hls_light_min_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _rtsp_to_web_player_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rtsp-to-web-player.css */ \"./src/rtsp-to-web-player.css\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nclass RTSPtoWEBPlayer {\n  constructor(options) {\n    var _this = this;\n\n    _defineProperty(this, \"MSE\", null);\n\n    _defineProperty(this, \"MSEStreamingStarted\", false);\n\n    _defineProperty(this, \"MSESourceBuffer\", null);\n\n    _defineProperty(this, \"turn\", []);\n\n    _defineProperty(this, \"codec\", null);\n\n    _defineProperty(this, \"webSocket\", null);\n\n    _defineProperty(this, \"webrtc\", null);\n\n    _defineProperty(this, \"webRtcSocket\", null);\n\n    _defineProperty(this, \"currentPlayerType\", null);\n\n    _defineProperty(this, \"hidden\", \"hidden\");\n\n    _defineProperty(this, \"paused\", false);\n\n    _defineProperty(this, \"presets\", null);\n\n    _defineProperty(this, \"audio_tracks\", null);\n\n    _defineProperty(this, \"switchFlag\", false);\n\n    _defineProperty(this, \"options\", {\n      parentElement: null,\n      source: null,\n      controls: true,\n      muted: true,\n      autoplay: true,\n      loop: false,\n      hlsjsconfig: {},\n      webrtcconfig: {\n        iceServers: [{\n          urls: [\"stun:stun.l.google.com:19302\"]\n        }],\n        sdpSemantics: \"unified-plan\",\n        bundlePolicy: \"max-compat\" //iceTransportPolicy: \"relay\",//for option \"relay\" need use  turn server\n\n      },\n      debug: false,\n      getPresets: null,\n      onResolutionChange: null,\n      latency: null\n    });\n\n    _defineProperty(this, \"createElements\", () => {\n      //video\n      this.video = document.createElement(\"video\");\n      this.video.setAttribute('playsinline', '');\n      this.video.muted = this.options.muted ? true : false;\n      this.video.controls = this.options.controls ? true : false;\n      this.video.autoplay = this.options.autoplay ? true : false;\n      this.video.loop = this.options.loop ? true : false;\n      this.addVideoListeners(); //wrapper\n\n      this.player = document.createElement(\"div\");\n      this.player.classList.add('RTSPtoWEBPlayer');\n      this.player.append(this.video);\n    });\n\n    _defineProperty(this, \"attachTo\", element => {\n      this.options.parentElement = element;\n      this.options.parentElement.innerHTML = \"\";\n      this.options.parentElement.append(this.player);\n\n      if (this.options.source) {\n        this.load(this.options.source);\n      }\n    });\n\n    _defineProperty(this, \"load\", source => {\n      this.options.source = source;\n      this.destroy();\n      const sourceType = new URL(this.options.source);\n\n      if (sourceType.protocol === 'http:' || sourceType.protocol === 'https:') {\n        if (this.options.source.indexOf('m3u8') !== -1) {\n          this.currentPlayerType = \"hls\";\n          this.hlsPlayer();\n        } else if (this.options.source.indexOf('.mp4') !== -1) {\n          this.currentPlayerType = \"mp4\";\n          this.mp4Player();\n        } else {\n          this.currentPlayerType = \"rtc\";\n          this.webRtcPlayer();\n        }\n      } else if (sourceType.protocol === 'ws:' || sourceType.protocol === 'wss:') {\n        if (this.options.source.indexOf('webrtc') !== -1) {\n          this.currentPlayerType = \"ws-rtc\";\n          this.webRtcOverSocket();\n        } // else if (this.options.source.indexOf('on-air') !== -1 || this.options.source.indexOf('preview')!== -1) {\n        //     this.currentPlayerType = \"ws-new\";\n        //     this.newMsePlayer();\n        //\n        // }\n        else {\n          this.currentPlayerType = \"ws\";\n          this.msePlayer();\n        }\n      } else {\n        this.currentPlayerType = null;\n      }\n    });\n\n    _defineProperty(this, \"newMsePlayer\", () => {\n      this.webSocket = new WebSocket(this.options.source);\n\n      this.webSocket.onopen = () => {//console.log('opened')\n      };\n\n      this.webSocket.onclose = e => {\n        console.log(e);\n      };\n\n      this.webSocket.onmessage = _ref => {\n        let {\n          data\n        } = _ref;\n        this.messageHandler(data);\n      };\n    });\n\n    _defineProperty(this, \"webRtcOverSocket\", () => {\n      this.webRtcSocket = new WebSocket(this.options.source);\n\n      this.webRtcSocket.onopen = () => {\n        this.webRtcPlayer();\n      };\n\n      this.webRtcSocket.onclose = () => {\n        this.webRtcSocket.onmessage = null;\n      };\n\n      this.webRtcSocket.onerror = () => {};\n\n      this.webRtcSocket.onmessage = _ref2 => {\n        let {\n          data\n        } = _ref2;\n        this.webRtcSocketMessageHanler(data);\n      };\n    });\n\n    _defineProperty(this, \"webRtcSocketMessageHanler\", data => {\n      data = JSON.parse(data);\n\n      if (data.candidate) {\n        //console.log('candidate',data.candidate);\n        this.webrtc.addIceCandidate(data);\n      } else {\n        this.webrtc.setRemoteDescription(new RTCSessionDescription(data));\n      }\n    });\n\n    _defineProperty(this, \"messageHandler\", data => {\n      if (typeof data === 'string') {\n        try {\n          data = JSON.parse(data);\n\n          if (data.method === 'play_response') {\n            this.presets = data.payload.streams;\n\n            if (typeof this.options.getPresets === 'function') {\n              this.options.getPresets(this.presets, data.payload.audio_tracks);\n            }\n\n            const default_video = data.payload.streams.filter(item => {\n              return item.default;\n            })[0].idx;\n            const default_audio = data.payload.audio_tracks.filter(item => {\n              return item.default;\n            })[0].idx;\n            this.playPreset(default_video, default_audio);\n          }\n        } catch (e) {\n          console.log(e);\n        }\n      } else if (typeof data === 'object') {\n        data.arrayBuffer().then(packet => {\n          this.readPacket(packet);\n        }); //\n      }\n    });\n\n    _defineProperty(this, \"getPresets\", () => {\n      return this.presets;\n    });\n\n    _defineProperty(this, \"playPreset\", (videoIdx, audioIdx) => {\n      this.codec = this.presets.filter(item => item.idx === videoIdx)[0].codecs;\n      const answer = JSON.stringify({\n        method: 'play',\n        payload: {\n          variant_id: videoIdx,\n          audio_track_id: audioIdx\n        }\n      });\n      this.MSE = new MediaSource();\n      this.video.src = window.URL.createObjectURL(this.MSE);\n      this.MSE.addEventListener('sourceopen', () => {\n        this.MSESourceBuffer = this.MSE.addSourceBuffer(\"video/mp4; codecs=\\\"\".concat(this.codec, \"\\\"\"));\n        this.MSESourceBuffer.mode = \"segments\";\n        this.MSESourceBuffer.addEventListener(\"updateend\", this.pushPacket);\n        this.webSocket.send(answer);\n      });\n    });\n\n    _defineProperty(this, \"switchStream\", index => {\n      this.codec = this.presets[index].codecs;\n      this.webSocket.send(JSON.stringify({\n        method: 'stop'\n      }));\n      this.switchFlag = true;\n      this.webSocket.send(JSON.stringify({\n        method: 'play',\n        payload: {\n          variant_id: this.presets[index].idx\n        }\n      }));\n      this.MSESourceBuffer.timestampOffset = this.MSESourceBuffer.appendWindowStart = this.MSESourceBuffer.buffered.end(this.MSESourceBuffer.buffered.length - 1);\n    });\n\n    _defineProperty(this, \"switchAudio\", idx => {\n      this.webSocket.send(JSON.stringify({\n        method: 'set_audio_track',\n        payload: {\n          audio_track_id: idx\n        }\n      }));\n      this.video.currentTime += 0.01;\n    });\n\n    _defineProperty(this, \"addMseListeners\", () => {\n      this.MSE.addEventListener('sourceopen', this.sourceOpenHandler);\n    });\n\n    _defineProperty(this, \"sourceOpenHandler\", () => {\n      this.websocketEvents();\n    });\n\n    _defineProperty(this, \"websocketEvents\", () => {\n      this.webSocket = new WebSocket(this.options.source);\n      this.webSocket.binaryType = \"arraybuffer\";\n\n      this.webSocket.onclose = () => {\n        this.webSocket.onmessage = null;\n      };\n\n      this.webSocket.onmessage = _ref3 => {\n        let {\n          data\n        } = _ref3;\n\n        if (this.codec === null) {\n          if (typeof data === \"object\") {\n            this.codec = new TextDecoder(\"utf-8\").decode(new Uint8Array(data).slice(1));\n          } else {\n            this.codec = data;\n          }\n\n          this.MSESourceBuffer = this.MSE.addSourceBuffer(\"video/mp4; codecs=\\\"\".concat(this.codec, \"\\\"\"));\n          this.MSESourceBuffer.mode = \"segments\";\n          this.MSESourceBuffer.addEventListener(\"updateend\", this.pushPacket);\n        } else {\n          if (!this.paused) {\n            this.readPacket(data);\n          }\n        }\n\n        if (document[this.hidden] && this.video.buffered.length) {\n          this.video.currentTime = this.video.buffered.end(this.video.buffered.length - 1) - 1;\n        }\n      };\n    });\n\n    _defineProperty(this, \"readPacket\", packet => {\n      if (this.video.buffered && this.video.currentTime > 0) {\n        if (typeof this.options.latency === 'function') {\n          this.options.latency(this.video.buffered.length, this.video.buffered.end(this.video.buffered.length - 1), this.video.currentTime);\n        }\n\n        if (this.video.currentTime < this.video.buffered.start(this.video.buffered.length - 1)) {\n          this.video.currentTime = this.video.buffered.end(this.video.buffered.length - 1);\n        }\n      }\n\n      if (!this.MSEStreamingStarted) {\n        try {\n          this.MSESourceBuffer.appendBuffer(packet);\n          this.MSEStreamingStarted = true;\n        } catch (e) {\n          console.log(e);\n        }\n\n        return;\n      }\n\n      this.turn.push(packet);\n      this.pushPacket();\n    });\n\n    _defineProperty(this, \"pushPacket\", () => {\n      if (!this.MSESourceBuffer.updating) {\n        if (this.turn.length > 0) {\n          const packet = this.turn.shift();\n\n          try {\n            this.MSESourceBuffer.appendBuffer(packet);\n          } catch (err) {\n            this.debugLogger(err);\n          }\n        } else {\n          this.MSEStreamingStarted = false;\n        }\n      }\n    });\n\n    _defineProperty(this, \"mp4Player\", () => {\n      this.video.src = this.options.source;\n    });\n\n    _defineProperty(this, \"msePlayer\", () => {\n      this.MSE = new MediaSource();\n      this.video.src = window.URL.createObjectURL(this.MSE);\n      this.addMseListeners();\n    });\n\n    _defineProperty(this, \"hlsPlayer\", () => {\n      if (this.video.canPlayType('application/vnd.apple.mpegurl')) {\n        this.video.src = this.options.source;\n      } else if (hls_js_dist_hls_light_min_js__WEBPACK_IMPORTED_MODULE_1___default().isSupported()) {\n        this.hls = new (hls_js_dist_hls_light_min_js__WEBPACK_IMPORTED_MODULE_1___default())(this.options.hlsjsconfig);\n        this.hls.loadSource(this.options.source);\n        this.hls.attachMedia(this.video);\n      } else {\n        console.warn('UNSUPPOERED MEDIA SOURCE');\n      }\n    });\n\n    _defineProperty(this, \"webRtcPlayer\", async () => {\n      this.mediaStream = new MediaStream();\n      this.video.srcObject = this.mediaStream;\n      this.webrtc = new RTCPeerConnection(this.options.webrtcconfig);\n      this.webrtc.onnegotiationneeded = this.handleNegotiationNeeded;\n      this.webrtc.onsignalingstatechange = this.signalingstatechange;\n      this.webrtc.onicegatheringstatechange = this.icegatheringstatechange;\n      this.webrtc.onicecandidate = this.icecandidate;\n      this.webrtc.onicecandidateerror = this.icecandidateerror;\n      this.webrtc.onconnectionstatechange = this.connectionstatechange;\n      this.webrtc.oniceconnectionstatechange = this.iceconnectionstatechange;\n      this.webrtc.ontrack = this.onTrack;\n      const offer = await this.webrtc.createOffer({\n        //iceRestart:true,\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: true\n      });\n      await this.webrtc.setLocalDescription(offer);\n    });\n\n    _defineProperty(this, \"handleNegotiationNeeded\", async () => {\n      /*\n      * in this project this handler is not needed, but in another it can be useful\n      */\n      this.debugLogger('handleNegotiationNeeded');\n    });\n\n    _defineProperty(this, \"signalingstatechange\", async () => {\n      switch (this.webrtc.signalingState) {\n        case 'have-local-offer':\n          if (this.webRtcSocket) {\n            this.webRtcSocket.send(JSON.stringify(this.webrtc.localDescription));\n          } else {\n            const suuid = new URL(this.options.source).pathname.split('/').slice(-1);\n            const formData = new FormData();\n            formData.append('data', btoa(this.webrtc.localDescription.sdp));\n            formData.append('suuid', suuid);\n            const response = await fetch(this.options.source, {\n              method: 'POST',\n              body: formData\n            });\n\n            if (response.ok) {\n              const remoteDescription = await response.text();\n              this.webrtc.setRemoteDescription(new RTCSessionDescription({\n                type: 'answer',\n                sdp: atob(remoteDescription)\n              }));\n            }\n          }\n\n          break;\n\n        case 'stable':\n          /*\n          * There is no ongoing exchange of offer and answer underway.\n          * This may mean that the RTCPeerConnection object is new, in which case both the localDescription and remoteDescription are null;\n          * it may also mean that negotiation is complete and a connection has been established.\n          */\n          break;\n\n        case 'closed':\n          /*\n           * The RTCPeerConnection has been closed.\n           */\n          this.destroy();\n          break;\n\n        default:\n          console.log(\"unhandled signalingState is \".concat(this.webrtc.signalingState));\n          break;\n      }\n    });\n\n    _defineProperty(this, \"icegatheringstatechange\", () => {\n      switch (this.webrtc.iceGatheringState) {\n        case \"gathering\":\n          /* collection of candidates has begun */\n          this.debugLogger('collection of candidates has begun');\n          break;\n\n        case \"complete\":\n          /* collection of candidates is finished */\n          this.debugLogger('collection of candidates is finished');\n          break;\n      }\n    });\n\n    _defineProperty(this, \"icecandidate\", event => {\n      this.debugLogger('icecandidate\\n', event);\n\n      if (this.webRtcSocket) {\n        if (event.candidate && event.candidate.candidate !== \"\") {\n          this.webRtcSocket.send(JSON.stringify(event.candidate));\n        }\n      }\n    });\n\n    _defineProperty(this, \"icecandidateerror\", event => {\n      this.debugLogger('icecandidateerror\\n', \"hostCandidate: \".concat(event.hostCandidate, \" CODE: \").concat(event.errorCode, \" TEXT: \").concat(event.errorText));\n    });\n\n    _defineProperty(this, \"connectionstatechange\", () => {\n      switch (this.webrtc.connectionState) {\n        case \"new\":\n        case \"connected\":\n          this.debugLogger(\"connected\");\n          break;\n\n        case \"disconnected\":\n          this.debugLogger(\"disconnected...\");\n          break;\n\n        case \"closed\":\n          this.debugLogger(\"Offline\");\n          break;\n\n        case \"failed\":\n          this.debugLogger(\"Error\");\n          break;\n\n        default:\n          this.debugLogger(\"Unhadled state: \".concat(this.webrtc.connectionState));\n          break;\n      }\n    });\n\n    _defineProperty(this, \"iceconnectionstatechange\", () => {\n      this.debugLogger('iceconnectionstatechange\\n', this.webrtc.iceConnectionState);\n    });\n\n    _defineProperty(this, \"onTrack\", event => {\n      this.debugLogger('onTrack\\n', this.webrtc.iceConnectionState);\n      this.mediaStream.addTrack(event.track);\n    });\n\n    _defineProperty(this, \"destroy\", () => {\n      this.codec = null;\n      this.presets = null;\n      this.audio_tracks = null;\n\n      if (this.currentPlayerType != null) {\n        switch (this.currentPlayerType) {\n          case 'hls':\n            if (this.hls != null) {\n              this.hls.destroy();\n            }\n\n            break;\n\n          case 'rtc':\n            if (this.webrtc != null) {\n              this.webrtc.close();\n              this.webrtc = null;\n              this.video.srcObject = null;\n              this.mediaStream = null;\n            }\n\n            break;\n\n          case 'ws':\n          case 'ws-new':\n            this.webSocket.onerror = null;\n            this.webSocket.onopen = null;\n            this.webSocket.onmessage = null;\n            this.webSocket.onclose = null;\n            this.webSocket.close(1000);\n            this.turn = [];\n            break;\n\n          case 'ws-rtc':\n            this.webRtcSocket.onerror = null;\n            this.webRtcSocket.onopen = null;\n            this.webRtcSocket.onmessage = null;\n            this.webRtcSocket.onclose = null;\n            this.webRtcSocket.close(1000);\n            this.turn = [];\n\n            if (this.webrtc != null) {\n              this.webrtc.close();\n              this.webrtc = null;\n              this.video.srcObject = null;\n              this.mediaStream = null;\n            }\n\n            break;\n\n          default:\n        }\n\n        this.video.pause();\n        this.video.removeAttribute('src'); // empty source\n\n        this.video.load();\n      }\n    });\n\n    _defineProperty(this, \"addVideoListeners\", () => {\n      this.video.addEventListener('error', e => {\n        this.debugLogger('[ video listener ]', e);\n        this.destroy();\n      });\n      this.video.addEventListener('play', () => {\n        this.paused = false;\n      });\n      this.video.addEventListener('pause', () => {\n        this.paused = true;\n      });\n      this.video.addEventListener('resize', () => {\n        if (typeof this.options.onResolutionChange === 'function') {\n          this.options.onResolutionChange(this.video.videoWidth, this.video.videoHeight);\n        }\n      });\n      this.video.addEventListener('progress', () => {\n        if (this.currentPlayerType === 'ws' && this.video.buffered.length > 0) {\n          if (this.video.currentTime < this.video.buffered.start(this.video.buffered.length - 1)) {\n            this.video.currentTime = this.video.buffered.end(this.video.buffered.length - 1) - 1;\n          }\n        }\n      });\n    });\n\n    _defineProperty(this, \"getImageBase64\", () => {\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = this.video.videoWidth;\n      canvas.height = this.video.videoHeight;\n      canvas.getContext('2d').drawImage(this.video, 0, 0, canvas.width, canvas.height);\n      const dataURL = canvas.toDataURL();\n      canvas.remove();\n      return dataURL;\n    });\n\n    _defineProperty(this, \"debugLogger\", function () {\n      if (_this.options.debug) {\n        for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {\n          arg[_key] = arguments[_key];\n        }\n\n        if (_this.options.debug === 'trace') {\n          console.trace(...arg);\n        } else {\n          const d = new Date();\n          console.log(d.toLocaleTimeString() + \".\".concat(d.getMilliseconds()), ...arg);\n        }\n      }\n    });\n\n    this.options = _objectSpread(_objectSpread({}, this.options), options);\n    this.createElements();\n\n    if (this.options.parentElement) {\n      this.attachTo(this.options.parentElement);\n    }\n\n    this.defDocumentHidden();\n  }\n\n  defDocumentHidden() {\n    if (typeof document.hidden !== \"undefined\") {\n      this.hidden = \"hidden\";\n    } else if (typeof document.msHidden !== \"undefined\") {\n      this.hidden = \"msHidden\";\n    } else if (typeof document.webkitHidden !== \"undefined\") {\n      this.hidden = \"webkitHidden\";\n    }\n  }\n\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./src/rtsp-to-web-player.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/rtsp-to-web-player.css":
/*!**************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/rtsp-to-web-player.css ***!
  \**************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".RTSPtoWEBPlayer{\\n    width: 100%;\\n    height: 100%;\\n}\\n.RTSPtoWEBPlayer video{\\n    width: 100%;\\n    height: 100%;\\n    background: black;\\n}\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://rtsptowebplayer/./src/rtsp-to-web-player.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./src/rtsp-to-web-player.css":
/*!************************************!*\
  !*** ./src/rtsp-to-web-player.css ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_rtsp_to_web_player_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./rtsp-to-web-player.css */ \"./node_modules/css-loader/dist/cjs.js!./src/rtsp-to-web-player.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_rtsp_to_web_player_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_rtsp_to_web_player_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"].locals || {});\n\n//# sourceURL=webpack://rtsptowebplayer/./src/rtsp-to-web-player.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : 0;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/rtsp-to-web-player.js");
/******/ 	RTSPtoWEBPlayer = __webpack_exports__["default"];
/******/ 	
/******/ })()
;