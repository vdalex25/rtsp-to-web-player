/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var RTSPtoWEBPlayer;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/hls.js/dist/hls.light.min.js":
/*!***************************************************!*\
  !*** ./node_modules/hls.js/dist/hls.light.min.js ***!
  \***************************************************/
/***/ ((module) => {

eval("!function e(t) {\n  var r, i;\n  r = this, i = function () {\n    \"use strict\";\n\n    function r(e, t) {\n      var r = Object.keys(e);\n      if (Object.getOwnPropertySymbols) {\n        var i = Object.getOwnPropertySymbols(e);\n        t && (i = i.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), r.push.apply(r, i);\n      }\n      return r;\n    }\n    function i(e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var i = null != arguments[t] ? arguments[t] : {};\n        t % 2 ? r(Object(i), !0).forEach(function (t) {\n          var r, n, s;\n          r = e, n = t, s = i[t], (n = a(n)) in r ? Object.defineProperty(r, n, {\n            value: s,\n            enumerable: !0,\n            configurable: !0,\n            writable: !0\n          }) : r[n] = s;\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : r(Object(i)).forEach(function (t) {\n          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n        });\n      }\n      return e;\n    }\n    function a(e) {\n      var t = function (e, t) {\n        if (\"object\" != typeof e || !e) return e;\n        var r = e[Symbol.toPrimitive];\n        if (void 0 !== r) {\n          var i = r.call(e, t || \"default\");\n          if (\"object\" != typeof i) return i;\n          throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return (\"string\" === t ? String : Number)(e);\n      }(e, \"string\");\n      return \"symbol\" == typeof t ? t : String(t);\n    }\n    function n(e, t) {\n      for (var r = 0; r < t.length; r++) {\n        var i = t[r];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, a(i.key), i);\n      }\n    }\n    function s(e, t, r) {\n      return t && n(e.prototype, t), r && n(e, r), Object.defineProperty(e, \"prototype\", {\n        writable: !1\n      }), e;\n    }\n    function o() {\n      return o = Object.assign ? Object.assign.bind() : function (e) {\n        for (var t = 1; t < arguments.length; t++) {\n          var r = arguments[t];\n          for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);\n        }\n        return e;\n      }, o.apply(this, arguments);\n    }\n    function l(e, t) {\n      e.prototype = Object.create(t.prototype), e.prototype.constructor = e, d(e, t);\n    }\n    function u(e) {\n      return u = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e) {\n        return e.__proto__ || Object.getPrototypeOf(e);\n      }, u(e);\n    }\n    function d(e, t) {\n      return d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {\n        return e.__proto__ = t, e;\n      }, d(e, t);\n    }\n    function h(e, t, r) {\n      return h = function () {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n        if (Reflect.construct.sham) return !1;\n        if (\"function\" == typeof Proxy) return !0;\n        try {\n          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n        } catch (e) {\n          return !1;\n        }\n      }() ? Reflect.construct.bind() : function (e, t, r) {\n        var i = [null];\n        i.push.apply(i, t);\n        var a = new (Function.bind.apply(e, i))();\n        return r && d(a, r.prototype), a;\n      }, h.apply(null, arguments);\n    }\n    function f(e) {\n      var t = \"function\" == typeof Map ? new Map() : void 0;\n      return f = function (e) {\n        if (null === e || !function (e) {\n          try {\n            return -1 !== Function.toString.call(e).indexOf(\"[native code]\");\n          } catch (t) {\n            return \"function\" == typeof e;\n          }\n        }(e)) return e;\n        if (\"function\" != typeof e) throw new TypeError(\"Super expression must either be null or a function\");\n        if (void 0 !== t) {\n          if (t.has(e)) return t.get(e);\n          t.set(e, r);\n        }\n        function r() {\n          return h(e, arguments, u(this).constructor);\n        }\n        return r.prototype = Object.create(e.prototype, {\n          constructor: {\n            value: r,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), d(r, e);\n      }, f(e);\n    }\n    function c(e) {\n      return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n    }\n    var v = {\n      exports: {}\n    };\n    !function (e, t) {\n      var r, i, a, n, s;\n      r = /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/, i = /^(?=([^\\/?#]*))\\1([^]*)$/, a = /(?:\\/|^)\\.(?=\\/)/g, n = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g, s = {\n        buildAbsoluteURL: function (e, t, r) {\n          if (r = r || {}, e = e.trim(), !(t = t.trim())) {\n            if (!r.alwaysNormalize) return e;\n            var a = s.parseURL(e);\n            if (!a) throw new Error(\"Error trying to parse base URL.\");\n            return a.path = s.normalizePath(a.path), s.buildURLFromParts(a);\n          }\n          var n = s.parseURL(t);\n          if (!n) throw new Error(\"Error trying to parse relative URL.\");\n          if (n.scheme) return r.alwaysNormalize ? (n.path = s.normalizePath(n.path), s.buildURLFromParts(n)) : t;\n          var o = s.parseURL(e);\n          if (!o) throw new Error(\"Error trying to parse base URL.\");\n          if (!o.netLoc && o.path && \"/\" !== o.path[0]) {\n            var l = i.exec(o.path);\n            o.netLoc = l[1], o.path = l[2];\n          }\n          o.netLoc && !o.path && (o.path = \"/\");\n          var u = {\n            scheme: o.scheme,\n            netLoc: n.netLoc,\n            path: null,\n            params: n.params,\n            query: n.query,\n            fragment: n.fragment\n          };\n          if (!n.netLoc && (u.netLoc = o.netLoc, \"/\" !== n.path[0])) if (n.path) {\n            var d = o.path,\n              h = d.substring(0, d.lastIndexOf(\"/\") + 1) + n.path;\n            u.path = s.normalizePath(h);\n          } else u.path = o.path, n.params || (u.params = o.params, n.query || (u.query = o.query));\n          return null === u.path && (u.path = r.alwaysNormalize ? s.normalizePath(n.path) : n.path), s.buildURLFromParts(u);\n        },\n        parseURL: function (e) {\n          var t = r.exec(e);\n          return t ? {\n            scheme: t[1] || \"\",\n            netLoc: t[2] || \"\",\n            path: t[3] || \"\",\n            params: t[4] || \"\",\n            query: t[5] || \"\",\n            fragment: t[6] || \"\"\n          } : null;\n        },\n        normalizePath: function (e) {\n          for (e = e.split(\"\").reverse().join(\"\").replace(a, \"\"); e.length !== (e = e.replace(n, \"\")).length;);\n          return e.split(\"\").reverse().join(\"\");\n        },\n        buildURLFromParts: function (e) {\n          return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment;\n        }\n      }, e.exports = s;\n    }(v);\n    var g = v.exports,\n      m = Number.isFinite || function (e) {\n        return \"number\" == typeof e && isFinite(e);\n      },\n      p = Number.isSafeInteger || function (e) {\n        return \"number\" == typeof e && Math.abs(e) <= y;\n      },\n      y = Number.MAX_SAFE_INTEGER || 9007199254740991,\n      E = function (e) {\n        return e.MEDIA_ATTACHING = \"hlsMediaAttaching\", e.MEDIA_ATTACHED = \"hlsMediaAttached\", e.MEDIA_DETACHING = \"hlsMediaDetaching\", e.MEDIA_DETACHED = \"hlsMediaDetached\", e.BUFFER_RESET = \"hlsBufferReset\", e.BUFFER_CODECS = \"hlsBufferCodecs\", e.BUFFER_CREATED = \"hlsBufferCreated\", e.BUFFER_APPENDING = \"hlsBufferAppending\", e.BUFFER_APPENDED = \"hlsBufferAppended\", e.BUFFER_EOS = \"hlsBufferEos\", e.BUFFER_FLUSHING = \"hlsBufferFlushing\", e.BUFFER_FLUSHED = \"hlsBufferFlushed\", e.MANIFEST_LOADING = \"hlsManifestLoading\", e.MANIFEST_LOADED = \"hlsManifestLoaded\", e.MANIFEST_PARSED = \"hlsManifestParsed\", e.LEVEL_SWITCHING = \"hlsLevelSwitching\", e.LEVEL_SWITCHED = \"hlsLevelSwitched\", e.LEVEL_LOADING = \"hlsLevelLoading\", e.LEVEL_LOADED = \"hlsLevelLoaded\", e.LEVEL_UPDATED = \"hlsLevelUpdated\", e.LEVEL_PTS_UPDATED = \"hlsLevelPtsUpdated\", e.LEVELS_UPDATED = \"hlsLevelsUpdated\", e.AUDIO_TRACKS_UPDATED = \"hlsAudioTracksUpdated\", e.AUDIO_TRACK_SWITCHING = \"hlsAudioTrackSwitching\", e.AUDIO_TRACK_SWITCHED = \"hlsAudioTrackSwitched\", e.AUDIO_TRACK_LOADING = \"hlsAudioTrackLoading\", e.AUDIO_TRACK_LOADED = \"hlsAudioTrackLoaded\", e.SUBTITLE_TRACKS_UPDATED = \"hlsSubtitleTracksUpdated\", e.SUBTITLE_TRACKS_CLEARED = \"hlsSubtitleTracksCleared\", e.SUBTITLE_TRACK_SWITCH = \"hlsSubtitleTrackSwitch\", e.SUBTITLE_TRACK_LOADING = \"hlsSubtitleTrackLoading\", e.SUBTITLE_TRACK_LOADED = \"hlsSubtitleTrackLoaded\", e.SUBTITLE_FRAG_PROCESSED = \"hlsSubtitleFragProcessed\", e.CUES_PARSED = \"hlsCuesParsed\", e.NON_NATIVE_TEXT_TRACKS_FOUND = \"hlsNonNativeTextTracksFound\", e.INIT_PTS_FOUND = \"hlsInitPtsFound\", e.FRAG_LOADING = \"hlsFragLoading\", e.FRAG_LOAD_EMERGENCY_ABORTED = \"hlsFragLoadEmergencyAborted\", e.FRAG_LOADED = \"hlsFragLoaded\", e.FRAG_DECRYPTED = \"hlsFragDecrypted\", e.FRAG_PARSING_INIT_SEGMENT = \"hlsFragParsingInitSegment\", e.FRAG_PARSING_USERDATA = \"hlsFragParsingUserdata\", e.FRAG_PARSING_METADATA = \"hlsFragParsingMetadata\", e.FRAG_PARSED = \"hlsFragParsed\", e.FRAG_BUFFERED = \"hlsFragBuffered\", e.FRAG_CHANGED = \"hlsFragChanged\", e.FPS_DROP = \"hlsFpsDrop\", e.FPS_DROP_LEVEL_CAPPING = \"hlsFpsDropLevelCapping\", e.MAX_AUTO_LEVEL_UPDATED = \"hlsMaxAutoLevelUpdated\", e.ERROR = \"hlsError\", e.DESTROYING = \"hlsDestroying\", e.KEY_LOADING = \"hlsKeyLoading\", e.KEY_LOADED = \"hlsKeyLoaded\", e.LIVE_BACK_BUFFER_REACHED = \"hlsLiveBackBufferReached\", e.BACK_BUFFER_REACHED = \"hlsBackBufferReached\", e.STEERING_MANIFEST_LOADED = \"hlsSteeringManifestLoaded\", e;\n      }({}),\n      T = function (e) {\n        return e.NETWORK_ERROR = \"networkError\", e.MEDIA_ERROR = \"mediaError\", e.KEY_SYSTEM_ERROR = \"keySystemError\", e.MUX_ERROR = \"muxError\", e.OTHER_ERROR = \"otherError\", e;\n      }({}),\n      S = function (e) {\n        return e.KEY_SYSTEM_NO_KEYS = \"keySystemNoKeys\", e.KEY_SYSTEM_NO_ACCESS = \"keySystemNoAccess\", e.KEY_SYSTEM_NO_SESSION = \"keySystemNoSession\", e.KEY_SYSTEM_NO_CONFIGURED_LICENSE = \"keySystemNoConfiguredLicense\", e.KEY_SYSTEM_LICENSE_REQUEST_FAILED = \"keySystemLicenseRequestFailed\", e.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = \"keySystemServerCertificateRequestFailed\", e.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = \"keySystemServerCertificateUpdateFailed\", e.KEY_SYSTEM_SESSION_UPDATE_FAILED = \"keySystemSessionUpdateFailed\", e.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = \"keySystemStatusOutputRestricted\", e.KEY_SYSTEM_STATUS_INTERNAL_ERROR = \"keySystemStatusInternalError\", e.MANIFEST_LOAD_ERROR = \"manifestLoadError\", e.MANIFEST_LOAD_TIMEOUT = \"manifestLoadTimeOut\", e.MANIFEST_PARSING_ERROR = \"manifestParsingError\", e.MANIFEST_INCOMPATIBLE_CODECS_ERROR = \"manifestIncompatibleCodecsError\", e.LEVEL_EMPTY_ERROR = \"levelEmptyError\", e.LEVEL_LOAD_ERROR = \"levelLoadError\", e.LEVEL_LOAD_TIMEOUT = \"levelLoadTimeOut\", e.LEVEL_PARSING_ERROR = \"levelParsingError\", e.LEVEL_SWITCH_ERROR = \"levelSwitchError\", e.AUDIO_TRACK_LOAD_ERROR = \"audioTrackLoadError\", e.AUDIO_TRACK_LOAD_TIMEOUT = \"audioTrackLoadTimeOut\", e.SUBTITLE_LOAD_ERROR = \"subtitleTrackLoadError\", e.SUBTITLE_TRACK_LOAD_TIMEOUT = \"subtitleTrackLoadTimeOut\", e.FRAG_LOAD_ERROR = \"fragLoadError\", e.FRAG_LOAD_TIMEOUT = \"fragLoadTimeOut\", e.FRAG_DECRYPT_ERROR = \"fragDecryptError\", e.FRAG_PARSING_ERROR = \"fragParsingError\", e.FRAG_GAP = \"fragGap\", e.REMUX_ALLOC_ERROR = \"remuxAllocError\", e.KEY_LOAD_ERROR = \"keyLoadError\", e.KEY_LOAD_TIMEOUT = \"keyLoadTimeOut\", e.BUFFER_ADD_CODEC_ERROR = \"bufferAddCodecError\", e.BUFFER_INCOMPATIBLE_CODECS_ERROR = \"bufferIncompatibleCodecsError\", e.BUFFER_APPEND_ERROR = \"bufferAppendError\", e.BUFFER_APPENDING_ERROR = \"bufferAppendingError\", e.BUFFER_STALLED_ERROR = \"bufferStalledError\", e.BUFFER_FULL_ERROR = \"bufferFullError\", e.BUFFER_SEEK_OVER_HOLE = \"bufferSeekOverHole\", e.BUFFER_NUDGE_ON_STALL = \"bufferNudgeOnStall\", e.INTERNAL_EXCEPTION = \"internalException\", e.INTERNAL_ABORTED = \"aborted\", e.UNKNOWN = \"unknown\", e;\n      }({}),\n      L = function () {},\n      R = {\n        trace: L,\n        debug: L,\n        log: L,\n        warn: L,\n        info: L,\n        error: L\n      },\n      A = R;\n    function b(e) {\n      for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) r[i - 1] = arguments[i];\n      r.forEach(function (t) {\n        A[t] = e[t] ? e[t].bind(e) : function (e) {\n          var t = self.console[e];\n          return t ? t.bind(self.console, \"[\" + e + \"] >\") : L;\n        }(t);\n      });\n    }\n    function D(e, t) {\n      if (\"object\" == typeof console && !0 === e || \"object\" == typeof e) {\n        b(e, \"debug\", \"log\", \"info\", \"warn\", \"error\");\n        try {\n          A.log('Debug logs enabled for \"' + t + '\" in hls.js version 1.5.4');\n        } catch (e) {\n          A = R;\n        }\n      } else A = R;\n    }\n    var k = A,\n      _ = /^(\\d+)x(\\d+)$/,\n      x = /(.+?)=(\".*?\"|.*?)(?:,|$)/g,\n      w = function () {\n        function e(t) {\n          \"string\" == typeof t && (t = e.parseAttrList(t)), o(this, t);\n        }\n        var t = e.prototype;\n        return t.decimalInteger = function (e) {\n          var t = parseInt(this[e], 10);\n          return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;\n        }, t.hexadecimalInteger = function (e) {\n          if (this[e]) {\n            var t = (this[e] || \"0x\").slice(2);\n            t = (1 & t.length ? \"0\" : \"\") + t;\n            for (var r = new Uint8Array(t.length / 2), i = 0; i < t.length / 2; i++) r[i] = parseInt(t.slice(2 * i, 2 * i + 2), 16);\n            return r;\n          }\n          return null;\n        }, t.hexadecimalIntegerAsNumber = function (e) {\n          var t = parseInt(this[e], 16);\n          return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t;\n        }, t.decimalFloatingPoint = function (e) {\n          return parseFloat(this[e]);\n        }, t.optionalFloat = function (e, t) {\n          var r = this[e];\n          return r ? parseFloat(r) : t;\n        }, t.enumeratedString = function (e) {\n          return this[e];\n        }, t.bool = function (e) {\n          return \"YES\" === this[e];\n        }, t.decimalResolution = function (e) {\n          var t = _.exec(this[e]);\n          if (null !== t) return {\n            width: parseInt(t[1], 10),\n            height: parseInt(t[2], 10)\n          };\n        }, e.parseAttrList = function (e) {\n          var t,\n            r = {};\n          for (x.lastIndex = 0; null !== (t = x.exec(e));) {\n            var i = t[2];\n            0 === i.indexOf('\"') && i.lastIndexOf('\"') === i.length - 1 && (i = i.slice(1, -1)), r[t[1].trim()] = i;\n          }\n          return r;\n        }, s(e, [{\n          key: \"clientAttrs\",\n          get: function () {\n            return Object.keys(this).filter(function (e) {\n              return \"X-\" === e.substring(0, 2);\n            });\n          }\n        }]), e;\n      }();\n    function C(e) {\n      return \"SCTE35-OUT\" === e || \"SCTE35-IN\" === e;\n    }\n    var I = function () {\n        function e(e, t) {\n          if (this.attr = void 0, this._startDate = void 0, this._endDate = void 0, this._badValueForSameId = void 0, t) {\n            var r = t.attr;\n            for (var i in r) if (Object.prototype.hasOwnProperty.call(e, i) && e[i] !== r[i]) {\n              k.warn('DATERANGE tag attribute: \"' + i + '\" does not match for tags with ID: \"' + e.ID + '\"'), this._badValueForSameId = i;\n              break;\n            }\n            e = o(new w({}), r, e);\n          }\n          if (this.attr = e, this._startDate = new Date(e[\"START-DATE\"]), \"END-DATE\" in this.attr) {\n            var a = new Date(this.attr[\"END-DATE\"]);\n            m(a.getTime()) && (this._endDate = a);\n          }\n        }\n        return s(e, [{\n          key: \"id\",\n          get: function () {\n            return this.attr.ID;\n          }\n        }, {\n          key: \"class\",\n          get: function () {\n            return this.attr.CLASS;\n          }\n        }, {\n          key: \"startDate\",\n          get: function () {\n            return this._startDate;\n          }\n        }, {\n          key: \"endDate\",\n          get: function () {\n            if (this._endDate) return this._endDate;\n            var e = this.duration;\n            return null !== e ? new Date(this._startDate.getTime() + 1e3 * e) : null;\n          }\n        }, {\n          key: \"duration\",\n          get: function () {\n            if (\"DURATION\" in this.attr) {\n              var e = this.attr.decimalFloatingPoint(\"DURATION\");\n              if (m(e)) return e;\n            } else if (this._endDate) return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;\n            return null;\n          }\n        }, {\n          key: \"plannedDuration\",\n          get: function () {\n            return \"PLANNED-DURATION\" in this.attr ? this.attr.decimalFloatingPoint(\"PLANNED-DURATION\") : null;\n          }\n        }, {\n          key: \"endOnNext\",\n          get: function () {\n            return this.attr.bool(\"END-ON-NEXT\");\n          }\n        }, {\n          key: \"isValid\",\n          get: function () {\n            return !!this.id && !this._badValueForSameId && m(this.startDate.getTime()) && (null === this.duration || this.duration >= 0) && (!this.endOnNext || !!this.class);\n          }\n        }]), e;\n      }(),\n      P = function () {\n        this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {\n          start: 0,\n          first: 0,\n          end: 0\n        }, this.parsing = {\n          start: 0,\n          end: 0\n        }, this.buffering = {\n          start: 0,\n          first: 0,\n          end: 0\n        };\n      },\n      F = \"audio\",\n      O = \"video\",\n      M = \"audiovideo\",\n      N = function () {\n        function e(e) {\n          var t;\n          this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = ((t = {})[F] = null, t[O] = null, t[M] = null, t), this.baseurl = e;\n        }\n        return e.prototype.setByteRange = function (e, t) {\n          var r,\n            i = e.split(\"@\", 2);\n          r = 1 === i.length ? (null == t ? void 0 : t.byteRangeEndOffset) || 0 : parseInt(i[1]), this._byteRange = [r, parseInt(i[0]) + r];\n        }, s(e, [{\n          key: \"byteRange\",\n          get: function () {\n            return this._byteRange ? this._byteRange : [];\n          }\n        }, {\n          key: \"byteRangeStartOffset\",\n          get: function () {\n            return this.byteRange[0];\n          }\n        }, {\n          key: \"byteRangeEndOffset\",\n          get: function () {\n            return this.byteRange[1];\n          }\n        }, {\n          key: \"url\",\n          get: function () {\n            return !this._url && this.baseurl && this.relurl && (this._url = g.buildAbsoluteURL(this.baseurl, this.relurl, {\n              alwaysNormalize: !0\n            })), this._url || \"\";\n          },\n          set: function (e) {\n            this._url = e;\n          }\n        }]), e;\n      }(),\n      B = function (e) {\n        function t(t, r) {\n          var i;\n          return (i = e.call(this, r) || this)._decryptdata = null, i.rawProgramDateTime = null, i.programDateTime = null, i.tagList = [], i.duration = 0, i.sn = 0, i.levelkeys = void 0, i.type = void 0, i.loader = null, i.keyLoader = null, i.level = -1, i.cc = 0, i.startPTS = void 0, i.endPTS = void 0, i.startDTS = void 0, i.endDTS = void 0, i.start = 0, i.deltaPTS = void 0, i.maxStartPTS = void 0, i.minEndPTS = void 0, i.stats = new P(), i.data = void 0, i.bitrateTest = !1, i.title = null, i.initSegment = null, i.endList = void 0, i.gap = void 0, i.urlId = 0, i.type = t, i;\n        }\n        l(t, e);\n        var r = t.prototype;\n        return r.setKeyFormat = function (e) {\n          if (this.levelkeys) {\n            var t = this.levelkeys[e];\n            t && !this._decryptdata && (this._decryptdata = t.getDecryptData(this.sn));\n          }\n        }, r.abortRequests = function () {\n          var e, t;\n          null == (e = this.loader) || e.abort(), null == (t = this.keyLoader) || t.abort();\n        }, r.setElementaryStreamInfo = function (e, t, r, i, a, n) {\n          void 0 === n && (n = !1);\n          var s = this.elementaryStreams,\n            o = s[e];\n          o ? (o.startPTS = Math.min(o.startPTS, t), o.endPTS = Math.max(o.endPTS, r), o.startDTS = Math.min(o.startDTS, i), o.endDTS = Math.max(o.endDTS, a)) : s[e] = {\n            startPTS: t,\n            endPTS: r,\n            startDTS: i,\n            endDTS: a,\n            partial: n\n          };\n        }, r.clearElementaryStreamInfo = function () {\n          var e = this.elementaryStreams;\n          e[F] = null, e[O] = null, e[M] = null;\n        }, s(t, [{\n          key: \"decryptdata\",\n          get: function () {\n            if (!this.levelkeys && !this._decryptdata) return null;\n            if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {\n              var e = this.levelkeys.identity;\n              if (e) this._decryptdata = e.getDecryptData(this.sn);else {\n                var t = Object.keys(this.levelkeys);\n                if (1 === t.length) return this._decryptdata = this.levelkeys[t[0]].getDecryptData(this.sn);\n              }\n            }\n            return this._decryptdata;\n          }\n        }, {\n          key: \"end\",\n          get: function () {\n            return this.start + this.duration;\n          }\n        }, {\n          key: \"endProgramDateTime\",\n          get: function () {\n            if (null === this.programDateTime) return null;\n            if (!m(this.programDateTime)) return null;\n            var e = m(this.duration) ? this.duration : 0;\n            return this.programDateTime + 1e3 * e;\n          }\n        }, {\n          key: \"encrypted\",\n          get: function () {\n            var e;\n            if (null != (e = this._decryptdata) && e.encrypted) return !0;\n            if (this.levelkeys) {\n              var t = Object.keys(this.levelkeys),\n                r = t.length;\n              if (r > 1 || 1 === r && this.levelkeys[t[0]].encrypted) return !0;\n            }\n            return !1;\n          }\n        }]), t;\n      }(N),\n      U = function (e) {\n        function t(t, r, i, a, n) {\n          var s;\n          (s = e.call(this, i) || this).fragOffset = 0, s.duration = 0, s.gap = !1, s.independent = !1, s.relurl = void 0, s.fragment = void 0, s.index = void 0, s.stats = new P(), s.duration = t.decimalFloatingPoint(\"DURATION\"), s.gap = t.bool(\"GAP\"), s.independent = t.bool(\"INDEPENDENT\"), s.relurl = t.enumeratedString(\"URI\"), s.fragment = r, s.index = a;\n          var o = t.enumeratedString(\"BYTERANGE\");\n          return o && s.setByteRange(o, n), n && (s.fragOffset = n.fragOffset + n.duration), s;\n        }\n        return l(t, e), s(t, [{\n          key: \"start\",\n          get: function () {\n            return this.fragment.start + this.fragOffset;\n          }\n        }, {\n          key: \"end\",\n          get: function () {\n            return this.start + this.duration;\n          }\n        }, {\n          key: \"loaded\",\n          get: function () {\n            var e = this.elementaryStreams;\n            return !!(e.audio || e.video || e.audiovideo);\n          }\n        }]), t;\n      }(N),\n      G = function () {\n        function e(e) {\n          this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.live = !0, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.availabilityDelay = void 0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = \"\", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e;\n        }\n        return e.prototype.reloaded = function (e) {\n          if (!e) return this.advanced = !0, void (this.updated = !0);\n          var t = this.lastPartSn - e.lastPartSn,\n            r = this.lastPartIndex - e.lastPartIndex;\n          this.updated = this.endSN !== e.endSN || !!r || !!t || !this.live, this.advanced = this.endSN > e.endSN || t > 0 || 0 === t && r > 0, this.updated || this.advanced ? this.misses = Math.floor(.6 * e.misses) : this.misses = e.misses + 1, this.availabilityDelay = e.availabilityDelay;\n        }, s(e, [{\n          key: \"hasProgramDateTime\",\n          get: function () {\n            return !!this.fragments.length && m(this.fragments[this.fragments.length - 1].programDateTime);\n          }\n        }, {\n          key: \"levelTargetDuration\",\n          get: function () {\n            return this.averagetargetduration || this.targetduration || 10;\n          }\n        }, {\n          key: \"drift\",\n          get: function () {\n            var e = this.driftEndTime - this.driftStartTime;\n            return e > 0 ? 1e3 * (this.driftEnd - this.driftStart) / e : 1;\n          }\n        }, {\n          key: \"edge\",\n          get: function () {\n            return this.partEnd || this.fragmentEnd;\n          }\n        }, {\n          key: \"partEnd\",\n          get: function () {\n            var e;\n            return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd;\n          }\n        }, {\n          key: \"fragmentEnd\",\n          get: function () {\n            var e;\n            return null != (e = this.fragments) && e.length ? this.fragments[this.fragments.length - 1].end : 0;\n          }\n        }, {\n          key: \"age\",\n          get: function () {\n            return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0;\n          }\n        }, {\n          key: \"lastPartIndex\",\n          get: function () {\n            var e;\n            return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].index : -1;\n          }\n        }, {\n          key: \"lastPartSn\",\n          get: function () {\n            var e;\n            return null != (e = this.partList) && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN;\n          }\n        }]), e;\n      }(),\n      H = c(void 0);\n    function V(e, t, r) {\n      return Uint8Array.prototype.slice ? e.slice(t, r) : new Uint8Array(Array.prototype.slice.call(e, t, r));\n    }\n    var K,\n      j = function (e, t) {\n        return t + 10 <= e.length && 73 === e[t] && 68 === e[t + 1] && 51 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128;\n      },\n      W = function (e, t) {\n        return t + 10 <= e.length && 51 === e[t] && 68 === e[t + 1] && 73 === e[t + 2] && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128;\n      },\n      Y = function (e, t) {\n        for (var r = t, i = 0; j(e, t);) i += 10, i += q(e, t + 6), W(e, t + 10) && (i += 10), t += i;\n        if (i > 0) return e.subarray(r, r + i);\n      },\n      q = function (e, t) {\n        var r = 0;\n        return r = (127 & e[t]) << 21, r |= (127 & e[t + 1]) << 14, r |= (127 & e[t + 2]) << 7, r |= 127 & e[t + 3];\n      },\n      z = function (e, t) {\n        return j(e, t) && q(e, t + 6) + 10 <= e.length - t;\n      },\n      X = function (e) {\n        for (var t = $(e), r = 0; r < t.length; r++) {\n          var i = t[r];\n          if (Q(i)) return ie(i);\n        }\n      },\n      Q = function (e) {\n        return e && \"PRIV\" === e.key && \"com.apple.streaming.transportStreamTimestamp\" === e.info;\n      },\n      J = function (e) {\n        var t = String.fromCharCode(e[0], e[1], e[2], e[3]),\n          r = q(e, 4);\n        return {\n          type: t,\n          size: r,\n          data: e.subarray(10, 10 + r)\n        };\n      },\n      $ = function (e) {\n        for (var t = 0, r = []; j(e, t);) {\n          for (var i = q(e, t + 6), a = (t += 10) + i; t + 8 < a;) {\n            var n = J(e.subarray(t)),\n              s = Z(n);\n            s && r.push(s), t += n.size + 10;\n          }\n          W(e, t) && (t += 10);\n        }\n        return r;\n      },\n      Z = function (e) {\n        return \"PRIV\" === e.type ? ee(e) : \"W\" === e.type[0] ? re(e) : te(e);\n      },\n      ee = function (e) {\n        if (!(e.size < 2)) {\n          var t = ae(e.data, !0),\n            r = new Uint8Array(e.data.subarray(t.length + 1));\n          return {\n            key: e.type,\n            info: t,\n            data: r.buffer\n          };\n        }\n      },\n      te = function (e) {\n        if (!(e.size < 2)) {\n          if (\"TXXX\" === e.type) {\n            var t = 1,\n              r = ae(e.data.subarray(t), !0);\n            t += r.length + 1;\n            var i = ae(e.data.subarray(t));\n            return {\n              key: e.type,\n              info: r,\n              data: i\n            };\n          }\n          var a = ae(e.data.subarray(1));\n          return {\n            key: e.type,\n            data: a\n          };\n        }\n      },\n      re = function (e) {\n        if (\"WXXX\" === e.type) {\n          if (e.size < 2) return;\n          var t = 1,\n            r = ae(e.data.subarray(t), !0);\n          t += r.length + 1;\n          var i = ae(e.data.subarray(t));\n          return {\n            key: e.type,\n            info: r,\n            data: i\n          };\n        }\n        var a = ae(e.data);\n        return {\n          key: e.type,\n          data: a\n        };\n      },\n      ie = function (e) {\n        if (8 === e.data.byteLength) {\n          var t = new Uint8Array(e.data),\n            r = 1 & t[3],\n            i = (t[4] << 23) + (t[5] << 15) + (t[6] << 7) + t[7];\n          return i /= 45, r && (i += 47721858.84), Math.round(i);\n        }\n      },\n      ae = function (e, t) {\n        void 0 === t && (t = !1);\n        var r = ne();\n        if (r) {\n          var i = r.decode(e);\n          if (t) {\n            var a = i.indexOf(\"\\0\");\n            return -1 !== a ? i.substring(0, a) : i;\n          }\n          return i.replace(/\\0/g, \"\");\n        }\n        for (var n, s, o, l = e.length, u = \"\", d = 0; d < l;) {\n          if (0 === (n = e[d++]) && t) return u;\n          if (0 !== n && 3 !== n) switch (n >> 4) {\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n              u += String.fromCharCode(n);\n              break;\n            case 12:\n            case 13:\n              s = e[d++], u += String.fromCharCode((31 & n) << 6 | 63 & s);\n              break;\n            case 14:\n              s = e[d++], o = e[d++], u += String.fromCharCode((15 & n) << 12 | (63 & s) << 6 | (63 & o) << 0);\n          }\n        }\n        return u;\n      };\n    function ne() {\n      if (!navigator.userAgent.includes(\"PlayStation 4\")) return K || void 0 === self.TextDecoder || (K = new self.TextDecoder(\"utf-8\")), K;\n    }\n    var se = function (e) {\n        for (var t = \"\", r = 0; r < e.length; r++) {\n          var i = e[r].toString(16);\n          i.length < 2 && (i = \"0\" + i), t += i;\n        }\n        return t;\n      },\n      oe = Math.pow(2, 32) - 1,\n      le = [].push,\n      ue = {\n        video: 1,\n        audio: 2,\n        id3: 3,\n        text: 4\n      };\n    function de(e) {\n      return String.fromCharCode.apply(null, e);\n    }\n    function he(e, t) {\n      var r = e[t] << 8 | e[t + 1];\n      return r < 0 ? 65536 + r : r;\n    }\n    function fe(e, t) {\n      var r = ve(e, t);\n      return r < 0 ? 4294967296 + r : r;\n    }\n    function ce(e, t) {\n      var r = fe(e, t);\n      return r *= Math.pow(2, 32), r += fe(e, t + 4);\n    }\n    function ve(e, t) {\n      return e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3];\n    }\n    function ge(e, t, r) {\n      e[t] = r >> 24, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = 255 & r;\n    }\n    function me(e, t) {\n      var r = [];\n      if (!t.length) return r;\n      for (var i = e.byteLength, a = 0; a < i;) {\n        var n = fe(e, a),\n          s = n > 1 ? a + n : i;\n        if (de(e.subarray(a + 4, a + 8)) === t[0]) if (1 === t.length) r.push(e.subarray(a + 8, s));else {\n          var o = me(e.subarray(a + 8, s), t.slice(1));\n          o.length && le.apply(r, o);\n        }\n        a = s;\n      }\n      return r;\n    }\n    function pe(e) {\n      var t = [],\n        r = e[0],\n        i = 8,\n        a = fe(e, i);\n      i += 4;\n      var n = 0,\n        s = 0;\n      0 === r ? (n = fe(e, i += 4), s = fe(e, i += 4)) : (n = ce(e, i += 8), s = ce(e, i += 8)), i += 2;\n      var o = e.length + s,\n        l = he(e, i);\n      i += 2;\n      for (var u = 0; u < l; u++) {\n        var d = i,\n          h = fe(e, d);\n        d += 4;\n        var f = 2147483647 & h;\n        if (1 == (2147483648 & h) >>> 31) return k.warn(\"SIDX has hierarchical references (not supported)\"), null;\n        var c = fe(e, d);\n        d += 4, t.push({\n          referenceSize: f,\n          subsegmentDuration: c,\n          info: {\n            duration: c / a,\n            start: o,\n            end: o + f - 1\n          }\n        }), o += f, i = d += 4;\n      }\n      return {\n        earliestPresentationTime: n,\n        timescale: a,\n        version: r,\n        referencesCount: l,\n        references: t\n      };\n    }\n    function ye(e) {\n      for (var t = [], r = me(e, [\"moov\", \"trak\"]), a = 0; a < r.length; a++) {\n        var n = r[a],\n          s = me(n, [\"tkhd\"])[0];\n        if (s) {\n          var o = s[0],\n            l = fe(s, 0 === o ? 12 : 20),\n            u = me(n, [\"mdia\", \"mdhd\"])[0];\n          if (u) {\n            var d = fe(u, 0 === (o = u[0]) ? 12 : 20),\n              h = me(n, [\"mdia\", \"hdlr\"])[0];\n            if (h) {\n              var f = de(h.subarray(8, 12)),\n                c = {\n                  soun: F,\n                  vide: O\n                }[f];\n              if (c) {\n                var v = Ee(me(n, [\"mdia\", \"minf\", \"stbl\", \"stsd\"])[0]);\n                t[l] = {\n                  timescale: d,\n                  type: c\n                }, t[c] = i({\n                  timescale: d,\n                  id: l\n                }, v);\n              }\n            }\n          }\n        }\n      }\n      return me(e, [\"moov\", \"mvex\", \"trex\"]).forEach(function (e) {\n        var r = fe(e, 4),\n          i = t[r];\n        i && (i.default = {\n          duration: fe(e, 12),\n          flags: fe(e, 20)\n        });\n      }), t;\n    }\n    function Ee(e) {\n      var t = e.subarray(8),\n        r = t.subarray(86),\n        i = de(t.subarray(4, 8)),\n        a = i,\n        n = \"enca\" === i || \"encv\" === i;\n      if (n) {\n        var s = me(t, [i])[0];\n        me(s.subarray(\"enca\" === i ? 28 : 78), [\"sinf\"]).forEach(function (e) {\n          var t = me(e, [\"schm\"])[0];\n          if (t) {\n            var r = de(t.subarray(4, 8));\n            if (\"cbcs\" === r || \"cenc\" === r) {\n              var i = me(e, [\"frma\"])[0];\n              i && (a = de(i));\n            }\n          }\n        });\n      }\n      switch (a) {\n        case \"avc1\":\n        case \"avc2\":\n        case \"avc3\":\n        case \"avc4\":\n          var o = me(r, [\"avcC\"])[0];\n          a += \".\" + Se(o[1]) + Se(o[2]) + Se(o[3]);\n          break;\n        case \"mp4a\":\n          var l = me(t, [i])[0],\n            u = me(l.subarray(28), [\"esds\"])[0];\n          if (u && u.length > 12) {\n            var d = 4;\n            if (3 !== u[d++]) break;\n            d = Te(u, d), d += 2;\n            var h = u[d++];\n            if (128 & h && (d += 2), 64 & h && (d += u[d++]), 4 !== u[d++]) break;\n            d = Te(u, d);\n            var f = u[d++];\n            if (64 !== f) break;\n            if (a += \".\" + Se(f), d += 12, 5 !== u[d++]) break;\n            d = Te(u, d);\n            var c = u[d++],\n              v = (248 & c) >> 3;\n            31 === v && (v += 1 + ((7 & c) << 3) + ((224 & u[d]) >> 5)), a += \".\" + v;\n          }\n          break;\n        case \"hvc1\":\n        case \"hev1\":\n          var g = me(r, [\"hvcC\"])[0],\n            m = g[1],\n            p = [\"\", \"A\", \"B\", \"C\"][m >> 6],\n            y = 31 & m,\n            E = fe(g, 2),\n            T = (32 & m) >> 5 ? \"H\" : \"L\",\n            S = g[12],\n            L = g.subarray(6, 12);\n          a += \".\" + p + y, a += \".\" + E.toString(16).toUpperCase(), a += \".\" + T + S;\n          for (var R = \"\", A = L.length; A--;) {\n            var b = L[A];\n            (b || R) && (R = \".\" + b.toString(16).toUpperCase() + R);\n          }\n          a += R;\n          break;\n        case \"dvh1\":\n        case \"dvhe\":\n          var D = me(r, [\"dvcC\"])[0],\n            k = D[2] >> 1 & 127,\n            _ = D[2] << 5 & 32 | D[3] >> 3 & 31;\n          a += \".\" + Le(k) + \".\" + Le(_);\n          break;\n        case \"vp09\":\n          var x = me(r, [\"vpcC\"])[0],\n            w = x[4],\n            C = x[5],\n            I = x[6] >> 4 & 15;\n          a += \".\" + Le(w) + \".\" + Le(C) + \".\" + Le(I);\n          break;\n        case \"av01\":\n          var P = me(r, [\"av1C\"])[0],\n            F = P[1] >>> 5,\n            O = 31 & P[1],\n            M = P[2] >>> 7 ? \"H\" : \"M\",\n            N = (64 & P[2]) >> 6,\n            B = (32 & P[2]) >> 5,\n            U = 2 === F && N ? B ? 12 : 10 : N ? 10 : 8,\n            G = (16 & P[2]) >> 4,\n            H = (8 & P[2]) >> 3,\n            V = (4 & P[2]) >> 2,\n            K = 3 & P[2];\n          a += \".\" + F + \".\" + Le(O) + M + \".\" + Le(U) + \".\" + G + \".\" + H + V + K + \".\" + Le(1) + \".\" + Le(1) + \".\" + Le(1) + \".0\";\n      }\n      return {\n        codec: a,\n        encrypted: n\n      };\n    }\n    function Te(e, t) {\n      for (var r = t + 5; 128 & e[t++] && t < r;);\n      return t;\n    }\n    function Se(e) {\n      return (\"0\" + e.toString(16).toUpperCase()).slice(-2);\n    }\n    function Le(e) {\n      return (e < 10 ? \"0\" : \"\") + e;\n    }\n    function Re(e, t) {\n      if (!e || !t) return e;\n      var r = t.keyId;\n      return r && t.isCommonEncryption && me(e, [\"moov\", \"trak\"]).forEach(function (e) {\n        var t = me(e, [\"mdia\", \"minf\", \"stbl\", \"stsd\"])[0].subarray(8),\n          i = me(t, [\"enca\"]),\n          a = i.length > 0;\n        a || (i = me(t, [\"encv\"])), i.forEach(function (e) {\n          me(a ? e.subarray(28) : e.subarray(78), [\"sinf\"]).forEach(function (e) {\n            var t = function (e) {\n              var t = me(e, [\"schm\"])[0];\n              if (t) {\n                var r = de(t.subarray(4, 8));\n                if (\"cbcs\" === r || \"cenc\" === r) return me(e, [\"schi\", \"tenc\"])[0];\n              }\n              return k.error(\"[eme] missing 'schm' box\"), null;\n            }(e);\n            if (t) {\n              var i = t.subarray(8, 24);\n              i.some(function (e) {\n                return 0 !== e;\n              }) || (k.log(\"[eme] Patching keyId in 'enc\" + (a ? \"a\" : \"v\") + \">sinf>>tenc' box: \" + se(i) + \" -> \" + se(r)), t.set(r, 8));\n            }\n          });\n        });\n      }), e;\n    }\n    function Ae(e) {\n      var t = fe(e, 0),\n        r = 8;\n      1 & t && (r += 4), 4 & t && (r += 4);\n      for (var i = 0, a = fe(e, 4), n = 0; n < a; n++) 256 & t && (i += fe(e, r), r += 4), 512 & t && (r += 4), 1024 & t && (r += 4), 2048 & t && (r += 4);\n      return i;\n    }\n    function be(e, t) {\n      var r = new Uint8Array(e.length + t.length);\n      return r.set(e), r.set(t, e.length), r;\n    }\n    function De(e, t) {\n      var r = [],\n        i = t.samples,\n        a = t.timescale,\n        n = t.id,\n        s = !1;\n      return me(i, [\"moof\"]).map(function (o) {\n        var l = o.byteOffset - 8;\n        me(o, [\"traf\"]).map(function (o) {\n          var u = me(o, [\"tfdt\"]).map(function (e) {\n            var t = e[0],\n              r = fe(e, 4);\n            return 1 === t && (r *= Math.pow(2, 32), r += fe(e, 8)), r / a;\n          })[0];\n          return void 0 !== u && (e = u), me(o, [\"tfhd\"]).map(function (u) {\n            var d = fe(u, 4),\n              h = 16777215 & fe(u, 0),\n              f = 0,\n              c = 0 != (16 & h),\n              v = 0,\n              g = 0 != (32 & h),\n              m = 8;\n            d === n && (0 != (1 & h) && (m += 8), 0 != (2 & h) && (m += 4), 0 != (8 & h) && (f = fe(u, m), m += 4), c && (v = fe(u, m), m += 4), g && (m += 4), \"video\" === t.type && (s = function (e) {\n              if (!e) return !1;\n              var t = e.indexOf(\".\"),\n                r = t < 0 ? e : e.substring(0, t);\n              return \"hvc1\" === r || \"hev1\" === r || \"dvh1\" === r || \"dvhe\" === r;\n            }(t.codec)), me(o, [\"trun\"]).map(function (n) {\n              var o = n[0],\n                u = 16777215 & fe(n, 0),\n                d = 0 != (1 & u),\n                h = 0,\n                c = 0 != (4 & u),\n                g = 0 != (256 & u),\n                m = 0,\n                p = 0 != (512 & u),\n                y = 0,\n                E = 0 != (1024 & u),\n                T = 0 != (2048 & u),\n                S = 0,\n                L = fe(n, 4),\n                R = 8;\n              d && (h = fe(n, R), R += 4), c && (R += 4);\n              for (var A = h + l, b = 0; b < L; b++) {\n                if (g ? (m = fe(n, R), R += 4) : m = f, p ? (y = fe(n, R), R += 4) : y = v, E && (R += 4), T && (S = 0 === o ? fe(n, R) : ve(n, R), R += 4), t.type === O) for (var D = 0; D < y;) {\n                  var k = fe(i, A);\n                  ke(s, i[A += 4]) && _e(i.subarray(A, A + k), s ? 2 : 1, e + S / a, r), A += k, D += k + 4;\n                }\n                e += m / a;\n              }\n            }));\n          });\n        });\n      }), r;\n    }\n    function ke(e, t) {\n      if (e) {\n        var r = t >> 1 & 63;\n        return 39 === r || 40 === r;\n      }\n      return 6 == (31 & t);\n    }\n    function _e(e, t, r, i) {\n      var a = xe(e),\n        n = 0;\n      n += t;\n      for (var s = 0, o = 0, l = 0; n < a.length;) {\n        s = 0;\n        do {\n          if (n >= a.length) break;\n          s += l = a[n++];\n        } while (255 === l);\n        o = 0;\n        do {\n          if (n >= a.length) break;\n          o += l = a[n++];\n        } while (255 === l);\n        var u = a.length - n,\n          d = n;\n        if (o < u) n += o;else if (o > u) {\n          k.error(\"Malformed SEI payload. \" + o + \" is too small, only \" + u + \" bytes left to parse.\");\n          break;\n        }\n        if (4 === s) {\n          if (181 === a[d++]) {\n            var h = he(a, d);\n            if (d += 2, 49 === h) {\n              var f = fe(a, d);\n              if (d += 4, 1195456820 === f) {\n                var c = a[d++];\n                if (3 === c) {\n                  var v = a[d++],\n                    g = 64 & v,\n                    m = g ? 2 + 3 * (31 & v) : 0,\n                    p = new Uint8Array(m);\n                  if (g) {\n                    p[0] = v;\n                    for (var y = 1; y < m; y++) p[y] = a[d++];\n                  }\n                  i.push({\n                    type: c,\n                    payloadType: s,\n                    pts: r,\n                    bytes: p\n                  });\n                }\n              }\n            }\n          }\n        } else if (5 === s && o > 16) {\n          for (var E = [], T = 0; T < 16; T++) {\n            var S = a[d++].toString(16);\n            E.push(1 == S.length ? \"0\" + S : S), 3 !== T && 5 !== T && 7 !== T && 9 !== T || E.push(\"-\");\n          }\n          for (var L = o - 16, R = new Uint8Array(L), A = 0; A < L; A++) R[A] = a[d++];\n          i.push({\n            payloadType: s,\n            pts: r,\n            uuid: E.join(\"\"),\n            userData: ae(R),\n            userDataBytes: R\n          });\n        }\n      }\n    }\n    function xe(e) {\n      for (var t = e.byteLength, r = [], i = 1; i < t - 2;) 0 === e[i] && 0 === e[i + 1] && 3 === e[i + 2] ? (r.push(i + 2), i += 2) : i++;\n      if (0 === r.length) return e;\n      var a = t - r.length,\n        n = new Uint8Array(a),\n        s = 0;\n      for (i = 0; i < a; s++, i++) s === r[0] && (s++, r.shift()), n[i] = e[s];\n      return n;\n    }\n    var we = function () {\n      function e(e, t, r, i, a) {\n        void 0 === i && (i = [1]), void 0 === a && (a = null), this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = t, this.keyFormat = r, this.keyFormatVersions = i, this.iv = a, this.encrypted = !!e && \"NONE\" !== e, this.isCommonEncryption = this.encrypted && \"AES-128\" !== e;\n      }\n      e.clearKeyUriToKeyIdMap = function () {};\n      var t = e.prototype;\n      return t.isSupported = function () {\n        if (this.method) {\n          if (\"AES-128\" === this.method || \"NONE\" === this.method) return !0;\n          if (\"identity\" === this.keyFormat) return \"SAMPLE-AES\" === this.method;\n        }\n        return !1;\n      }, t.getDecryptData = function (t) {\n        if (!this.encrypted || !this.uri) return null;\n        if (\"AES-128\" === this.method && this.uri && !this.iv) {\n          \"number\" != typeof t && (\"AES-128\" !== this.method || this.iv || k.warn('missing IV for initialization segment with method=\"' + this.method + '\" - compliance issue'), t = 0);\n          var r = function (e) {\n            for (var t = new Uint8Array(16), r = 12; r < 16; r++) t[r] = e >> 8 * (15 - r) & 255;\n            return t;\n          }(t);\n          return new e(this.method, this.uri, \"identity\", this.keyFormatVersions, r);\n        }\n        return this;\n      }, e;\n    }();\n    function Ce(e) {\n      if (void 0 === e && (e = !0), \"undefined\" != typeof self) return (e || !self.MediaSource) && self.ManagedMediaSource || self.MediaSource || self.WebKitMediaSource;\n    }\n    var Ie = {\n      audio: {\n        a3ds: 1,\n        \"ac-3\": .95,\n        \"ac-4\": 1,\n        alac: .9,\n        alaw: 1,\n        dra1: 1,\n        \"dts+\": 1,\n        \"dts-\": 1,\n        dtsc: 1,\n        dtse: 1,\n        dtsh: 1,\n        \"ec-3\": .9,\n        enca: 1,\n        fLaC: .9,\n        flac: .9,\n        FLAC: .9,\n        g719: 1,\n        g726: 1,\n        m4ae: 1,\n        mha1: 1,\n        mha2: 1,\n        mhm1: 1,\n        mhm2: 1,\n        mlpa: 1,\n        mp4a: 1,\n        \"raw \": 1,\n        Opus: 1,\n        opus: 1,\n        samr: 1,\n        sawb: 1,\n        sawp: 1,\n        sevc: 1,\n        sqcp: 1,\n        ssmv: 1,\n        twos: 1,\n        ulaw: 1\n      },\n      video: {\n        avc1: 1,\n        avc2: 1,\n        avc3: 1,\n        avc4: 1,\n        avcp: 1,\n        av01: .8,\n        drac: 1,\n        dva1: 1,\n        dvav: 1,\n        dvh1: .7,\n        dvhe: .7,\n        encv: 1,\n        hev1: .75,\n        hvc1: .75,\n        mjp2: 1,\n        mp4v: 1,\n        mvc1: 1,\n        mvc2: 1,\n        mvc3: 1,\n        mvc4: 1,\n        resv: 1,\n        rv60: 1,\n        s263: 1,\n        svc1: 1,\n        svc2: 1,\n        \"vc-1\": 1,\n        vp08: 1,\n        vp09: .9\n      },\n      text: {\n        stpp: 1,\n        wvtt: 1\n      }\n    };\n    function Pe(e, t, r) {\n      return void 0 === r && (r = !0), !e.split(\",\").some(function (e) {\n        return !Fe(e, t, r);\n      });\n    }\n    function Fe(e, t, r) {\n      var i;\n      void 0 === r && (r = !0);\n      var a = Ce(r);\n      return null != (i = null == a ? void 0 : a.isTypeSupported(Oe(e, t))) && i;\n    }\n    function Oe(e, t) {\n      return t + '/mp4;codecs=\"' + e + '\"';\n    }\n    function Me(e) {\n      if (e) {\n        var t = e.substring(0, 4);\n        return Ie.video[t];\n      }\n      return 2;\n    }\n    function Ne(e) {\n      return e.split(\",\").reduce(function (e, t) {\n        var r = Ie.video[t];\n        return r ? (2 * r + e) / (e ? 3 : 2) : (Ie.audio[t] + e) / (e ? 2 : 1);\n      }, 0);\n    }\n    var Be = {},\n      Ue = /flac|opus/i;\n    function Ge(e, t) {\n      return void 0 === t && (t = !0), e.replace(Ue, function (e) {\n        return function (e, t) {\n          if (void 0 === t && (t = !0), Be[e]) return Be[e];\n          for (var r = {\n              flac: [\"flac\", \"fLaC\", \"FLAC\"],\n              opus: [\"opus\", \"Opus\"]\n            }[e], i = 0; i < r.length; i++) if (Fe(r[i], \"audio\", t)) return Be[e] = r[i], r[i];\n          return e;\n        }(e.toLowerCase(), t);\n      });\n    }\n    function He(e, t) {\n      return e && \"mp4a\" !== e ? e : t;\n    }\n    var Ve = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\\r\\n]*)[\\r\\n]+/g,\n      Ke = /#EXT-X-MEDIA:(.*)/g,\n      je = /^#EXT(?:INF|-X-TARGETDURATION):/m,\n      We = new RegExp([/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source, /(?!#) *(\\S[\\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join(\"|\"), \"g\"),\n      Ye = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\\r?\\n?/.source].join(\"|\")),\n      qe = function () {\n        function e() {}\n        return e.findGroup = function (e, t) {\n          for (var r = 0; r < e.length; r++) {\n            var i = e[r];\n            if (i.id === t) return i;\n          }\n        }, e.resolve = function (e, t) {\n          return g.buildAbsoluteURL(t, e, {\n            alwaysNormalize: !0\n          });\n        }, e.isMediaPlaylist = function (e) {\n          return je.test(e);\n        }, e.parseMasterPlaylist = function (t, r) {\n          var i,\n            a = {\n              contentSteering: null,\n              levels: [],\n              playlistParsingError: null,\n              sessionData: null,\n              sessionKeys: null,\n              startTimeOffset: null,\n              variableList: null,\n              hasVariableRefs: !1\n            },\n            n = [];\n          for (Ve.lastIndex = 0; null != (i = Ve.exec(t));) if (i[1]) {\n            var s,\n              o = new w(i[1]),\n              l = i[2],\n              u = {\n                attrs: o,\n                bitrate: o.decimalInteger(\"BANDWIDTH\") || o.decimalInteger(\"AVERAGE-BANDWIDTH\"),\n                name: o.NAME,\n                url: e.resolve(l, r)\n              },\n              d = o.decimalResolution(\"RESOLUTION\");\n            d && (u.width = d.width, u.height = d.height), Qe(o.CODECS, u), null != (s = u.unknownCodecs) && s.length || n.push(u), a.levels.push(u);\n          } else if (i[3]) {\n            var h = i[3],\n              f = i[4];\n            switch (h) {\n              case \"SESSION-DATA\":\n                var c = new w(f),\n                  v = c[\"DATA-ID\"];\n                v && (null === a.sessionData && (a.sessionData = {}), a.sessionData[v] = c);\n                break;\n              case \"SESSION-KEY\":\n                var g = ze(f, r);\n                g.encrypted && g.isSupported() ? (null === a.sessionKeys && (a.sessionKeys = []), a.sessionKeys.push(g)) : k.warn('[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: \"' + f + '\"');\n                break;\n              case \"DEFINE\":\n                break;\n              case \"CONTENT-STEERING\":\n                var m = new w(f);\n                a.contentSteering = {\n                  uri: e.resolve(m[\"SERVER-URI\"], r),\n                  pathwayId: m[\"PATHWAY-ID\"] || \".\"\n                };\n                break;\n              case \"START\":\n                a.startTimeOffset = Xe(f);\n            }\n          }\n          var p = n.length > 0 && n.length < a.levels.length;\n          return a.levels = p ? n : a.levels, 0 === a.levels.length && (a.playlistParsingError = new Error(\"no levels found in manifest\")), a;\n        }, e.parseMasterPlaylistMedia = function (t, r, i) {\n          var a,\n            n = {},\n            s = i.levels,\n            o = {\n              AUDIO: s.map(function (e) {\n                return {\n                  id: e.attrs.AUDIO,\n                  audioCodec: e.audioCodec\n                };\n              }),\n              SUBTITLES: s.map(function (e) {\n                return {\n                  id: e.attrs.SUBTITLES,\n                  textCodec: e.textCodec\n                };\n              }),\n              \"CLOSED-CAPTIONS\": []\n            },\n            l = 0;\n          for (Ke.lastIndex = 0; null !== (a = Ke.exec(t));) {\n            var u = new w(a[1]),\n              d = u.TYPE;\n            if (d) {\n              var h = o[d],\n                f = n[d] || [];\n              n[d] = f;\n              var c = u.LANGUAGE,\n                v = u[\"ASSOC-LANGUAGE\"],\n                g = u.CHANNELS,\n                m = u.CHARACTERISTICS,\n                p = u[\"INSTREAM-ID\"],\n                y = {\n                  attrs: u,\n                  bitrate: 0,\n                  id: l++,\n                  groupId: u[\"GROUP-ID\"] || \"\",\n                  name: u.NAME || c || \"\",\n                  type: d,\n                  default: u.bool(\"DEFAULT\"),\n                  autoselect: u.bool(\"AUTOSELECT\"),\n                  forced: u.bool(\"FORCED\"),\n                  lang: c,\n                  url: u.URI ? e.resolve(u.URI, r) : \"\"\n                };\n              if (v && (y.assocLang = v), g && (y.channels = g), m && (y.characteristics = m), p && (y.instreamId = p), null != h && h.length) {\n                var E = e.findGroup(h, y.groupId) || h[0];\n                Je(y, E, \"audioCodec\"), Je(y, E, \"textCodec\");\n              }\n              f.push(y);\n            }\n          }\n          return n;\n        }, e.parseLevelPlaylist = function (e, t, r, i, a, n) {\n          var s,\n            l,\n            u,\n            d = new G(t),\n            h = d.fragments,\n            f = null,\n            c = 0,\n            v = 0,\n            g = 0,\n            p = 0,\n            y = null,\n            E = new B(i, t),\n            T = -1,\n            S = !1,\n            L = null;\n          for (We.lastIndex = 0, d.m3u8 = e, d.hasVariableRefs = !1; null !== (s = We.exec(e));) {\n            S && (S = !1, (E = new B(i, t)).start = g, E.sn = c, E.cc = p, E.level = r, f && (E.initSegment = f, E.rawProgramDateTime = f.rawProgramDateTime, f.rawProgramDateTime = null, L && (E.setByteRange(L), L = null)));\n            var R = s[1];\n            if (R) {\n              E.duration = parseFloat(R);\n              var A = (\" \" + s[2]).slice(1);\n              E.title = A || null, E.tagList.push(A ? [\"INF\", R, A] : [\"INF\", R]);\n            } else if (s[3]) {\n              if (m(E.duration)) {\n                E.start = g, u && et(E, u, d), E.sn = c, E.level = r, E.cc = p, h.push(E);\n                var b = (\" \" + s[3]).slice(1);\n                E.relurl = b, $e(E, y), y = E, g += E.duration, c++, v = 0, S = !0;\n              }\n            } else if (s[4]) {\n              var D = (\" \" + s[4]).slice(1);\n              y ? E.setByteRange(D, y) : E.setByteRange(D);\n            } else if (s[5]) E.rawProgramDateTime = (\" \" + s[5]).slice(1), E.tagList.push([\"PROGRAM-DATE-TIME\", E.rawProgramDateTime]), -1 === T && (T = h.length);else {\n              if (!(s = s[0].match(Ye))) {\n                k.warn(\"No matches on slow regex match for level playlist!\");\n                continue;\n              }\n              for (l = 1; l < s.length && void 0 === s[l]; l++);\n              var _ = (\" \" + s[l]).slice(1),\n                x = (\" \" + s[l + 1]).slice(1),\n                C = s[l + 2] ? (\" \" + s[l + 2]).slice(1) : \"\";\n              switch (_) {\n                case \"PLAYLIST-TYPE\":\n                  d.type = x.toUpperCase();\n                  break;\n                case \"MEDIA-SEQUENCE\":\n                  c = d.startSN = parseInt(x);\n                  break;\n                case \"SKIP\":\n                  var P = new w(x),\n                    F = P.decimalInteger(\"SKIPPED-SEGMENTS\");\n                  if (m(F)) {\n                    d.skippedSegments = F;\n                    for (var O = F; O--;) h.unshift(null);\n                    c += F;\n                  }\n                  var M = P.enumeratedString(\"RECENTLY-REMOVED-DATERANGES\");\n                  M && (d.recentlyRemovedDateranges = M.split(\"\\t\"));\n                  break;\n                case \"TARGETDURATION\":\n                  d.targetduration = Math.max(parseInt(x), 1);\n                  break;\n                case \"VERSION\":\n                  d.version = parseInt(x);\n                  break;\n                case \"INDEPENDENT-SEGMENTS\":\n                case \"EXTM3U\":\n                case \"DEFINE\":\n                  break;\n                case \"ENDLIST\":\n                  d.live = !1;\n                  break;\n                case \"#\":\n                  (x || C) && E.tagList.push(C ? [x, C] : [x]);\n                  break;\n                case \"DISCONTINUITY\":\n                  p++, E.tagList.push([\"DIS\"]);\n                  break;\n                case \"GAP\":\n                  E.gap = !0, E.tagList.push([_]);\n                  break;\n                case \"BITRATE\":\n                  E.tagList.push([_, x]);\n                  break;\n                case \"DATERANGE\":\n                  var N = new w(x),\n                    H = new I(N, d.dateRanges[N.ID]);\n                  H.isValid || d.skippedSegments ? d.dateRanges[H.id] = H : k.warn('Ignoring invalid DATERANGE tag: \"' + x + '\"'), E.tagList.push([\"EXT-X-DATERANGE\", x]);\n                  break;\n                case \"DISCONTINUITY-SEQUENCE\":\n                  p = parseInt(x);\n                  break;\n                case \"KEY\":\n                  var V = ze(x, t);\n                  if (V.isSupported()) {\n                    if (\"NONE\" === V.method) {\n                      u = void 0;\n                      break;\n                    }\n                    u || (u = {}), u[V.keyFormat] && (u = o({}, u)), u[V.keyFormat] = V;\n                  } else k.warn('[Keys] Ignoring invalid EXT-X-KEY tag: \"' + x + '\"');\n                  break;\n                case \"START\":\n                  d.startTimeOffset = Xe(x);\n                  break;\n                case \"MAP\":\n                  var K = new w(x);\n                  if (E.duration) {\n                    var j = new B(i, t);\n                    Ze(j, K, r, u), f = j, E.initSegment = f, f.rawProgramDateTime && !E.rawProgramDateTime && (E.rawProgramDateTime = f.rawProgramDateTime);\n                  } else {\n                    var W = E.byteRangeEndOffset;\n                    if (W) {\n                      var Y = E.byteRangeStartOffset;\n                      L = W - Y + \"@\" + Y;\n                    } else L = null;\n                    Ze(E, K, r, u), f = E, S = !0;\n                  }\n                  break;\n                case \"SERVER-CONTROL\":\n                  var q = new w(x);\n                  d.canBlockReload = q.bool(\"CAN-BLOCK-RELOAD\"), d.canSkipUntil = q.optionalFloat(\"CAN-SKIP-UNTIL\", 0), d.canSkipDateRanges = d.canSkipUntil > 0 && q.bool(\"CAN-SKIP-DATERANGES\"), d.partHoldBack = q.optionalFloat(\"PART-HOLD-BACK\", 0), d.holdBack = q.optionalFloat(\"HOLD-BACK\", 0);\n                  break;\n                case \"PART-INF\":\n                  var z = new w(x);\n                  d.partTarget = z.decimalFloatingPoint(\"PART-TARGET\");\n                  break;\n                case \"PART\":\n                  var X = d.partList;\n                  X || (X = d.partList = []);\n                  var Q = v > 0 ? X[X.length - 1] : void 0,\n                    J = v++,\n                    $ = new w(x),\n                    Z = new U($, E, t, J, Q);\n                  X.push(Z), E.duration += Z.duration;\n                  break;\n                case \"PRELOAD-HINT\":\n                  var ee = new w(x);\n                  d.preloadHint = ee;\n                  break;\n                case \"RENDITION-REPORT\":\n                  var te = new w(x);\n                  d.renditionReports = d.renditionReports || [], d.renditionReports.push(te);\n                  break;\n                default:\n                  k.warn(\"line parsed but not handled: \" + s);\n              }\n            }\n          }\n          y && !y.relurl ? (h.pop(), g -= y.duration, d.partList && (d.fragmentHint = y)) : d.partList && ($e(E, y), E.cc = p, d.fragmentHint = E, u && et(E, u, d));\n          var re = h.length,\n            ie = h[0],\n            ae = h[re - 1];\n          if ((g += d.skippedSegments * d.targetduration) > 0 && re && ae) {\n            d.averagetargetduration = g / re;\n            var ne = ae.sn;\n            d.endSN = \"initSegment\" !== ne ? ne : 0, d.live || (ae.endList = !0), ie && (d.startCC = ie.cc);\n          } else d.endSN = 0, d.startCC = 0;\n          return d.fragmentHint && (g += d.fragmentHint.duration), d.totalduration = g, d.endCC = p, T > 0 && function (e, t) {\n            for (var r = e[t], i = t; i--;) {\n              var a = e[i];\n              if (!a) return;\n              a.programDateTime = r.programDateTime - 1e3 * a.duration, r = a;\n            }\n          }(h, T), d;\n        }, e;\n      }();\n    function ze(e, t, r) {\n      var i,\n        a,\n        n = new w(e),\n        s = null != (i = n.METHOD) ? i : \"\",\n        o = n.URI,\n        l = n.hexadecimalInteger(\"IV\"),\n        u = n.KEYFORMATVERSIONS,\n        d = null != (a = n.KEYFORMAT) ? a : \"identity\";\n      o && n.IV && !l && k.error(\"Invalid IV: \" + n.IV);\n      var h = o ? qe.resolve(o, t) : \"\",\n        f = (u || \"1\").split(\"/\").map(Number).filter(Number.isFinite);\n      return new we(s, h, d, f, l);\n    }\n    function Xe(e) {\n      var t = new w(e).decimalFloatingPoint(\"TIME-OFFSET\");\n      return m(t) ? t : null;\n    }\n    function Qe(e, t) {\n      var r = (e || \"\").split(/[ ,]+/).filter(function (e) {\n        return e;\n      });\n      [\"video\", \"audio\", \"text\"].forEach(function (e) {\n        var i = r.filter(function (t) {\n          return function (e, t) {\n            var r = Ie[t];\n            return !!r && !!r[e.slice(0, 4)];\n          }(t, e);\n        });\n        i.length && (t[e + \"Codec\"] = i.join(\",\"), r = r.filter(function (e) {\n          return -1 === i.indexOf(e);\n        }));\n      }), t.unknownCodecs = r;\n    }\n    function Je(e, t, r) {\n      var i = t[r];\n      i && (e[r] = i);\n    }\n    function $e(e, t) {\n      e.rawProgramDateTime ? e.programDateTime = Date.parse(e.rawProgramDateTime) : null != t && t.programDateTime && (e.programDateTime = t.endProgramDateTime), m(e.programDateTime) || (e.programDateTime = null, e.rawProgramDateTime = null);\n    }\n    function Ze(e, t, r, i) {\n      e.relurl = t.URI, t.BYTERANGE && e.setByteRange(t.BYTERANGE), e.level = r, e.sn = \"initSegment\", i && (e.levelkeys = i), e.initSegment = null;\n    }\n    function et(e, t, r) {\n      e.levelkeys = t;\n      var i = r.encryptedFragments;\n      i.length && i[i.length - 1].levelkeys === t || !Object.keys(t).some(function (e) {\n        return t[e].isCommonEncryption;\n      }) || i.push(e);\n    }\n    var tt = \"manifest\",\n      rt = \"level\",\n      it = \"audioTrack\",\n      at = \"subtitleTrack\",\n      nt = \"main\",\n      st = \"audio\",\n      ot = \"subtitle\";\n    function lt(e) {\n      switch (e.type) {\n        case it:\n          return st;\n        case at:\n          return ot;\n        default:\n          return nt;\n      }\n    }\n    function ut(e, t) {\n      var r = e.url;\n      return void 0 !== r && 0 !== r.indexOf(\"data:\") || (r = t.url), r;\n    }\n    var dt = function () {\n      function e(e) {\n        this.hls = void 0, this.loaders = Object.create(null), this.variableList = null, this.hls = e, this.registerListeners();\n      }\n      var t = e.prototype;\n      return t.startLoad = function (e) {}, t.stopLoad = function () {\n        this.destroyInternalLoaders();\n      }, t.registerListeners = function () {\n        var e = this.hls;\n        e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.LEVEL_LOADING, this.onLevelLoading, this), e.on(E.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(E.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n      }, t.unregisterListeners = function () {\n        var e = this.hls;\n        e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.LEVEL_LOADING, this.onLevelLoading, this), e.off(E.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(E.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n      }, t.createInternalLoader = function (e) {\n        var t = this.hls.config,\n          r = t.pLoader,\n          i = t.loader,\n          a = new (r || i)(t);\n        return this.loaders[e.type] = a, a;\n      }, t.getInternalLoader = function (e) {\n        return this.loaders[e.type];\n      }, t.resetInternalLoader = function (e) {\n        this.loaders[e] && delete this.loaders[e];\n      }, t.destroyInternalLoaders = function () {\n        for (var e in this.loaders) {\n          var t = this.loaders[e];\n          t && t.destroy(), this.resetInternalLoader(e);\n        }\n      }, t.destroy = function () {\n        this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders();\n      }, t.onManifestLoading = function (e, t) {\n        var r = t.url;\n        this.variableList = null, this.load({\n          id: null,\n          level: 0,\n          responseType: \"text\",\n          type: tt,\n          url: r,\n          deliveryDirectives: null\n        });\n      }, t.onLevelLoading = function (e, t) {\n        var r = t.id,\n          i = t.level,\n          a = t.pathwayId,\n          n = t.url,\n          s = t.deliveryDirectives;\n        this.load({\n          id: r,\n          level: i,\n          pathwayId: a,\n          responseType: \"text\",\n          type: rt,\n          url: n,\n          deliveryDirectives: s\n        });\n      }, t.onAudioTrackLoading = function (e, t) {\n        var r = t.id,\n          i = t.groupId,\n          a = t.url,\n          n = t.deliveryDirectives;\n        this.load({\n          id: r,\n          groupId: i,\n          level: null,\n          responseType: \"text\",\n          type: it,\n          url: a,\n          deliveryDirectives: n\n        });\n      }, t.onSubtitleTrackLoading = function (e, t) {\n        var r = t.id,\n          i = t.groupId,\n          a = t.url,\n          n = t.deliveryDirectives;\n        this.load({\n          id: r,\n          groupId: i,\n          level: null,\n          responseType: \"text\",\n          type: at,\n          url: a,\n          deliveryDirectives: n\n        });\n      }, t.load = function (e) {\n        var t,\n          r,\n          i,\n          a = this,\n          n = this.hls.config,\n          s = this.getInternalLoader(e);\n        if (s) {\n          var l = s.context;\n          if (l && l.url === e.url && l.level === e.level) return void k.trace(\"[playlist-loader]: playlist request ongoing\");\n          k.log(\"[playlist-loader]: aborting previous loader for type: \" + e.type), s.abort();\n        }\n        if (r = e.type === tt ? n.manifestLoadPolicy.default : o({}, n.playlistLoadPolicy.default, {\n          timeoutRetry: null,\n          errorRetry: null\n        }), s = this.createInternalLoader(e), m(null == (t = e.deliveryDirectives) ? void 0 : t.part) && (e.type === rt && null !== e.level ? i = this.hls.levels[e.level].details : e.type === it && null !== e.id ? i = this.hls.audioTracks[e.id].details : e.type === at && null !== e.id && (i = this.hls.subtitleTracks[e.id].details), i)) {\n          var u = i.partTarget,\n            d = i.targetduration;\n          if (u && d) {\n            var h = 1e3 * Math.max(3 * u, .8 * d);\n            r = o({}, r, {\n              maxTimeToFirstByteMs: Math.min(h, r.maxTimeToFirstByteMs),\n              maxLoadTimeMs: Math.min(h, r.maxTimeToFirstByteMs)\n            });\n          }\n        }\n        var f = r.errorRetry || r.timeoutRetry || {},\n          c = {\n            loadPolicy: r,\n            timeout: r.maxLoadTimeMs,\n            maxRetry: f.maxNumRetry || 0,\n            retryDelay: f.retryDelayMs || 0,\n            maxRetryDelay: f.maxRetryDelayMs || 0\n          },\n          v = {\n            onSuccess: function (e, t, r, i) {\n              var n = a.getInternalLoader(r);\n              a.resetInternalLoader(r.type);\n              var s = e.data;\n              0 === s.indexOf(\"#EXTM3U\") ? (t.parsing.start = performance.now(), qe.isMediaPlaylist(s) ? a.handleTrackOrLevelPlaylist(e, t, r, i || null, n) : a.handleMasterPlaylist(e, t, r, i)) : a.handleManifestParsingError(e, r, new Error(\"no EXTM3U delimiter\"), i || null, t);\n            },\n            onError: function (e, t, r, i) {\n              a.handleNetworkError(t, r, !1, e, i);\n            },\n            onTimeout: function (e, t, r) {\n              a.handleNetworkError(t, r, !0, void 0, e);\n            }\n          };\n        s.load(e, c, v);\n      }, t.handleMasterPlaylist = function (e, t, r, i) {\n        var a = this.hls,\n          n = e.data,\n          s = ut(e, r),\n          o = qe.parseMasterPlaylist(n, s);\n        if (o.playlistParsingError) this.handleManifestParsingError(e, r, o.playlistParsingError, i, t);else {\n          var l = o.contentSteering,\n            u = o.levels,\n            d = o.sessionData,\n            h = o.sessionKeys,\n            f = o.startTimeOffset,\n            c = o.variableList;\n          this.variableList = c;\n          var v = qe.parseMasterPlaylistMedia(n, s, o),\n            g = v.AUDIO,\n            m = void 0 === g ? [] : g,\n            p = v.SUBTITLES,\n            y = v[\"CLOSED-CAPTIONS\"];\n          m.length && (m.some(function (e) {\n            return !e.url;\n          }) || !u[0].audioCodec || u[0].attrs.AUDIO || (k.log(\"[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one\"), m.unshift({\n            type: \"main\",\n            name: \"main\",\n            groupId: \"main\",\n            default: !1,\n            autoselect: !1,\n            forced: !1,\n            id: -1,\n            attrs: new w({}),\n            bitrate: 0,\n            url: \"\"\n          }))), a.trigger(E.MANIFEST_LOADED, {\n            levels: u,\n            audioTracks: m,\n            subtitles: p,\n            captions: y,\n            contentSteering: l,\n            url: s,\n            stats: t,\n            networkDetails: i,\n            sessionData: d,\n            sessionKeys: h,\n            startTimeOffset: f,\n            variableList: c\n          });\n        }\n      }, t.handleTrackOrLevelPlaylist = function (e, t, r, i, a) {\n        var n = this.hls,\n          s = r.id,\n          o = r.level,\n          l = r.type,\n          u = ut(e, r),\n          d = m(o) ? o : m(s) ? s : 0,\n          h = lt(r),\n          f = qe.parseLevelPlaylist(e.data, u, d, h, 0, this.variableList);\n        if (l === tt) {\n          var c = {\n            attrs: new w({}),\n            bitrate: 0,\n            details: f,\n            name: \"\",\n            url: u\n          };\n          n.trigger(E.MANIFEST_LOADED, {\n            levels: [c],\n            audioTracks: [],\n            url: u,\n            stats: t,\n            networkDetails: i,\n            sessionData: null,\n            sessionKeys: null,\n            contentSteering: null,\n            startTimeOffset: null,\n            variableList: null\n          });\n        }\n        t.parsing.end = performance.now(), r.levelDetails = f, this.handlePlaylistLoaded(f, e, t, r, i, a);\n      }, t.handleManifestParsingError = function (e, t, r, i, a) {\n        this.hls.trigger(E.ERROR, {\n          type: T.NETWORK_ERROR,\n          details: S.MANIFEST_PARSING_ERROR,\n          fatal: t.type === tt,\n          url: e.url,\n          err: r,\n          error: r,\n          reason: r.message,\n          response: e,\n          context: t,\n          networkDetails: i,\n          stats: a\n        });\n      }, t.handleNetworkError = function (e, t, r, a, n) {\n        void 0 === r && (r = !1);\n        var s = \"A network \" + (r ? \"timeout\" : \"error\" + (a ? \" (status \" + a.code + \")\" : \"\")) + \" occurred while loading \" + e.type;\n        e.type === rt ? s += \": \" + e.level + \" id: \" + e.id : e.type !== it && e.type !== at || (s += \" id: \" + e.id + ' group-id: \"' + e.groupId + '\"');\n        var o = new Error(s);\n        k.warn(\"[playlist-loader]: \" + s);\n        var l = S.UNKNOWN,\n          u = !1,\n          d = this.getInternalLoader(e);\n        switch (e.type) {\n          case tt:\n            l = r ? S.MANIFEST_LOAD_TIMEOUT : S.MANIFEST_LOAD_ERROR, u = !0;\n            break;\n          case rt:\n            l = r ? S.LEVEL_LOAD_TIMEOUT : S.LEVEL_LOAD_ERROR, u = !1;\n            break;\n          case it:\n            l = r ? S.AUDIO_TRACK_LOAD_TIMEOUT : S.AUDIO_TRACK_LOAD_ERROR, u = !1;\n            break;\n          case at:\n            l = r ? S.SUBTITLE_TRACK_LOAD_TIMEOUT : S.SUBTITLE_LOAD_ERROR, u = !1;\n        }\n        d && this.resetInternalLoader(e.type);\n        var h = {\n          type: T.NETWORK_ERROR,\n          details: l,\n          fatal: u,\n          url: e.url,\n          loader: d,\n          context: e,\n          error: o,\n          networkDetails: t,\n          stats: n\n        };\n        if (a) {\n          var f = (null == t ? void 0 : t.url) || e.url;\n          h.response = i({\n            url: f,\n            data: void 0\n          }, a);\n        }\n        this.hls.trigger(E.ERROR, h);\n      }, t.handlePlaylistLoaded = function (e, t, r, i, a, n) {\n        var s = this.hls,\n          o = i.type,\n          l = i.level,\n          u = i.id,\n          d = i.groupId,\n          h = i.deliveryDirectives,\n          f = ut(t, i),\n          c = lt(i),\n          v = \"number\" == typeof i.level && c === nt ? l : void 0;\n        if (e.fragments.length) {\n          e.targetduration || (e.playlistParsingError = new Error(\"Missing Target Duration\"));\n          var g = e.playlistParsingError;\n          if (g) s.trigger(E.ERROR, {\n            type: T.NETWORK_ERROR,\n            details: S.LEVEL_PARSING_ERROR,\n            fatal: !1,\n            url: f,\n            error: g,\n            reason: g.message,\n            response: t,\n            context: i,\n            level: v,\n            parent: c,\n            networkDetails: a,\n            stats: r\n          });else switch (e.live && n && (n.getCacheAge && (e.ageHeader = n.getCacheAge() || 0), n.getCacheAge && !isNaN(e.ageHeader) || (e.ageHeader = 0)), o) {\n            case tt:\n            case rt:\n              s.trigger(E.LEVEL_LOADED, {\n                details: e,\n                level: v || 0,\n                id: u || 0,\n                stats: r,\n                networkDetails: a,\n                deliveryDirectives: h\n              });\n              break;\n            case it:\n              s.trigger(E.AUDIO_TRACK_LOADED, {\n                details: e,\n                id: u || 0,\n                groupId: d || \"\",\n                stats: r,\n                networkDetails: a,\n                deliveryDirectives: h\n              });\n              break;\n            case at:\n              s.trigger(E.SUBTITLE_TRACK_LOADED, {\n                details: e,\n                id: u || 0,\n                groupId: d || \"\",\n                stats: r,\n                networkDetails: a,\n                deliveryDirectives: h\n              });\n          }\n        } else {\n          var m = new Error(\"No Segments found in Playlist\");\n          s.trigger(E.ERROR, {\n            type: T.NETWORK_ERROR,\n            details: S.LEVEL_EMPTY_ERROR,\n            fatal: !1,\n            url: f,\n            error: m,\n            reason: m.message,\n            response: t,\n            context: i,\n            level: v,\n            parent: c,\n            networkDetails: a,\n            stats: r\n          });\n        }\n      }, e;\n    }();\n    function ht(e, t) {\n      var r;\n      try {\n        r = new Event(\"addtrack\");\n      } catch (e) {\n        (r = document.createEvent(\"Event\")).initEvent(\"addtrack\", !1, !1);\n      }\n      r.track = e, t.dispatchEvent(r);\n    }\n    function ft(e, t, r, i) {\n      var a = e.mode;\n      if (\"disabled\" === a && (e.mode = \"hidden\"), e.cues && e.cues.length > 0) for (var n = function (e, t, r) {\n          var i = [],\n            a = function (e, t) {\n              if (t < e[0].startTime) return 0;\n              var r = e.length - 1;\n              if (t > e[r].endTime) return -1;\n              for (var i = 0, a = r; i <= a;) {\n                var n = Math.floor((a + i) / 2);\n                if (t < e[n].startTime) a = n - 1;else {\n                  if (!(t > e[n].startTime && i < r)) return n;\n                  i = n + 1;\n                }\n              }\n              return e[i].startTime - t < t - e[a].startTime ? i : a;\n            }(e, t);\n          if (a > -1) for (var n = a, s = e.length; n < s; n++) {\n            var o = e[n];\n            if (o.startTime >= t && o.endTime <= r) i.push(o);else if (o.startTime > r) return i;\n          }\n          return i;\n        }(e.cues, t, r), s = 0; s < n.length; s++) i && !i(n[s]) || e.removeCue(n[s]);\n      \"disabled\" === a && (e.mode = a);\n    }\n    var ct = \"org.id3\",\n      vt = \"com.apple.quicktime.HLS\",\n      gt = \"https://aomedia.org/emsg/ID3\";\n    function mt() {\n      if (\"undefined\" != typeof self) return self.VTTCue || self.TextTrackCue;\n    }\n    function pt(e, t, r, a, n) {\n      var s = new e(t, r, \"\");\n      try {\n        s.value = a, n && (s.type = n);\n      } catch (o) {\n        s = new e(t, r, JSON.stringify(n ? i({\n          type: n\n        }, a) : a));\n      }\n      return s;\n    }\n    var yt = function () {\n      var e = mt();\n      try {\n        e && new e(0, Number.POSITIVE_INFINITY, \"\");\n      } catch (e) {\n        return Number.MAX_VALUE;\n      }\n      return Number.POSITIVE_INFINITY;\n    }();\n    function Et(e, t) {\n      return e.getTime() / 1e3 - t;\n    }\n    var Tt = function () {\n        function e(e) {\n          this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = e, this._registerListeners();\n        }\n        var t = e.prototype;\n        return t.destroy = function () {\n          this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = null;\n        }, t._registerListeners = function () {\n          var e = this.hls;\n          e.on(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(E.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(E.LEVEL_UPDATED, this.onLevelUpdated, this);\n        }, t._unregisterListeners = function () {\n          var e = this.hls;\n          e.off(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(E.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(E.LEVEL_UPDATED, this.onLevelUpdated, this);\n        }, t.onMediaAttached = function (e, t) {\n          this.media = t.media;\n        }, t.onMediaDetaching = function () {\n          this.id3Track && (function (e) {\n            var t = e.mode;\n            if (\"disabled\" === t && (e.mode = \"hidden\"), e.cues) for (var r = e.cues.length; r--;) e.removeCue(e.cues[r]);\n            \"disabled\" === t && (e.mode = t);\n          }(this.id3Track), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {});\n        }, t.onManifestLoading = function () {\n          this.dateRangeCuesAppended = {};\n        }, t.createTrack = function (e) {\n          var t = this.getID3Track(e.textTracks);\n          return t.mode = \"hidden\", t;\n        }, t.getID3Track = function (e) {\n          if (this.media) {\n            for (var t = 0; t < e.length; t++) {\n              var r = e[t];\n              if (\"metadata\" === r.kind && \"id3\" === r.label) return ht(r, this.media), r;\n            }\n            return this.media.addTextTrack(\"metadata\", \"id3\");\n          }\n        }, t.onFragParsingMetadata = function (e, t) {\n          if (this.media) {\n            var r = this.hls.config,\n              i = r.enableEmsgMetadataCues,\n              a = r.enableID3MetadataCues;\n            if (i || a) {\n              var n = t.samples;\n              this.id3Track || (this.id3Track = this.createTrack(this.media));\n              var s = mt();\n              if (s) for (var o = 0; o < n.length; o++) {\n                var l = n[o].type;\n                if ((l !== gt || i) && a) {\n                  var u = $(n[o].data);\n                  if (u) {\n                    var d = n[o].pts,\n                      h = d + n[o].duration;\n                    h > yt && (h = yt), h - d <= 0 && (h = d + .25);\n                    for (var f = 0; f < u.length; f++) {\n                      var c = u[f];\n                      if (!Q(c)) {\n                        this.updateId3CueEnds(d, l);\n                        var v = pt(s, d, h, c, l);\n                        v && this.id3Track.addCue(v);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }, t.updateId3CueEnds = function (e, t) {\n          var r,\n            i = null == (r = this.id3Track) ? void 0 : r.cues;\n          if (i) for (var a = i.length; a--;) {\n            var n = i[a];\n            n.type === t && n.startTime < e && n.endTime === yt && (n.endTime = e);\n          }\n        }, t.onBufferFlushing = function (e, t) {\n          var r = t.startOffset,\n            i = t.endOffset,\n            a = t.type,\n            n = this.id3Track,\n            s = this.hls;\n          if (s) {\n            var o = s.config,\n              l = o.enableEmsgMetadataCues,\n              u = o.enableID3MetadataCues;\n            n && (l || u) && ft(n, r, i, \"audio\" === a ? function (e) {\n              return e.type === ct && u;\n            } : \"video\" === a ? function (e) {\n              return e.type === gt && l;\n            } : function (e) {\n              return e.type === ct && u || e.type === gt && l;\n            });\n          }\n        }, t.onLevelUpdated = function (e, t) {\n          var r = this,\n            i = t.details;\n          if (this.media && i.hasProgramDateTime && this.hls.config.enableDateRangeMetadataCues) {\n            var a = this.dateRangeCuesAppended,\n              n = this.id3Track,\n              s = i.dateRanges,\n              o = Object.keys(s);\n            if (n) for (var l = Object.keys(a).filter(function (e) {\n                return !o.includes(e);\n              }), u = function () {\n                var e = l[d];\n                Object.keys(a[e].cues).forEach(function (t) {\n                  n.removeCue(a[e].cues[t]);\n                }), delete a[e];\n              }, d = l.length; d--;) u();\n            var h = i.fragments[i.fragments.length - 1];\n            if (0 !== o.length && m(null == h ? void 0 : h.programDateTime)) {\n              this.id3Track || (this.id3Track = this.createTrack(this.media));\n              for (var f = h.programDateTime / 1e3 - h.start, c = mt(), v = function () {\n                  var e = o[g],\n                    t = s[e],\n                    i = Et(t.startDate, f),\n                    n = a[e],\n                    l = (null == n ? void 0 : n.cues) || {},\n                    u = (null == n ? void 0 : n.durationKnown) || !1,\n                    d = yt,\n                    h = t.endDate;\n                  if (h) d = Et(h, f), u = !0;else if (t.endOnNext && !u) {\n                    var v = o.reduce(function (e, r) {\n                      if (r !== t.id) {\n                        var i = s[r];\n                        if (i.class === t.class && i.startDate > t.startDate && (!e || t.startDate < e.startDate)) return i;\n                      }\n                      return e;\n                    }, null);\n                    v && (d = Et(v.startDate, f), u = !0);\n                  }\n                  for (var m, p, y = Object.keys(t.attr), E = 0; E < y.length; E++) {\n                    var T = y[E];\n                    if (\"ID\" !== (p = T) && \"CLASS\" !== p && \"START-DATE\" !== p && \"DURATION\" !== p && \"END-DATE\" !== p && \"END-ON-NEXT\" !== p) {\n                      var S = l[T];\n                      if (S) u && !n.durationKnown && (S.endTime = d);else if (c) {\n                        var L = t.attr[T];\n                        C(T) && (m = L, L = Uint8Array.from(m.replace(/^0x/, \"\").replace(/([\\da-fA-F]{2}) ?/g, \"0x$1 \").replace(/ +$/, \"\").split(\" \")).buffer);\n                        var R = pt(c, i, d, {\n                          key: T,\n                          data: L\n                        }, vt);\n                        R && (R.id = e, r.id3Track.addCue(R), l[T] = R);\n                      }\n                    }\n                  }\n                  a[e] = {\n                    cues: l,\n                    dateRange: t,\n                    durationKnown: u\n                  };\n                }, g = 0; g < o.length; g++) v();\n            }\n          }\n        }, e;\n      }(),\n      St = function () {\n        function e(e) {\n          var t = this;\n          this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = function () {\n            return t.timeupdate();\n          }, this.hls = e, this.config = e.config, this.registerListeners();\n        }\n        var t = e.prototype;\n        return t.destroy = function () {\n          this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null;\n        }, t.registerListeners = function () {\n          this.hls.on(E.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(E.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(E.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(E.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(E.ERROR, this.onError, this);\n        }, t.unregisterListeners = function () {\n          this.hls.off(E.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(E.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.off(E.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(E.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.off(E.ERROR, this.onError, this);\n        }, t.onMediaAttached = function (e, t) {\n          this.media = t.media, this.media.addEventListener(\"timeupdate\", this.timeupdateHandler);\n        }, t.onMediaDetaching = function () {\n          this.media && (this.media.removeEventListener(\"timeupdate\", this.timeupdateHandler), this.media = null);\n        }, t.onManifestLoading = function () {\n          this.levelDetails = null, this._latency = null, this.stallCount = 0;\n        }, t.onLevelUpdated = function (e, t) {\n          var r = t.details;\n          this.levelDetails = r, r.advanced && this.timeupdate(), !r.live && this.media && this.media.removeEventListener(\"timeupdate\", this.timeupdateHandler);\n        }, t.onError = function (e, t) {\n          var r;\n          t.details === S.BUFFER_STALLED_ERROR && (this.stallCount++, null != (r = this.levelDetails) && r.live && k.warn(\"[playback-rate-controller]: Stall detected, adjusting target latency\"));\n        }, t.timeupdate = function () {\n          var e = this.media,\n            t = this.levelDetails;\n          if (e && t) {\n            this.currentTime = e.currentTime;\n            var r = this.computeLatency();\n            if (null !== r) {\n              this._latency = r;\n              var i = this.config,\n                a = i.lowLatencyMode,\n                n = i.maxLiveSyncPlaybackRate;\n              if (a && 1 !== n && t.live) {\n                var s = this.targetLatency;\n                if (null !== s) {\n                  var o = r - s;\n                  if (o < Math.min(this.maxLatency, s + t.targetduration) && o > .05 && this.forwardBufferLength > 1) {\n                    var l = Math.min(2, Math.max(1, n)),\n                      u = Math.round(2 / (1 + Math.exp(-.75 * o - this.edgeStalled)) * 20) / 20;\n                    e.playbackRate = Math.min(l, Math.max(1, u));\n                  } else 1 !== e.playbackRate && 0 !== e.playbackRate && (e.playbackRate = 1);\n                }\n              }\n            }\n          }\n        }, t.estimateLiveEdge = function () {\n          var e = this.levelDetails;\n          return null === e ? null : e.edge + e.age;\n        }, t.computeLatency = function () {\n          var e = this.estimateLiveEdge();\n          return null === e ? null : e - this.currentTime;\n        }, s(e, [{\n          key: \"latency\",\n          get: function () {\n            return this._latency || 0;\n          }\n        }, {\n          key: \"maxLatency\",\n          get: function () {\n            var e = this.config,\n              t = this.levelDetails;\n            return void 0 !== e.liveMaxLatencyDuration ? e.liveMaxLatencyDuration : t ? e.liveMaxLatencyDurationCount * t.targetduration : 0;\n          }\n        }, {\n          key: \"targetLatency\",\n          get: function () {\n            var e = this.levelDetails;\n            if (null === e) return null;\n            var t = e.holdBack,\n              r = e.partHoldBack,\n              i = e.targetduration,\n              a = this.config,\n              n = a.liveSyncDuration,\n              s = a.liveSyncDurationCount,\n              o = a.lowLatencyMode,\n              l = this.hls.userConfig,\n              u = o && r || t;\n            (l.liveSyncDuration || l.liveSyncDurationCount || 0 === u) && (u = void 0 !== n ? n : s * i);\n            var d = i;\n            return u + Math.min(1 * this.stallCount, d);\n          }\n        }, {\n          key: \"liveSyncPosition\",\n          get: function () {\n            var e = this.estimateLiveEdge(),\n              t = this.targetLatency,\n              r = this.levelDetails;\n            if (null === e || null === t || null === r) return null;\n            var i = r.edge,\n              a = e - t - this.edgeStalled,\n              n = i - r.totalduration,\n              s = i - (this.config.lowLatencyMode && r.partTarget || r.targetduration);\n            return Math.min(Math.max(n, a), s);\n          }\n        }, {\n          key: \"drift\",\n          get: function () {\n            var e = this.levelDetails;\n            return null === e ? 1 : e.drift;\n          }\n        }, {\n          key: \"edgeStalled\",\n          get: function () {\n            var e = this.levelDetails;\n            if (null === e) return 0;\n            var t = 3 * (this.config.lowLatencyMode && e.partTarget || e.targetduration);\n            return Math.max(e.age - t, 0);\n          }\n        }, {\n          key: \"forwardBufferLength\",\n          get: function () {\n            var e = this.media,\n              t = this.levelDetails;\n            if (!e || !t) return 0;\n            var r = e.buffered.length;\n            return (r ? e.buffered.end(r - 1) : t.edge) - this.currentTime;\n          }\n        }]), e;\n      }(),\n      Lt = [\"NONE\", \"TYPE-0\", \"TYPE-1\", null],\n      Rt = [\"SDR\", \"PQ\", \"HLG\"],\n      At = \"\",\n      bt = \"YES\",\n      Dt = \"v2\",\n      kt = function () {\n        function e(e, t, r) {\n          this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = t, this.skip = r;\n        }\n        return e.prototype.addDirectives = function (e) {\n          var t = new self.URL(e);\n          return void 0 !== this.msn && t.searchParams.set(\"_HLS_msn\", this.msn.toString()), void 0 !== this.part && t.searchParams.set(\"_HLS_part\", this.part.toString()), this.skip && t.searchParams.set(\"_HLS_skip\", this.skip), t.href;\n        }, e;\n      }(),\n      _t = function () {\n        function e(e) {\n          this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.url = void 0, this.frameRate = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.supportedPromise = void 0, this.supportedResult = void 0, this._avgBitrate = 0, this._audioGroups = void 0, this._subtitleGroups = void 0, this._urlId = 0, this.url = [e.url], this._attrs = [e.attrs], this.bitrate = e.bitrate, e.details && (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.frameRate = e.attrs.optionalFloat(\"FRAME-RATE\", 0), this._avgBitrate = e.attrs.decimalInteger(\"AVERAGE-BANDWIDTH\"), this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.codecSet = [e.videoCodec, e.audioCodec].filter(function (e) {\n            return !!e;\n          }).map(function (e) {\n            return e.substring(0, 4);\n          }).join(\",\"), this.addGroupId(\"audio\", e.attrs.AUDIO), this.addGroupId(\"text\", e.attrs.SUBTITLES);\n        }\n        var t = e.prototype;\n        return t.hasAudioGroup = function (e) {\n          return xt(this._audioGroups, e);\n        }, t.hasSubtitleGroup = function (e) {\n          return xt(this._subtitleGroups, e);\n        }, t.addGroupId = function (e, t) {\n          if (t) if (\"audio\" === e) {\n            var r = this._audioGroups;\n            r || (r = this._audioGroups = []), -1 === r.indexOf(t) && r.push(t);\n          } else if (\"text\" === e) {\n            var i = this._subtitleGroups;\n            i || (i = this._subtitleGroups = []), -1 === i.indexOf(t) && i.push(t);\n          }\n        }, t.addFallback = function () {}, s(e, [{\n          key: \"maxBitrate\",\n          get: function () {\n            return Math.max(this.realBitrate, this.bitrate);\n          }\n        }, {\n          key: \"averageBitrate\",\n          get: function () {\n            return this._avgBitrate || this.realBitrate || this.bitrate;\n          }\n        }, {\n          key: \"attrs\",\n          get: function () {\n            return this._attrs[0];\n          }\n        }, {\n          key: \"codecs\",\n          get: function () {\n            return this.attrs.CODECS || \"\";\n          }\n        }, {\n          key: \"pathwayId\",\n          get: function () {\n            return this.attrs[\"PATHWAY-ID\"] || \".\";\n          }\n        }, {\n          key: \"videoRange\",\n          get: function () {\n            return this.attrs[\"VIDEO-RANGE\"] || \"SDR\";\n          }\n        }, {\n          key: \"score\",\n          get: function () {\n            return this.attrs.optionalFloat(\"SCORE\", 0);\n          }\n        }, {\n          key: \"uri\",\n          get: function () {\n            return this.url[0] || \"\";\n          }\n        }, {\n          key: \"audioGroups\",\n          get: function () {\n            return this._audioGroups;\n          }\n        }, {\n          key: \"subtitleGroups\",\n          get: function () {\n            return this._subtitleGroups;\n          }\n        }, {\n          key: \"urlId\",\n          get: function () {\n            return 0;\n          },\n          set: function (e) {}\n        }, {\n          key: \"audioGroupIds\",\n          get: function () {\n            return this.audioGroups ? [this.audioGroupId] : void 0;\n          }\n        }, {\n          key: \"textGroupIds\",\n          get: function () {\n            return this.subtitleGroups ? [this.textGroupId] : void 0;\n          }\n        }, {\n          key: \"audioGroupId\",\n          get: function () {\n            var e;\n            return null == (e = this.audioGroups) ? void 0 : e[0];\n          }\n        }, {\n          key: \"textGroupId\",\n          get: function () {\n            var e;\n            return null == (e = this.subtitleGroups) ? void 0 : e[0];\n          }\n        }]), e;\n      }();\n    function xt(e, t) {\n      return !(!t || !e) && -1 !== e.indexOf(t);\n    }\n    function wt(e, t) {\n      var r = t.startPTS;\n      if (m(r)) {\n        var i,\n          a = 0;\n        t.sn > e.sn ? (a = r - e.start, i = e) : (a = e.start - r, i = t), i.duration !== a && (i.duration = a);\n      } else t.sn > e.sn ? e.cc === t.cc && e.minEndPTS ? t.start = e.start + (e.minEndPTS - e.start) : t.start = e.start + e.duration : t.start = Math.max(e.start - t.duration, 0);\n    }\n    function Ct(e, t, r, i, a, n) {\n      i - r <= 0 && (k.warn(\"Fragment should have a positive duration\", t), i = r + t.duration, n = a + t.duration);\n      var s = r,\n        o = i,\n        l = t.startPTS,\n        u = t.endPTS;\n      if (m(l)) {\n        var d = Math.abs(l - r);\n        m(t.deltaPTS) ? t.deltaPTS = Math.max(d, t.deltaPTS) : t.deltaPTS = d, s = Math.max(r, l), r = Math.min(r, l), a = Math.min(a, t.startDTS), o = Math.min(i, u), i = Math.max(i, u), n = Math.max(n, t.endDTS);\n      }\n      var h = r - t.start;\n      0 !== t.start && (t.start = r), t.duration = i - t.start, t.startPTS = r, t.maxStartPTS = s, t.startDTS = a, t.endPTS = i, t.minEndPTS = o, t.endDTS = n;\n      var f,\n        c = t.sn;\n      if (!e || c < e.startSN || c > e.endSN) return 0;\n      var v = c - e.startSN,\n        g = e.fragments;\n      for (g[v] = t, f = v; f > 0; f--) wt(g[f], g[f - 1]);\n      for (f = v; f < g.length - 1; f++) wt(g[f], g[f + 1]);\n      return e.fragmentHint && wt(g[g.length - 1], e.fragmentHint), e.PTSKnown = e.alignedSliding = !0, h;\n    }\n    function It(e, t) {\n      for (var r = null, i = e.fragments, a = i.length - 1; a >= 0; a--) {\n        var n = i[a].initSegment;\n        if (n) {\n          r = n;\n          break;\n        }\n      }\n      e.fragmentHint && delete e.fragmentHint.endPTS;\n      var s,\n        l,\n        u,\n        d,\n        h,\n        f = 0;\n      if (function (e, t, r) {\n        for (var i = t.skippedSegments, a = Math.max(e.startSN, t.startSN) - t.startSN, n = (e.fragmentHint ? 1 : 0) + (i ? t.endSN : Math.min(e.endSN, t.endSN)) - t.startSN, s = t.startSN - e.startSN, o = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments, l = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments, u = a; u <= n; u++) {\n          var d = l[s + u],\n            h = o[u];\n          i && !h && u < i && (h = t.fragments[u] = d), d && h && r(d, h);\n        }\n      }(e, t, function (e, i) {\n        e.relurl && (f = e.cc - i.cc), m(e.startPTS) && m(e.endPTS) && (i.start = i.startPTS = e.startPTS, i.startDTS = e.startDTS, i.maxStartPTS = e.maxStartPTS, i.endPTS = e.endPTS, i.endDTS = e.endDTS, i.minEndPTS = e.minEndPTS, i.duration = e.endPTS - e.startPTS, i.duration && (s = i), t.PTSKnown = t.alignedSliding = !0), i.elementaryStreams = e.elementaryStreams, i.loader = e.loader, i.stats = e.stats, e.initSegment && (i.initSegment = e.initSegment, r = e.initSegment);\n      }), r && (t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments).forEach(function (e) {\n        var t;\n        !e || e.initSegment && e.initSegment.relurl !== (null == (t = r) ? void 0 : t.relurl) || (e.initSegment = r);\n      }), t.skippedSegments) if (t.deltaUpdateFailed = t.fragments.some(function (e) {\n        return !e;\n      }), t.deltaUpdateFailed) {\n        k.warn(\"[level-helper] Previous playlist missing segments skipped in delta playlist\");\n        for (var c = t.skippedSegments; c--;) t.fragments.shift();\n        t.startSN = t.fragments[0].sn, t.startCC = t.fragments[0].cc;\n      } else t.canSkipDateRanges && (t.dateRanges = (l = e.dateRanges, u = t.dateRanges, d = t.recentlyRemovedDateranges, h = o({}, l), d && d.forEach(function (e) {\n        delete h[e];\n      }), Object.keys(u).forEach(function (e) {\n        var t = new I(u[e].attr, h[e]);\n        t.isValid ? h[e] = t : k.warn('Ignoring invalid Playlist Delta Update DATERANGE tag: \"' + JSON.stringify(u[e].attr) + '\"');\n      }), h));\n      var v = t.fragments;\n      if (f) {\n        k.warn(\"discontinuity sliding from playlist, take drift into account\");\n        for (var g = 0; g < v.length; g++) v[g].cc += f;\n      }\n      t.skippedSegments && (t.startCC = t.fragments[0].cc), function (e, t, r) {\n        if (e && t) for (var i = 0, a = 0, n = e.length; a <= n; a++) {\n          var s = e[a],\n            o = t[a + i];\n          s && o && s.index === o.index && s.fragment.sn === o.fragment.sn ? r(s, o) : i--;\n        }\n      }(e.partList, t.partList, function (e, t) {\n        t.elementaryStreams = e.elementaryStreams, t.stats = e.stats;\n      }), s ? Ct(t, s, s.startPTS, s.endPTS, s.startDTS, s.endDTS) : Pt(e, t), v.length && (t.totalduration = t.edge - v[0].start), t.driftStartTime = e.driftStartTime, t.driftStart = e.driftStart;\n      var p = t.advancedDateTime;\n      if (t.advanced && p) {\n        var y = t.edge;\n        t.driftStart || (t.driftStartTime = p, t.driftStart = y), t.driftEndTime = p, t.driftEnd = y;\n      } else t.driftEndTime = e.driftEndTime, t.driftEnd = e.driftEnd, t.advancedDateTime = e.advancedDateTime;\n    }\n    function Pt(e, t) {\n      var r = t.startSN + t.skippedSegments - e.startSN,\n        i = e.fragments;\n      r < 0 || r >= i.length || function (e, t) {\n        if (t) {\n          for (var r = e.fragments, i = e.skippedSegments; i < r.length; i++) r[i].start += t;\n          e.fragmentHint && (e.fragmentHint.start += t);\n        }\n      }(t, i[r].start);\n    }\n    function Ft(e, t, r) {\n      var i;\n      return null != e && e.details ? Ot(null == (i = e.details) ? void 0 : i.partList, t, r) : null;\n    }\n    function Ot(e, t, r) {\n      if (e) for (var i = e.length; i--;) {\n        var a = e[i];\n        if (a.index === r && a.fragment.sn === t) return a;\n      }\n      return null;\n    }\n    function Mt(e) {\n      e.forEach(function (e, t) {\n        var r = e.details;\n        null != r && r.fragments && r.fragments.forEach(function (e) {\n          e.level = t;\n        });\n      });\n    }\n    function Nt(e) {\n      switch (e.details) {\n        case S.FRAG_LOAD_TIMEOUT:\n        case S.KEY_LOAD_TIMEOUT:\n        case S.LEVEL_LOAD_TIMEOUT:\n        case S.MANIFEST_LOAD_TIMEOUT:\n          return !0;\n      }\n      return !1;\n    }\n    function Bt(e, t) {\n      var r = Nt(t);\n      return e.default[(r ? \"timeout\" : \"error\") + \"Retry\"];\n    }\n    function Ut(e, t) {\n      var r = \"linear\" === e.backoff ? 1 : Math.pow(2, t);\n      return Math.min(r * e.retryDelayMs, e.maxRetryDelayMs);\n    }\n    function Gt(e) {\n      return i(i({}, e), {\n        errorRetry: null,\n        timeoutRetry: null\n      });\n    }\n    function Ht(e, t, r, i) {\n      if (!e) return !1;\n      var a = null == i ? void 0 : i.code,\n        n = t < e.maxNumRetry && (function (e) {\n          return 0 === e && !1 === navigator.onLine || !!e && (e < 400 || e > 499);\n        }(a) || !!r);\n      return e.shouldRetry ? e.shouldRetry(e, t, r, i, n) : n;\n    }\n    var Vt = function (e, t) {\n      for (var r = 0, i = e.length - 1, a = null, n = null; r <= i;) {\n        var s = t(n = e[a = (r + i) / 2 | 0]);\n        if (s > 0) r = a + 1;else {\n          if (!(s < 0)) return n;\n          i = a - 1;\n        }\n      }\n      return null;\n    };\n    function Kt(e, t, r, i) {\n      void 0 === r && (r = 0), void 0 === i && (i = 0);\n      var a = null;\n      if (e) {\n        a = t[e.sn - t[0].sn + 1] || null;\n        var n = e.endDTS - r;\n        n > 0 && n < 15e-7 && (r += 15e-7);\n      } else 0 === r && 0 === t[0].start && (a = t[0]);\n      if (a && (!e || e.level === a.level) && 0 === jt(r, i, a)) return a;\n      var s = Vt(t, jt.bind(null, r, i));\n      return !s || s === e && a ? a : s;\n    }\n    function jt(e, t, r) {\n      if (void 0 === e && (e = 0), void 0 === t && (t = 0), r.start <= e && r.start + r.duration > e) return 0;\n      var i = Math.min(t, r.duration + (r.deltaPTS ? r.deltaPTS : 0));\n      return r.start + r.duration - i <= e ? 1 : r.start - i > e && r.start ? -1 : 0;\n    }\n    function Wt(e, t, r) {\n      var i = 1e3 * Math.min(t, r.duration + (r.deltaPTS ? r.deltaPTS : 0));\n      return (r.endProgramDateTime || 0) - i > e;\n    }\n    var Yt = 0,\n      qt = 2,\n      zt = 3,\n      Xt = 5,\n      Qt = 0,\n      Jt = 1,\n      $t = 2,\n      Zt = function () {\n        function e(e) {\n          this.hls = void 0, this.playlistError = 0, this.penalizedRenditions = {}, this.log = void 0, this.warn = void 0, this.error = void 0, this.hls = e, this.log = k.log.bind(k, \"[info]:\"), this.warn = k.warn.bind(k, \"[warning]:\"), this.error = k.error.bind(k, \"[error]:\"), this.registerListeners();\n        }\n        var t = e.prototype;\n        return t.registerListeners = function () {\n          var e = this.hls;\n          e.on(E.ERROR, this.onError, this), e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.LEVEL_UPDATED, this.onLevelUpdated, this);\n        }, t.unregisterListeners = function () {\n          var e = this.hls;\n          e && (e.off(E.ERROR, this.onError, this), e.off(E.ERROR, this.onErrorOut, this), e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.LEVEL_UPDATED, this.onLevelUpdated, this));\n        }, t.destroy = function () {\n          this.unregisterListeners(), this.hls = null, this.penalizedRenditions = {};\n        }, t.startLoad = function (e) {}, t.stopLoad = function () {\n          this.playlistError = 0;\n        }, t.getVariantLevelIndex = function (e) {\n          return (null == e ? void 0 : e.type) === nt ? e.level : this.hls.loadLevel;\n        }, t.onManifestLoading = function () {\n          this.playlistError = 0, this.penalizedRenditions = {};\n        }, t.onLevelUpdated = function () {\n          this.playlistError = 0;\n        }, t.onError = function (e, t) {\n          var r, i;\n          if (!t.fatal) {\n            var a = this.hls,\n              n = t.context;\n            switch (t.details) {\n              case S.FRAG_LOAD_ERROR:\n              case S.FRAG_LOAD_TIMEOUT:\n              case S.KEY_LOAD_ERROR:\n              case S.KEY_LOAD_TIMEOUT:\n                return void (t.errorAction = this.getFragRetryOrSwitchAction(t));\n              case S.FRAG_PARSING_ERROR:\n                if (null != (r = t.frag) && r.gap) return void (t.errorAction = {\n                  action: Yt,\n                  flags: Qt\n                });\n              case S.FRAG_GAP:\n              case S.FRAG_DECRYPT_ERROR:\n                return t.errorAction = this.getFragRetryOrSwitchAction(t), void (t.errorAction.action = qt);\n              case S.LEVEL_EMPTY_ERROR:\n              case S.LEVEL_PARSING_ERROR:\n                var s,\n                  o,\n                  l = t.parent === nt ? t.level : a.loadLevel;\n                return void (t.details === S.LEVEL_EMPTY_ERROR && null != (s = t.context) && null != (o = s.levelDetails) && o.live ? t.errorAction = this.getPlaylistRetryOrSwitchAction(t, l) : (t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, l)));\n              case S.LEVEL_LOAD_ERROR:\n              case S.LEVEL_LOAD_TIMEOUT:\n                return void (\"number\" == typeof (null == n ? void 0 : n.level) && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, n.level)));\n              case S.AUDIO_TRACK_LOAD_ERROR:\n              case S.AUDIO_TRACK_LOAD_TIMEOUT:\n              case S.SUBTITLE_LOAD_ERROR:\n              case S.SUBTITLE_TRACK_LOAD_TIMEOUT:\n                if (n) {\n                  var u = a.levels[a.loadLevel];\n                  if (u && (n.type === it && u.hasAudioGroup(n.groupId) || n.type === at && u.hasSubtitleGroup(n.groupId))) return t.errorAction = this.getPlaylistRetryOrSwitchAction(t, a.loadLevel), t.errorAction.action = qt, void (t.errorAction.flags = Jt);\n                }\n                return;\n              case S.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:\n                var d = a.levels[a.loadLevel],\n                  h = null == d ? void 0 : d.attrs[\"HDCP-LEVEL\"];\n                return void (h ? t.errorAction = {\n                  action: qt,\n                  flags: $t,\n                  hdcpLevel: h\n                } : this.keySystemError(t));\n              case S.BUFFER_ADD_CODEC_ERROR:\n              case S.REMUX_ALLOC_ERROR:\n              case S.BUFFER_APPEND_ERROR:\n                return void (t.errorAction = this.getLevelSwitchAction(t, null != (i = t.level) ? i : a.loadLevel));\n              case S.INTERNAL_EXCEPTION:\n              case S.BUFFER_APPENDING_ERROR:\n              case S.BUFFER_FULL_ERROR:\n              case S.LEVEL_SWITCH_ERROR:\n              case S.BUFFER_STALLED_ERROR:\n              case S.BUFFER_SEEK_OVER_HOLE:\n              case S.BUFFER_NUDGE_ON_STALL:\n                return void (t.errorAction = {\n                  action: Yt,\n                  flags: Qt\n                });\n            }\n            t.type === T.KEY_SYSTEM_ERROR && this.keySystemError(t);\n          }\n        }, t.keySystemError = function (e) {\n          var t = this.getVariantLevelIndex(e.frag);\n          e.levelRetry = !1, e.errorAction = this.getLevelSwitchAction(e, t);\n        }, t.getPlaylistRetryOrSwitchAction = function (e, t) {\n          var r = Bt(this.hls.config.playlistLoadPolicy, e),\n            i = this.playlistError++;\n          if (Ht(r, i, Nt(e), e.response)) return {\n            action: Xt,\n            flags: Qt,\n            retryConfig: r,\n            retryCount: i\n          };\n          var a = this.getLevelSwitchAction(e, t);\n          return r && (a.retryConfig = r, a.retryCount = i), a;\n        }, t.getFragRetryOrSwitchAction = function (e) {\n          var t = this.hls,\n            r = this.getVariantLevelIndex(e.frag),\n            i = t.levels[r],\n            a = t.config,\n            n = a.fragLoadPolicy,\n            s = a.keyLoadPolicy,\n            o = Bt(e.details.startsWith(\"key\") ? s : n, e),\n            l = t.levels.reduce(function (e, t) {\n              return e + t.fragmentError;\n            }, 0);\n          if (i && (e.details !== S.FRAG_GAP && i.fragmentError++, Ht(o, l, Nt(e), e.response))) return {\n            action: Xt,\n            flags: Qt,\n            retryConfig: o,\n            retryCount: l\n          };\n          var u = this.getLevelSwitchAction(e, r);\n          return o && (u.retryConfig = o, u.retryCount = l), u;\n        }, t.getLevelSwitchAction = function (e, t) {\n          var r = this.hls;\n          null == t && (t = r.loadLevel);\n          var i = this.hls.levels[t];\n          if (i) {\n            var a,\n              n,\n              s = e.details;\n            i.loadError++, s === S.BUFFER_APPEND_ERROR && i.fragmentError++;\n            var o = -1,\n              l = r.levels,\n              u = r.loadLevel,\n              d = r.minAutoLevel,\n              h = r.maxAutoLevel;\n            r.autoLevelEnabled || (r.loadLevel = -1);\n            for (var f, c = null == (a = e.frag) ? void 0 : a.type, v = (c === st && s === S.FRAG_PARSING_ERROR || \"audio\" === e.sourceBufferName && (s === S.BUFFER_ADD_CODEC_ERROR || s === S.BUFFER_APPEND_ERROR)) && l.some(function (e) {\n                var t = e.audioCodec;\n                return i.audioCodec !== t;\n              }), g = \"video\" === e.sourceBufferName && (s === S.BUFFER_ADD_CODEC_ERROR || s === S.BUFFER_APPEND_ERROR) && l.some(function (e) {\n                var t = e.codecSet,\n                  r = e.audioCodec;\n                return i.codecSet !== t && i.audioCodec === r;\n              }), m = null != (n = e.context) ? n : {}, p = m.type, y = m.groupId, E = function () {\n                var t = (T + u) % l.length;\n                if (t !== u && t >= d && t <= h && 0 === l[t].loadError) {\n                  var r,\n                    a,\n                    n = l[t];\n                  if (s === S.FRAG_GAP && e.frag) {\n                    var f = l[t].details;\n                    if (f) {\n                      var m = Kt(e.frag, f.fragments, e.frag.start);\n                      if (null != m && m.gap) return 0;\n                    }\n                  } else {\n                    if (p === it && n.hasAudioGroup(y) || p === at && n.hasSubtitleGroup(y)) return 0;\n                    if (c === st && null != (r = i.audioGroups) && r.some(function (e) {\n                      return n.hasAudioGroup(e);\n                    }) || c === ot && null != (a = i.subtitleGroups) && a.some(function (e) {\n                      return n.hasSubtitleGroup(e);\n                    }) || v && i.audioCodec === n.audioCodec || !v && i.audioCodec !== n.audioCodec || g && i.codecSet === n.codecSet) return 0;\n                  }\n                  return o = t, 1;\n                }\n              }, T = l.length; T-- && (0 === (f = E()) || 1 !== f););\n            if (o > -1 && r.loadLevel !== o) return e.levelRetry = !0, this.playlistError = 0, {\n              action: qt,\n              flags: Qt,\n              nextAutoLevel: o\n            };\n          }\n          return {\n            action: qt,\n            flags: Jt\n          };\n        }, t.onErrorOut = function (e, t) {\n          var r;\n          switch (null == (r = t.errorAction) ? void 0 : r.action) {\n            case Yt:\n              break;\n            case qt:\n              this.sendAlternateToPenaltyBox(t), t.errorAction.resolved || t.details === S.FRAG_GAP ? /MediaSource readyState: ended/.test(t.error.message) && (this.warn('MediaSource ended after \"' + t.sourceBufferName + '\" sourceBuffer append error. Attempting to recover from media error.'), this.hls.recoverMediaError()) : t.fatal = !0;\n          }\n          t.fatal && this.hls.stopLoad();\n        }, t.sendAlternateToPenaltyBox = function (e) {\n          var t = this.hls,\n            r = e.errorAction;\n          if (r) {\n            var i = r.flags,\n              a = r.hdcpLevel,\n              n = r.nextAutoLevel;\n            switch (i) {\n              case Qt:\n                this.switchLevel(e, n);\n                break;\n              case $t:\n                a && (t.maxHdcpLevel = Lt[Lt.indexOf(a) - 1], r.resolved = !0), this.warn('Restricting playback to HDCP-LEVEL of \"' + t.maxHdcpLevel + '\" or lower');\n            }\n            r.resolved || this.switchLevel(e, n);\n          }\n        }, t.switchLevel = function (e, t) {\n          void 0 !== t && e.errorAction && (this.warn(\"switching to level \" + t + \" after \" + e.details), this.hls.nextAutoLevel = t, e.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel);\n        }, e;\n      }(),\n      er = function () {\n        function e(e, t) {\n          this.hls = void 0, this.timer = -1, this.requestScheduled = -1, this.canLoad = !1, this.log = void 0, this.warn = void 0, this.log = k.log.bind(k, t + \":\"), this.warn = k.warn.bind(k, t + \":\"), this.hls = e;\n        }\n        var t = e.prototype;\n        return t.destroy = function () {\n          this.clearTimer(), this.hls = this.log = this.warn = null;\n        }, t.clearTimer = function () {\n          -1 !== this.timer && (self.clearTimeout(this.timer), this.timer = -1);\n        }, t.startLoad = function () {\n          this.canLoad = !0, this.requestScheduled = -1, this.loadPlaylist();\n        }, t.stopLoad = function () {\n          this.canLoad = !1, this.clearTimer();\n        }, t.switchParams = function (e, t) {\n          var r = null == t ? void 0 : t.renditionReports;\n          if (r) {\n            for (var i = -1, a = 0; a < r.length; a++) {\n              var n = r[a],\n                s = void 0;\n              try {\n                s = new self.URL(n.URI, t.url).href;\n              } catch (e) {\n                k.warn(\"Could not construct new URL for Rendition Report: \" + e), s = n.URI || \"\";\n              }\n              if (s === e) {\n                i = a;\n                break;\n              }\n              s === e.substring(0, s.length) && (i = a);\n            }\n            if (-1 !== i) {\n              var o = r[i],\n                l = parseInt(o[\"LAST-MSN\"]) || (null == t ? void 0 : t.lastPartSn),\n                u = parseInt(o[\"LAST-PART\"]) || (null == t ? void 0 : t.lastPartIndex);\n              if (this.hls.config.lowLatencyMode) {\n                var d = Math.min(t.age - t.partTarget, t.targetduration);\n                u >= 0 && d > t.partTarget && (u += 1);\n              }\n              return new kt(l, u >= 0 ? u : void 0, At);\n            }\n          }\n        }, t.loadPlaylist = function (e) {\n          -1 === this.requestScheduled && (this.requestScheduled = self.performance.now());\n        }, t.shouldLoadPlaylist = function (e) {\n          return this.canLoad && !!e && !!e.url && (!e.details || e.details.live);\n        }, t.shouldReloadPlaylist = function (e) {\n          return -1 === this.timer && -1 === this.requestScheduled && this.shouldLoadPlaylist(e);\n        }, t.playlistLoaded = function (e, t, r) {\n          var i = this,\n            a = t.details,\n            n = t.stats,\n            s = self.performance.now(),\n            o = n.loading.first ? Math.max(0, s - n.loading.first) : 0;\n          if (a.advancedDateTime = Date.now() - o, a.live || null != r && r.live) {\n            if (a.reloaded(r), r && this.log(\"live playlist \" + e + \" \" + (a.advanced ? \"REFRESHED \" + a.lastPartSn + \"-\" + a.lastPartIndex : a.updated ? \"UPDATED\" : \"MISSED\")), r && a.fragments.length > 0 && It(r, a), !this.canLoad || !a.live) return;\n            var l,\n              u = void 0,\n              d = void 0;\n            if (a.canBlockReload && a.endSN && a.advanced) {\n              var h = this.hls.config.lowLatencyMode,\n                f = a.lastPartSn,\n                c = a.endSN,\n                v = a.lastPartIndex,\n                g = f === c;\n              -1 !== v ? (u = g ? c + 1 : f, d = g ? h ? 0 : v : v + 1) : u = c + 1;\n              var m = a.age,\n                p = m + a.ageHeader,\n                y = Math.min(p - a.partTarget, 1.5 * a.targetduration);\n              if (y > 0) {\n                if (r && y > r.tuneInGoal) this.warn(\"CDN Tune-in goal increased from: \" + r.tuneInGoal + \" to: \" + y + \" with playlist age: \" + a.age), y = 0;else {\n                  var E = Math.floor(y / a.targetduration);\n                  u += E, void 0 !== d && (d += Math.round(y % a.targetduration / a.partTarget)), this.log(\"CDN Tune-in age: \" + a.ageHeader + \"s last advanced \" + m.toFixed(2) + \"s goal: \" + y + \" skip sn \" + E + \" to part \" + d);\n                }\n                a.tuneInGoal = y;\n              }\n              if (l = this.getDeliveryDirectives(a, t.deliveryDirectives, u, d), h || !g) return void this.loadPlaylist(l);\n            } else (a.canBlockReload || a.canSkipUntil) && (l = this.getDeliveryDirectives(a, t.deliveryDirectives, u, d));\n            var T = this.hls.mainForwardBufferInfo,\n              S = T ? T.end - T.len : 0,\n              L = function (e, t) {\n                void 0 === t && (t = 1 / 0);\n                var r = 1e3 * e.targetduration;\n                if (e.updated) {\n                  var i = e.fragments;\n                  if (i.length && 4 * r > t) {\n                    var a = 1e3 * i[i.length - 1].duration;\n                    a < r && (r = a);\n                  }\n                } else r /= 2;\n                return Math.round(r);\n              }(a, 1e3 * (a.edge - S));\n            a.updated && s > this.requestScheduled + L && (this.requestScheduled = n.loading.start), void 0 !== u && a.canBlockReload ? this.requestScheduled = n.loading.first + L - (1e3 * a.partTarget || 1e3) : -1 === this.requestScheduled || this.requestScheduled + L < s ? this.requestScheduled = s : this.requestScheduled - s <= 0 && (this.requestScheduled += L);\n            var R = this.requestScheduled - s;\n            R = Math.max(0, R), this.log(\"reload live playlist \" + e + \" in \" + Math.round(R) + \" ms\"), this.timer = self.setTimeout(function () {\n              return i.loadPlaylist(l);\n            }, R);\n          } else this.clearTimer();\n        }, t.getDeliveryDirectives = function (e, t, r, i) {\n          var a = function (e, t) {\n            var r = e.canSkipUntil,\n              i = e.canSkipDateRanges,\n              a = e.endSN;\n            return r && (void 0 !== t ? t - a : 0) < r ? i ? Dt : bt : At;\n          }(e, r);\n          return null != t && t.skip && e.deltaUpdateFailed && (r = t.msn, i = t.part, a = At), new kt(r, i, a);\n        }, t.checkRetry = function (e) {\n          var t = this,\n            r = e.details,\n            i = Nt(e),\n            a = e.errorAction,\n            n = a || {},\n            s = n.action,\n            o = n.retryCount,\n            l = void 0 === o ? 0 : o,\n            u = n.retryConfig,\n            d = !!a && !!u && (s === Xt || !a.resolved && s === qt);\n          if (d) {\n            var h;\n            if (this.requestScheduled = -1, l >= u.maxNumRetry) return !1;\n            if (i && null != (h = e.context) && h.deliveryDirectives) this.warn(\"Retrying playlist loading \" + (l + 1) + \"/\" + u.maxNumRetry + ' after \"' + r + '\" without delivery-directives'), this.loadPlaylist();else {\n              var f = Ut(u, l);\n              this.timer = self.setTimeout(function () {\n                return t.loadPlaylist();\n              }, f), this.warn(\"Retrying playlist loading \" + (l + 1) + \"/\" + u.maxNumRetry + ' after \"' + r + '\" in ' + f + \"ms\");\n            }\n            e.levelRetry = !0, a.resolved = !0;\n          }\n          return d;\n        }, e;\n      }(),\n      tr = function () {\n        function e(e, t, r) {\n          void 0 === t && (t = 0), void 0 === r && (r = 0), this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(.5) / e) : 0, this.estimate_ = t, this.totalWeight_ = r;\n        }\n        var t = e.prototype;\n        return t.sample = function (e, t) {\n          var r = Math.pow(this.alpha_, e);\n          this.estimate_ = t * (1 - r) + r * this.estimate_, this.totalWeight_ += e;\n        }, t.getTotalWeight = function () {\n          return this.totalWeight_;\n        }, t.getEstimate = function () {\n          if (this.alpha_) {\n            var e = 1 - Math.pow(this.alpha_, this.totalWeight_);\n            if (e) return this.estimate_ / e;\n          }\n          return this.estimate_;\n        }, e;\n      }(),\n      rr = function () {\n        function e(e, t, r, i) {\n          void 0 === i && (i = 100), this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = r, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new tr(e), this.fast_ = new tr(t), this.defaultTTFB_ = i, this.ttfb_ = new tr(e);\n        }\n        var t = e.prototype;\n        return t.update = function (e, t) {\n          var r = this.slow_,\n            i = this.fast_,\n            a = this.ttfb_;\n          r.halfLife !== e && (this.slow_ = new tr(e, r.getEstimate(), r.getTotalWeight())), i.halfLife !== t && (this.fast_ = new tr(t, i.getEstimate(), i.getTotalWeight())), a.halfLife !== e && (this.ttfb_ = new tr(e, a.getEstimate(), a.getTotalWeight()));\n        }, t.sample = function (e, t) {\n          var r = (e = Math.max(e, this.minDelayMs_)) / 1e3,\n            i = 8 * t / r;\n          this.fast_.sample(r, i), this.slow_.sample(r, i);\n        }, t.sampleTTFB = function (e) {\n          var t = e / 1e3,\n            r = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2);\n          this.ttfb_.sample(r, Math.max(e, 5));\n        }, t.canEstimate = function () {\n          return this.fast_.getTotalWeight() >= this.minWeight_;\n        }, t.getEstimate = function () {\n          return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_;\n        }, t.getEstimateTTFB = function () {\n          return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_;\n        }, t.destroy = function () {}, e;\n      }();\n    function ir(e, t) {\n      var r = !1,\n        i = [];\n      return e && (r = \"SDR\" !== e, i = [e]), t && (i = t.allowedVideoRanges || Rt.slice(0), i = (r = void 0 !== t.preferHDR ? t.preferHDR : function () {\n        if (\"function\" == typeof matchMedia) {\n          var e = matchMedia(\"(dynamic-range: high)\"),\n            t = matchMedia(\"bad query\");\n          if (e.media !== t.media) return !0 === e.matches;\n        }\n        return !1;\n      }()) ? i.filter(function (e) {\n        return \"SDR\" !== e;\n      }) : [\"SDR\"]), {\n        preferHDR: r,\n        allowedVideoRanges: i\n      };\n    }\n    function ar(e, t) {\n      k.log('[abr] start candidates with \"' + e + '\" ignored because ' + t);\n    }\n    var nr = function () {\n        function e(e) {\n          var t = this;\n          this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = -1, this.firstSelection = -1, this._nextAutoLevel = -1, this.nextAutoLevelKey = \"\", this.audioTracksByGroup = null, this.codecTiers = null, this.timer = -1, this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0, this._abandonRulesCheck = function () {\n            var e = t.fragCurrent,\n              r = t.partCurrent,\n              i = t.hls,\n              a = i.autoLevelEnabled,\n              n = i.media;\n            if (e && n) {\n              var s = performance.now(),\n                o = r ? r.stats : e.stats,\n                l = r ? r.duration : e.duration,\n                u = s - o.loading.start,\n                d = i.minAutoLevel;\n              if (o.aborted || o.loaded && o.loaded === o.total || e.level <= d) return t.clearTimer(), void (t._nextAutoLevel = -1);\n              if (a && !n.paused && n.playbackRate && n.readyState) {\n                var h = i.mainForwardBufferInfo;\n                if (null !== h) {\n                  var f = t.bwEstimator.getEstimateTTFB(),\n                    c = Math.abs(n.playbackRate);\n                  if (!(u <= Math.max(f, l / (2 * c) * 1e3))) {\n                    var v = h.len / c,\n                      g = o.loading.first ? o.loading.first - o.loading.start : -1,\n                      p = o.loaded && g > -1,\n                      y = t.getBwEstimate(),\n                      T = i.levels,\n                      S = T[e.level],\n                      L = o.total || Math.max(o.loaded, Math.round(l * S.averageBitrate / 8)),\n                      R = p ? u - g : u;\n                    R < 1 && p && (R = Math.min(u, 8 * o.loaded / y));\n                    var A = p ? 1e3 * o.loaded / R : 0,\n                      b = A ? (L - o.loaded) / A : 8 * L / y + f / 1e3;\n                    if (!(b <= v)) {\n                      var D,\n                        _ = A ? 8 * A : y,\n                        x = Number.POSITIVE_INFINITY;\n                      for (D = e.level - 1; D > d; D--) {\n                        var w = T[D].maxBitrate;\n                        if ((x = t.getTimeToLoadFrag(f / 1e3, _, l * w, !T[D].details)) < v) break;\n                      }\n                      if (!(x >= b || x > 10 * l)) {\n                        i.nextLoadLevel = i.nextAutoLevel = D, p ? t.bwEstimator.sample(u - Math.min(f, g), o.loaded) : t.bwEstimator.sampleTTFB(u);\n                        var C = T[D].maxBitrate;\n                        t.getBwEstimate() * t.hls.config.abrBandWidthUpFactor > C && t.resetEstimator(C), t.clearTimer(), k.warn(\"[abr] Fragment \" + e.sn + (r ? \" part \" + r.index : \"\") + \" of level \" + e.level + \" is loading too slowly;\\n      Time to underbuffer: \" + v.toFixed(3) + \" s\\n      Estimated load time for current fragment: \" + b.toFixed(3) + \" s\\n      Estimated load time for down switch fragment: \" + x.toFixed(3) + \" s\\n      TTFB estimate: \" + (0 | g) + \" ms\\n      Current BW estimate: \" + (m(y) ? 0 | y : \"Unknown\") + \" bps\\n      New BW estimate: \" + (0 | t.getBwEstimate()) + \" bps\\n      Switching to level \" + D + \" @ \" + (0 | C) + \" bps\"), i.trigger(E.FRAG_LOAD_EMERGENCY_ABORTED, {\n                          frag: e,\n                          part: r,\n                          stats: o\n                        });\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }, this.hls = e, this.bwEstimator = this.initEstimator(), this.registerListeners();\n        }\n        var t = e.prototype;\n        return t.resetEstimator = function (e) {\n          e && (k.log(\"setting initial bwe to \" + e), this.hls.config.abrEwmaDefaultEstimate = e), this.firstSelection = -1, this.bwEstimator = this.initEstimator();\n        }, t.initEstimator = function () {\n          var e = this.hls.config;\n          return new rr(e.abrEwmaSlowVoD, e.abrEwmaFastVoD, e.abrEwmaDefaultEstimate);\n        }, t.registerListeners = function () {\n          var e = this.hls;\n          e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.FRAG_LOADING, this.onFragLoading, this), e.on(E.FRAG_LOADED, this.onFragLoaded, this), e.on(E.FRAG_BUFFERED, this.onFragBuffered, this), e.on(E.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(E.LEVEL_LOADED, this.onLevelLoaded, this), e.on(E.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(E.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.on(E.ERROR, this.onError, this);\n        }, t.unregisterListeners = function () {\n          var e = this.hls;\n          e && (e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.FRAG_LOADING, this.onFragLoading, this), e.off(E.FRAG_LOADED, this.onFragLoaded, this), e.off(E.FRAG_BUFFERED, this.onFragBuffered, this), e.off(E.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(E.LEVEL_LOADED, this.onLevelLoaded, this), e.off(E.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(E.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.off(E.ERROR, this.onError, this));\n        }, t.destroy = function () {\n          this.unregisterListeners(), this.clearTimer(), this.hls = this._abandonRulesCheck = null, this.fragCurrent = this.partCurrent = null;\n        }, t.onManifestLoading = function (e, t) {\n          this.lastLoadedFragLevel = -1, this.firstSelection = -1, this.lastLevelLoadSec = 0, this.fragCurrent = this.partCurrent = null, this.onLevelsUpdated(), this.clearTimer();\n        }, t.onLevelsUpdated = function () {\n          this.lastLoadedFragLevel > -1 && this.fragCurrent && (this.lastLoadedFragLevel = this.fragCurrent.level), this._nextAutoLevel = -1, this.onMaxAutoLevelUpdated(), this.codecTiers = null, this.audioTracksByGroup = null;\n        }, t.onMaxAutoLevelUpdated = function () {\n          this.firstSelection = -1, this.nextAutoLevelKey = \"\";\n        }, t.onFragLoading = function (e, t) {\n          var r,\n            i = t.frag;\n          this.ignoreFragment(i) || (i.bitrateTest || (this.fragCurrent = i, this.partCurrent = null != (r = t.part) ? r : null), this.clearTimer(), this.timer = self.setInterval(this._abandonRulesCheck, 100));\n        }, t.onLevelSwitching = function (e, t) {\n          this.clearTimer();\n        }, t.onError = function (e, t) {\n          if (!t.fatal) switch (t.details) {\n            case S.BUFFER_ADD_CODEC_ERROR:\n            case S.BUFFER_APPEND_ERROR:\n              this.lastLoadedFragLevel = -1, this.firstSelection = -1;\n              break;\n            case S.FRAG_LOAD_TIMEOUT:\n              var r = t.frag,\n                i = this.fragCurrent,\n                a = this.partCurrent;\n              if (r && i && r.sn === i.sn && r.level === i.level) {\n                var n = performance.now(),\n                  s = a ? a.stats : r.stats,\n                  o = n - s.loading.start,\n                  l = s.loading.first ? s.loading.first - s.loading.start : -1;\n                if (s.loaded && l > -1) {\n                  var u = this.bwEstimator.getEstimateTTFB();\n                  this.bwEstimator.sample(o - Math.min(u, l), s.loaded);\n                } else this.bwEstimator.sampleTTFB(o);\n              }\n          }\n        }, t.getTimeToLoadFrag = function (e, t, r, i) {\n          return e + r / t + (i ? this.lastLevelLoadSec : 0);\n        }, t.onLevelLoaded = function (e, t) {\n          var r = this.hls.config,\n            i = t.stats.loading,\n            a = i.end - i.start;\n          m(a) && (this.lastLevelLoadSec = a / 1e3), t.details.live ? this.bwEstimator.update(r.abrEwmaSlowLive, r.abrEwmaFastLive) : this.bwEstimator.update(r.abrEwmaSlowVoD, r.abrEwmaFastVoD);\n        }, t.onFragLoaded = function (e, t) {\n          var r = t.frag,\n            i = t.part,\n            a = i ? i.stats : r.stats;\n          if (r.type === nt && this.bwEstimator.sampleTTFB(a.loading.first - a.loading.start), !this.ignoreFragment(r)) {\n            if (this.clearTimer(), r.level === this._nextAutoLevel && (this._nextAutoLevel = -1), this.firstSelection = -1, this.hls.config.abrMaxWithRealBitrate) {\n              var n = i ? i.duration : r.duration,\n                s = this.hls.levels[r.level],\n                o = (s.loaded ? s.loaded.bytes : 0) + a.loaded,\n                l = (s.loaded ? s.loaded.duration : 0) + n;\n              s.loaded = {\n                bytes: o,\n                duration: l\n              }, s.realBitrate = Math.round(8 * o / l);\n            }\n            if (r.bitrateTest) {\n              var u = {\n                stats: a,\n                frag: r,\n                part: i,\n                id: r.type\n              };\n              this.onFragBuffered(E.FRAG_BUFFERED, u), r.bitrateTest = !1;\n            } else this.lastLoadedFragLevel = r.level;\n          }\n        }, t.onFragBuffered = function (e, t) {\n          var r = t.frag,\n            i = t.part,\n            a = null != i && i.stats.loaded ? i.stats : r.stats;\n          if (!a.aborted && !this.ignoreFragment(r)) {\n            var n = a.parsing.end - a.loading.start - Math.min(a.loading.first - a.loading.start, this.bwEstimator.getEstimateTTFB());\n            this.bwEstimator.sample(n, a.loaded), a.bwEstimate = this.getBwEstimate(), r.bitrateTest ? this.bitrateTestDelay = n / 1e3 : this.bitrateTestDelay = 0;\n          }\n        }, t.ignoreFragment = function (e) {\n          return e.type !== nt || \"initSegment\" === e.sn;\n        }, t.clearTimer = function () {\n          this.timer > -1 && (self.clearInterval(this.timer), this.timer = -1);\n        }, t.getAutoLevelKey = function () {\n          var e;\n          return this.getBwEstimate() + \"_\" + (null == (e = this.hls.mainForwardBufferInfo) ? void 0 : e.len);\n        }, t.getNextABRAutoLevel = function () {\n          var e = this.fragCurrent,\n            t = this.partCurrent,\n            r = this.hls,\n            i = r.maxAutoLevel,\n            a = r.config,\n            n = r.minAutoLevel,\n            s = r.media,\n            o = t ? t.duration : e ? e.duration : 0,\n            l = s && 0 !== s.playbackRate ? Math.abs(s.playbackRate) : 1,\n            u = this.getBwEstimate(),\n            d = r.mainForwardBufferInfo,\n            h = (d ? d.len : 0) / l,\n            f = a.abrBandWidthFactor,\n            c = a.abrBandWidthUpFactor;\n          if (h) {\n            var v = this.findBestLevel(u, n, i, h, 0, f, c);\n            if (v >= 0) return v;\n          }\n          var g = o ? Math.min(o, a.maxStarvationDelay) : a.maxStarvationDelay;\n          if (!h) {\n            var m = this.bitrateTestDelay;\n            m && (g = (o ? Math.min(o, a.maxLoadingDelay) : a.maxLoadingDelay) - m, k.info(\"[abr] bitrate test took \" + Math.round(1e3 * m) + \"ms, set first fragment max fetchDuration to \" + Math.round(1e3 * g) + \" ms\"), f = c = 1);\n          }\n          var p = this.findBestLevel(u, n, i, h, g, f, c);\n          if (k.info(\"[abr] \" + (h ? \"rebuffering expected\" : \"buffer is empty\") + \", optimal quality level \" + p), p > -1) return p;\n          var y = r.levels[n],\n            E = r.levels[r.loadLevel];\n          return (null == y ? void 0 : y.bitrate) < (null == E ? void 0 : E.bitrate) ? n : r.loadLevel;\n        }, t.getBwEstimate = function () {\n          return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;\n        }, t.findBestLevel = function (e, t, r, i, a, n, s) {\n          var o,\n            l = this,\n            u = i + a,\n            d = this.lastLoadedFragLevel,\n            h = -1 === d ? this.hls.firstLevel : d,\n            f = this.fragCurrent,\n            c = this.partCurrent,\n            v = this.hls,\n            g = v.levels,\n            p = v.allAudioTracks,\n            y = v.loadLevel,\n            E = v.config;\n          if (1 === g.length) return 0;\n          var T,\n            S = g[h],\n            L = !(null == S || null == (o = S.details) || !o.live),\n            R = -1 === y || -1 === d,\n            A = \"SDR\",\n            b = (null == S ? void 0 : S.frameRate) || 0,\n            D = E.audioPreference,\n            _ = E.videoPreference,\n            x = this.audioTracksByGroup || (this.audioTracksByGroup = function (e) {\n              return e.reduce(function (e, t) {\n                var r = e.groups[t.groupId];\n                r || (r = e.groups[t.groupId] = {\n                  tracks: [],\n                  channels: {\n                    2: 0\n                  },\n                  hasDefault: !1,\n                  hasAutoSelect: !1\n                }), r.tracks.push(t);\n                var i = t.channels || \"2\";\n                return r.channels[i] = (r.channels[i] || 0) + 1, r.hasDefault = r.hasDefault || t.default, r.hasAutoSelect = r.hasAutoSelect || t.autoselect, r.hasDefault && (e.hasDefaultAudio = !0), r.hasAutoSelect && (e.hasAutoSelectAudio = !0), e;\n              }, {\n                hasDefaultAudio: !1,\n                hasAutoSelectAudio: !1,\n                groups: {}\n              });\n            }(p));\n          if (R) {\n            if (-1 !== this.firstSelection) return this.firstSelection;\n            var w = this.codecTiers || (this.codecTiers = function (e, t, r, i) {\n                return e.slice(r, i + 1).reduce(function (e, r) {\n                  if (!r.codecSet) return e;\n                  var i = r.audioGroups,\n                    a = e[r.codecSet];\n                  a || (e[r.codecSet] = a = {\n                    minBitrate: 1 / 0,\n                    minHeight: 1 / 0,\n                    minFramerate: 1 / 0,\n                    maxScore: 0,\n                    videoRanges: {\n                      SDR: 0\n                    },\n                    channels: {\n                      2: 0\n                    },\n                    hasDefaultAudio: !i,\n                    fragmentError: 0\n                  }), a.minBitrate = Math.min(a.minBitrate, r.bitrate);\n                  var n = Math.min(r.height, r.width);\n                  return a.minHeight = Math.min(a.minHeight, n), a.minFramerate = Math.min(a.minFramerate, r.frameRate), a.maxScore = Math.max(a.maxScore, r.score), a.fragmentError += r.fragmentError, a.videoRanges[r.videoRange] = (a.videoRanges[r.videoRange] || 0) + 1, i && i.forEach(function (e) {\n                    if (e) {\n                      var r = t.groups[e];\n                      a.hasDefaultAudio = a.hasDefaultAudio || t.hasDefaultAudio ? r.hasDefault : r.hasAutoSelect || !t.hasDefaultAudio && !t.hasAutoSelectAudio, Object.keys(r.channels).forEach(function (e) {\n                        a.channels[e] = (a.channels[e] || 0) + r.channels[e];\n                      });\n                    }\n                  }), e;\n                }, {});\n              }(g, x, t, r)),\n              C = function (e, t, r, i, a) {\n                for (var n = Object.keys(e), s = null == i ? void 0 : i.channels, o = null == i ? void 0 : i.audioCodec, l = s && 2 === parseInt(s), u = !0, d = !1, h = 1 / 0, f = 1 / 0, c = 1 / 0, v = 0, g = [], p = ir(t, a), y = p.preferHDR, E = p.allowedVideoRanges, T = function () {\n                    var t = e[n[S]];\n                    u = t.channels[2] > 0, h = Math.min(h, t.minHeight), f = Math.min(f, t.minFramerate), c = Math.min(c, t.minBitrate);\n                    var r = E.filter(function (e) {\n                      return t.videoRanges[e] > 0;\n                    });\n                    r.length > 0 && (d = !0, g = r);\n                  }, S = n.length; S--;) T();\n                h = m(h) ? h : 0, f = m(f) ? f : 0;\n                var L = Math.max(1080, h),\n                  R = Math.max(30, f);\n                return c = m(c) ? c : r, r = Math.max(c, r), d || (t = void 0, g = []), {\n                  codecSet: n.reduce(function (t, i) {\n                    var a = e[i];\n                    if (i === t) return t;\n                    if (a.minBitrate > r) return ar(i, \"min bitrate of \" + a.minBitrate + \" > current estimate of \" + r), t;\n                    if (!a.hasDefaultAudio) return ar(i, \"no renditions with default or auto-select sound found\"), t;\n                    if (o && i.indexOf(o.substring(0, 4)) % 5 != 0) return ar(i, 'audio codec preference \"' + o + '\" not found'), t;\n                    if (s && !l) {\n                      if (!a.channels[s]) return ar(i, \"no renditions with \" + s + \" channel sound found (channels options: \" + Object.keys(a.channels) + \")\"), t;\n                    } else if ((!o || l) && u && 0 === a.channels[2]) return ar(i, \"no renditions with stereo sound found\"), t;\n                    return a.minHeight > L ? (ar(i, \"min resolution of \" + a.minHeight + \" > maximum of \" + L), t) : a.minFramerate > R ? (ar(i, \"min framerate of \" + a.minFramerate + \" > maximum of \" + R), t) : g.some(function (e) {\n                      return a.videoRanges[e] > 0;\n                    }) ? a.maxScore < v ? (ar(i, \"max score of \" + a.maxScore + \" < selected max of \" + v), t) : t && (Ne(i) >= Ne(t) || a.fragmentError > e[t].fragmentError) ? t : (v = a.maxScore, i) : (ar(i, \"no variants with VIDEO-RANGE of \" + JSON.stringify(g) + \" found\"), t);\n                  }, void 0),\n                  videoRanges: g,\n                  preferHDR: y,\n                  minFramerate: f,\n                  minBitrate: c\n                };\n              }(w, A, e, D, _),\n              I = C.codecSet,\n              P = C.videoRanges,\n              F = C.minFramerate,\n              O = C.minBitrate,\n              M = C.preferHDR;\n            T = I, A = M ? P[P.length - 1] : P[0], b = F, e = Math.max(e, O), k.log(\"[abr] picked start tier \" + JSON.stringify(C));\n          } else T = null == S ? void 0 : S.codecSet, A = null == S ? void 0 : S.videoRange;\n          for (var N, B = c ? c.duration : f ? f.duration : 0, U = this.bwEstimator.getEstimateTTFB() / 1e3, G = [], H = function () {\n              var t,\n                o = g[V],\n                f = V > h;\n              if (!o) return 0;\n              if (T && o.codecSet !== T || A && o.videoRange !== A || f && b > o.frameRate || !f && b > 0 && b < o.frameRate || o.supportedResult && (null == (t = o.supportedResult.decodingInfoResults) || !t[0].smooth)) return G.push(V), 0;\n              var v,\n                p = o.details,\n                E = (c ? null == p ? void 0 : p.partTarget : null == p ? void 0 : p.averagetargetduration) || B;\n              v = f ? s * e : n * e;\n              var D = B && i >= 2 * B && 0 === a ? g[V].averageBitrate : g[V].maxBitrate,\n                _ = l.getTimeToLoadFrag(U, v, D * E, void 0 === p);\n              if (v >= D && (V === d || 0 === o.loadError && 0 === o.fragmentError) && (_ <= U || !m(_) || L && !l.bitrateTestDelay || _ < u)) {\n                var x = l.forcedAutoLevel;\n                return V === y || -1 !== x && x === y || (G.length && k.trace(\"[abr] Skipped level(s) \" + G.join(\",\") + \" of \" + r + ' max with CODECS and VIDEO-RANGE:\"' + g[G[0]].codecs + '\" ' + g[G[0]].videoRange + '; not compatible with \"' + S.codecs + '\" ' + A), k.info(\"[abr] switch candidate:\" + h + \"->\" + V + \" adjustedbw(\" + Math.round(v) + \")-bitrate=\" + Math.round(v - D) + \" ttfb:\" + U.toFixed(1) + \" avgDuration:\" + E.toFixed(1) + \" maxFetchDuration:\" + u.toFixed(1) + \" fetchDuration:\" + _.toFixed(1) + \" firstSelection:\" + R + \" codecSet:\" + T + \" videoRange:\" + A + \" hls.loadLevel:\" + y)), R && (l.firstSelection = V), {\n                  v: V\n                };\n              }\n            }, V = r; V >= t; V--) if (0 !== (N = H()) && N) return N.v;\n          return -1;\n        }, s(e, [{\n          key: \"firstAutoLevel\",\n          get: function () {\n            var e = this.hls,\n              t = e.maxAutoLevel,\n              r = e.minAutoLevel,\n              i = this.getBwEstimate(),\n              a = this.hls.config.maxStarvationDelay,\n              n = this.findBestLevel(i, r, t, 0, a, 1, 1);\n            if (n > -1) return n;\n            var s = this.hls.firstLevel,\n              o = Math.min(Math.max(s, r), t);\n            return k.warn(\"[abr] Could not find best starting auto level. Defaulting to first in playlist \" + s + \" clamped to \" + o), o;\n          }\n        }, {\n          key: \"forcedAutoLevel\",\n          get: function () {\n            return this.nextAutoLevelKey ? -1 : this._nextAutoLevel;\n          }\n        }, {\n          key: \"nextAutoLevel\",\n          get: function () {\n            var e = this.forcedAutoLevel,\n              t = this.bwEstimator.canEstimate(),\n              r = this.lastLoadedFragLevel > -1;\n            if (!(-1 === e || t && r && this.nextAutoLevelKey !== this.getAutoLevelKey())) return e;\n            var i = t && r ? this.getNextABRAutoLevel() : this.firstAutoLevel;\n            if (-1 !== e) {\n              var a = this.hls.levels;\n              if (a.length > Math.max(e, i) && a[e].loadError <= a[i].loadError) return e;\n            }\n            return this._nextAutoLevel = i, this.nextAutoLevelKey = this.getAutoLevelKey(), i;\n          },\n          set: function (e) {\n            var t = this.hls,\n              r = t.maxAutoLevel,\n              i = t.minAutoLevel,\n              a = Math.min(Math.max(e, i), r);\n            this._nextAutoLevel !== a && (this.nextAutoLevelKey = \"\", this._nextAutoLevel = a);\n          }\n        }]), e;\n      }(),\n      sr = {\n        length: 0,\n        start: function () {\n          return 0;\n        },\n        end: function () {\n          return 0;\n        }\n      },\n      or = function () {\n        function e() {}\n        return e.isBuffered = function (t, r) {\n          try {\n            if (t) for (var i = e.getBuffered(t), a = 0; a < i.length; a++) if (r >= i.start(a) && r <= i.end(a)) return !0;\n          } catch (e) {}\n          return !1;\n        }, e.bufferInfo = function (t, r, i) {\n          try {\n            if (t) {\n              var a,\n                n = e.getBuffered(t),\n                s = [];\n              for (a = 0; a < n.length; a++) s.push({\n                start: n.start(a),\n                end: n.end(a)\n              });\n              return this.bufferedInfo(s, r, i);\n            }\n          } catch (e) {}\n          return {\n            len: 0,\n            start: r,\n            end: r,\n            nextStart: void 0\n          };\n        }, e.bufferedInfo = function (e, t, r) {\n          t = Math.max(0, t), e.sort(function (e, t) {\n            var r = e.start - t.start;\n            return r || t.end - e.end;\n          });\n          var i = [];\n          if (r) for (var a = 0; a < e.length; a++) {\n            var n = i.length;\n            if (n) {\n              var s = i[n - 1].end;\n              e[a].start - s < r ? e[a].end > s && (i[n - 1].end = e[a].end) : i.push(e[a]);\n            } else i.push(e[a]);\n          } else i = e;\n          for (var o, l = 0, u = t, d = t, h = 0; h < i.length; h++) {\n            var f = i[h].start,\n              c = i[h].end;\n            if (t + r >= f && t < c) u = f, l = (d = c) - t;else if (t + r < f) {\n              o = f;\n              break;\n            }\n          }\n          return {\n            len: l,\n            start: u || 0,\n            end: d || 0,\n            nextStart: o\n          };\n        }, e.getBuffered = function (e) {\n          try {\n            return e.buffered;\n          } catch (e) {\n            return k.log(\"failed to get media.buffered\", e), sr;\n          }\n        }, e;\n      }(),\n      lr = function () {\n        function e(e) {\n          this.buffers = void 0, this.queues = {\n            video: [],\n            audio: [],\n            audiovideo: []\n          }, this.buffers = e;\n        }\n        var t = e.prototype;\n        return t.append = function (e, t, r) {\n          var i = this.queues[t];\n          i.push(e), 1 !== i.length || r || this.executeNext(t);\n        }, t.insertAbort = function (e, t) {\n          this.queues[t].unshift(e), this.executeNext(t);\n        }, t.appendBlocker = function (e) {\n          var t,\n            r = new Promise(function (e) {\n              t = e;\n            }),\n            i = {\n              execute: t,\n              onStart: function () {},\n              onComplete: function () {},\n              onError: function () {}\n            };\n          return this.append(i, e), r;\n        }, t.executeNext = function (e) {\n          var t = this.queues[e];\n          if (t.length) {\n            var r = t[0];\n            try {\n              r.execute();\n            } catch (t) {\n              k.warn('[buffer-operation-queue]: Exception executing \"' + e + '\" SourceBuffer operation: ' + t), r.onError(t);\n              var i = this.buffers[e];\n              null != i && i.updating || this.shiftAndExecuteNext(e);\n            }\n          }\n        }, t.shiftAndExecuteNext = function (e) {\n          this.queues[e].shift(), this.executeNext(e);\n        }, t.current = function (e) {\n          return this.queues[e][0];\n        }, e;\n      }(),\n      ur = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\\.[^.,]+)+/,\n      dr = function () {\n        function e(e) {\n          var t = this;\n          this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.appendSource = void 0, this.appendErrors = {\n            audio: 0,\n            video: 0,\n            audiovideo: 0\n          }, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this.log = void 0, this.warn = void 0, this.error = void 0, this._onEndStreaming = function (e) {\n            t.hls && t.hls.pauseBuffering();\n          }, this._onStartStreaming = function (e) {\n            t.hls && t.hls.resumeBuffering();\n          }, this._onMediaSourceOpen = function () {\n            var e = t.media,\n              r = t.mediaSource;\n            t.log(\"Media source opened\"), e && (e.removeEventListener(\"emptied\", t._onMediaEmptied), t.updateMediaElementDuration(), t.hls.trigger(E.MEDIA_ATTACHED, {\n              media: e,\n              mediaSource: r\n            })), r && r.removeEventListener(\"sourceopen\", t._onMediaSourceOpen), t.checkPendingTracks();\n          }, this._onMediaSourceClose = function () {\n            t.log(\"Media source closed\");\n          }, this._onMediaSourceEnded = function () {\n            t.log(\"Media source ended\");\n          }, this._onMediaEmptied = function () {\n            var e = t.mediaSrc,\n              r = t._objectUrl;\n            e !== r && k.error(\"Media element src was set while attaching MediaSource (\" + r + \" > \" + e + \")\");\n          }, this.hls = e;\n          var r = \"[buffer-controller]\";\n          this.appendSource = e.config.preferManagedMediaSource, this.log = k.log.bind(k, r), this.warn = k.warn.bind(k, r), this.error = k.error.bind(k, r), this._initSourceBuffer(), this.registerListeners();\n        }\n        var t = e.prototype;\n        return t.hasSourceTypes = function () {\n          return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;\n        }, t.destroy = function () {\n          this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = null, this.hls = null;\n        }, t.registerListeners = function () {\n          var e = this.hls;\n          e.on(E.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.MANIFEST_PARSED, this.onManifestParsed, this), e.on(E.BUFFER_RESET, this.onBufferReset, this), e.on(E.BUFFER_APPENDING, this.onBufferAppending, this), e.on(E.BUFFER_CODECS, this.onBufferCodecs, this), e.on(E.BUFFER_EOS, this.onBufferEos, this), e.on(E.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(E.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(E.FRAG_PARSED, this.onFragParsed, this), e.on(E.FRAG_CHANGED, this.onFragChanged, this);\n        }, t.unregisterListeners = function () {\n          var e = this.hls;\n          e.off(E.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.MANIFEST_PARSED, this.onManifestParsed, this), e.off(E.BUFFER_RESET, this.onBufferReset, this), e.off(E.BUFFER_APPENDING, this.onBufferAppending, this), e.off(E.BUFFER_CODECS, this.onBufferCodecs, this), e.off(E.BUFFER_EOS, this.onBufferEos, this), e.off(E.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(E.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(E.FRAG_PARSED, this.onFragParsed, this), e.off(E.FRAG_CHANGED, this.onFragChanged, this);\n        }, t._initSourceBuffer = function () {\n          this.sourceBuffer = {}, this.operationQueue = new lr(this.sourceBuffer), this.listeners = {\n            audio: [],\n            video: [],\n            audiovideo: []\n          }, this.appendErrors = {\n            audio: 0,\n            video: 0,\n            audiovideo: 0\n          }, this.lastMpegAudioChunk = null;\n        }, t.onManifestLoading = function () {\n          this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0, this.details = null;\n        }, t.onManifestParsed = function (e, t) {\n          var r = 2;\n          t.audio && !t.video || t.altAudio, r = 1, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = r, this.log(this.bufferCodecEventsExpected + \" bufferCodec event(s) expected\");\n        }, t.onMediaAttaching = function (e, t) {\n          var r = this.media = t.media,\n            i = Ce(this.appendSource);\n          if (r && i) {\n            var a,\n              n = this.mediaSource = new i();\n            this.log(\"created media source: \" + (null == (a = n.constructor) ? void 0 : a.name)), n.addEventListener(\"sourceopen\", this._onMediaSourceOpen), n.addEventListener(\"sourceended\", this._onMediaSourceEnded), n.addEventListener(\"sourceclose\", this._onMediaSourceClose), n.addEventListener(\"startstreaming\", this._onStartStreaming), n.addEventListener(\"endstreaming\", this._onEndStreaming);\n            var s = this._objectUrl = self.URL.createObjectURL(n);\n            if (this.appendSource) try {\n              r.removeAttribute(\"src\");\n              var o = self.ManagedMediaSource;\n              r.disableRemotePlayback = r.disableRemotePlayback || o && n instanceof o, hr(r), function (e, t) {\n                var r = self.document.createElement(\"source\");\n                r.type = \"video/mp4\", r.src = t, e.appendChild(r);\n              }(r, s), r.load();\n            } catch (e) {\n              r.src = s;\n            } else r.src = s;\n            r.addEventListener(\"emptied\", this._onMediaEmptied);\n          }\n        }, t.onMediaDetaching = function () {\n          var e = this.media,\n            t = this.mediaSource,\n            r = this._objectUrl;\n          if (t) {\n            if (this.log(\"media source detaching\"), \"open\" === t.readyState) try {\n              t.endOfStream();\n            } catch (e) {\n              this.warn(\"onMediaDetaching: \" + e.message + \" while calling endOfStream\");\n            }\n            this.onBufferReset(), t.removeEventListener(\"sourceopen\", this._onMediaSourceOpen), t.removeEventListener(\"sourceended\", this._onMediaSourceEnded), t.removeEventListener(\"sourceclose\", this._onMediaSourceClose), t.removeEventListener(\"startstreaming\", this._onStartStreaming), t.removeEventListener(\"endstreaming\", this._onEndStreaming), e && (e.removeEventListener(\"emptied\", this._onMediaEmptied), r && self.URL.revokeObjectURL(r), this.mediaSrc === r ? (e.removeAttribute(\"src\"), this.appendSource && hr(e), e.load()) : this.warn(\"media|source.src was changed by a third party - skip cleanup\")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {};\n          }\n          this.hls.trigger(E.MEDIA_DETACHED, void 0);\n        }, t.onBufferReset = function () {\n          var e = this;\n          this.getSourceBufferTypes().forEach(function (t) {\n            e.resetBuffer(t);\n          }), this._initSourceBuffer();\n        }, t.resetBuffer = function (e) {\n          var t = this.sourceBuffer[e];\n          try {\n            var r;\n            t && (this.removeBufferListeners(e), this.sourceBuffer[e] = void 0, null != (r = this.mediaSource) && r.sourceBuffers.length && this.mediaSource.removeSourceBuffer(t));\n          } catch (t) {\n            this.warn(\"onBufferReset \" + e, t);\n          }\n        }, t.onBufferCodecs = function (e, t) {\n          var r = this,\n            i = this.getSourceBufferTypes().length,\n            a = Object.keys(t);\n          if (a.forEach(function (e) {\n            if (i) {\n              var a = r.tracks[e];\n              if (a && \"function\" == typeof a.buffer.changeType) {\n                var n,\n                  s = t[e],\n                  o = s.id,\n                  l = s.codec,\n                  u = s.levelCodec,\n                  d = s.container,\n                  h = s.metadata,\n                  f = He(a.codec, a.levelCodec),\n                  c = null == f ? void 0 : f.replace(ur, \"$1\"),\n                  v = He(l, u),\n                  g = null == (n = v) ? void 0 : n.replace(ur, \"$1\");\n                if (v && c !== g) {\n                  \"audio\" === e.slice(0, 5) && (v = Ge(v, r.hls.config.preferManagedMediaSource));\n                  var m = d + \";codecs=\" + v;\n                  r.appendChangeType(e, m), r.log(\"switching codec \" + f + \" to \" + v), r.tracks[e] = {\n                    buffer: a.buffer,\n                    codec: l,\n                    container: d,\n                    levelCodec: u,\n                    metadata: h,\n                    id: o\n                  };\n                }\n              }\n            } else r.pendingTracks[e] = t[e];\n          }), !i) {\n            var n = Math.max(this.bufferCodecEventsExpected - 1, 0);\n            this.bufferCodecEventsExpected !== n && (this.log(n + \" bufferCodec event(s) expected \" + a.join(\",\")), this.bufferCodecEventsExpected = n), this.mediaSource && \"open\" === this.mediaSource.readyState && this.checkPendingTracks();\n          }\n        }, t.appendChangeType = function (e, t) {\n          var r = this,\n            i = this.operationQueue,\n            a = {\n              execute: function () {\n                var a = r.sourceBuffer[e];\n                a && (r.log(\"changing \" + e + \" sourceBuffer type to \" + t), a.changeType(t)), i.shiftAndExecuteNext(e);\n              },\n              onStart: function () {},\n              onComplete: function () {},\n              onError: function (t) {\n                r.warn(\"Failed to change \" + e + \" SourceBuffer type\", t);\n              }\n            };\n          i.append(a, e, !!this.pendingTracks[e]);\n        }, t.onBufferAppending = function (e, t) {\n          var r = this,\n            i = this.hls,\n            a = this.operationQueue,\n            n = this.tracks,\n            s = t.data,\n            o = t.type,\n            l = t.frag,\n            u = t.part,\n            d = t.chunkMeta,\n            h = d.buffering[o],\n            f = self.performance.now();\n          h.start = f;\n          var c = l.stats.buffering,\n            v = u ? u.stats.buffering : null;\n          0 === c.start && (c.start = f), v && 0 === v.start && (v.start = f);\n          var g = n.audio,\n            m = !1;\n          \"audio\" === o && \"audio/mpeg\" === (null == g ? void 0 : g.container) && (m = !this.lastMpegAudioChunk || 1 === d.id || this.lastMpegAudioChunk.sn !== d.sn, this.lastMpegAudioChunk = d);\n          var p = l.start,\n            y = {\n              execute: function () {\n                if (h.executeStart = self.performance.now(), m) {\n                  var e = r.sourceBuffer[o];\n                  if (e) {\n                    var t = p - e.timestampOffset;\n                    Math.abs(t) >= .1 && (r.log(\"Updating audio SourceBuffer timestampOffset to \" + p + \" (delta: \" + t + \") sn: \" + l.sn + \")\"), e.timestampOffset = p);\n                  }\n                }\n                r.appendExecutor(s, o);\n              },\n              onStart: function () {},\n              onComplete: function () {\n                var e = self.performance.now();\n                h.executeEnd = h.end = e, 0 === c.first && (c.first = e), v && 0 === v.first && (v.first = e);\n                var t = r.sourceBuffer,\n                  i = {};\n                for (var a in t) i[a] = or.getBuffered(t[a]);\n                r.appendErrors[o] = 0, \"audio\" === o || \"video\" === o ? r.appendErrors.audiovideo = 0 : (r.appendErrors.audio = 0, r.appendErrors.video = 0), r.hls.trigger(E.BUFFER_APPENDED, {\n                  type: o,\n                  frag: l,\n                  part: u,\n                  chunkMeta: d,\n                  parent: l.type,\n                  timeRanges: i\n                });\n              },\n              onError: function (e) {\n                var t = {\n                  type: T.MEDIA_ERROR,\n                  parent: l.type,\n                  details: S.BUFFER_APPEND_ERROR,\n                  sourceBufferName: o,\n                  frag: l,\n                  part: u,\n                  chunkMeta: d,\n                  error: e,\n                  err: e,\n                  fatal: !1\n                };\n                if (e.code === DOMException.QUOTA_EXCEEDED_ERR) t.details = S.BUFFER_FULL_ERROR;else {\n                  var a = ++r.appendErrors[o];\n                  t.details = S.BUFFER_APPEND_ERROR, r.warn(\"Failed \" + a + \"/\" + i.config.appendErrorMaxRetry + ' times to append segment in \"' + o + '\" sourceBuffer'), a >= i.config.appendErrorMaxRetry && (t.fatal = !0);\n                }\n                i.trigger(E.ERROR, t);\n              }\n            };\n          a.append(y, o, !!this.pendingTracks[o]);\n        }, t.onBufferFlushing = function (e, t) {\n          var r = this,\n            i = this.operationQueue,\n            a = function (e) {\n              return {\n                execute: r.removeExecutor.bind(r, e, t.startOffset, t.endOffset),\n                onStart: function () {},\n                onComplete: function () {\n                  r.hls.trigger(E.BUFFER_FLUSHED, {\n                    type: e\n                  });\n                },\n                onError: function (t) {\n                  r.warn(\"Failed to remove from \" + e + \" SourceBuffer\", t);\n                }\n              };\n            };\n          t.type ? i.append(a(t.type), t.type) : this.getSourceBufferTypes().forEach(function (e) {\n            i.append(a(e), e);\n          });\n        }, t.onFragParsed = function (e, t) {\n          var r = this,\n            i = t.frag,\n            a = t.part,\n            n = [],\n            s = a ? a.elementaryStreams : i.elementaryStreams;\n          s[M] ? n.push(\"audiovideo\") : (s[F] && n.push(\"audio\"), s[O] && n.push(\"video\")), 0 === n.length && this.warn(\"Fragments must have at least one ElementaryStreamType set. type: \" + i.type + \" level: \" + i.level + \" sn: \" + i.sn), this.blockBuffers(function () {\n            var e = self.performance.now();\n            i.stats.buffering.end = e, a && (a.stats.buffering.end = e);\n            var t = a ? a.stats : i.stats;\n            r.hls.trigger(E.FRAG_BUFFERED, {\n              frag: i,\n              part: a,\n              stats: t,\n              id: i.type\n            });\n          }, n);\n        }, t.onFragChanged = function (e, t) {\n          this.trimBuffers();\n        }, t.onBufferEos = function (e, t) {\n          var r = this;\n          this.getSourceBufferTypes().reduce(function (e, i) {\n            var a = r.sourceBuffer[i];\n            return !a || t.type && t.type !== i || (a.ending = !0, a.ended || (a.ended = !0, r.log(i + \" sourceBuffer now EOS\"))), e && !(a && !a.ended);\n          }, !0) && (this.log(\"Queueing mediaSource.endOfStream()\"), this.blockBuffers(function () {\n            r.getSourceBufferTypes().forEach(function (e) {\n              var t = r.sourceBuffer[e];\n              t && (t.ending = !1);\n            });\n            var e = r.mediaSource;\n            e && \"open\" === e.readyState ? (r.log(\"Calling mediaSource.endOfStream()\"), e.endOfStream()) : e && r.log(\"Could not call mediaSource.endOfStream(). mediaSource.readyState: \" + e.readyState);\n          }));\n        }, t.onLevelUpdated = function (e, t) {\n          var r = t.details;\n          r.fragments.length && (this.details = r, this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration());\n        }, t.trimBuffers = function () {\n          var e = this.hls,\n            t = this.details,\n            r = this.media;\n          if (r && null !== t && this.getSourceBufferTypes().length) {\n            var i = e.config,\n              a = r.currentTime,\n              n = t.levelTargetDuration,\n              s = t.live && null !== i.liveBackBufferLength ? i.liveBackBufferLength : i.backBufferLength;\n            if (m(s) && s > 0) {\n              var o = Math.max(s, n),\n                l = Math.floor(a / n) * n - o;\n              this.flushBackBuffer(a, n, l);\n            }\n            if (m(i.frontBufferFlushThreshold) && i.frontBufferFlushThreshold > 0) {\n              var u = Math.max(i.maxBufferLength, i.frontBufferFlushThreshold),\n                d = Math.max(u, n),\n                h = Math.floor(a / n) * n + d;\n              this.flushFrontBuffer(a, n, h);\n            }\n          }\n        }, t.flushBackBuffer = function (e, t, r) {\n          var i = this,\n            a = this.details,\n            n = this.sourceBuffer;\n          this.getSourceBufferTypes().forEach(function (s) {\n            var o = n[s];\n            if (o) {\n              var l = or.getBuffered(o);\n              if (l.length > 0 && r > l.start(0)) {\n                if (i.hls.trigger(E.BACK_BUFFER_REACHED, {\n                  bufferEnd: r\n                }), null != a && a.live) i.hls.trigger(E.LIVE_BACK_BUFFER_REACHED, {\n                  bufferEnd: r\n                });else if (o.ended && l.end(l.length - 1) - e < 2 * t) return void i.log(\"Cannot flush \" + s + \" back buffer while SourceBuffer is in ended state\");\n                i.hls.trigger(E.BUFFER_FLUSHING, {\n                  startOffset: 0,\n                  endOffset: r,\n                  type: s\n                });\n              }\n            }\n          });\n        }, t.flushFrontBuffer = function (e, t, r) {\n          var i = this,\n            a = this.sourceBuffer;\n          this.getSourceBufferTypes().forEach(function (n) {\n            var s = a[n];\n            if (s) {\n              var o = or.getBuffered(s),\n                l = o.length;\n              if (l < 2) return;\n              var u = o.start(l - 1),\n                d = o.end(l - 1);\n              if (r > u || e >= u && e <= d) return;\n              if (s.ended && e - d < 2 * t) return void i.log(\"Cannot flush \" + n + \" front buffer while SourceBuffer is in ended state\");\n              i.hls.trigger(E.BUFFER_FLUSHING, {\n                startOffset: u,\n                endOffset: 1 / 0,\n                type: n\n              });\n            }\n          });\n        }, t.updateMediaElementDuration = function () {\n          if (this.details && this.media && this.mediaSource && \"open\" === this.mediaSource.readyState) {\n            var e = this.details,\n              t = this.hls,\n              r = this.media,\n              i = this.mediaSource,\n              a = e.fragments[0].start + e.totalduration,\n              n = r.duration,\n              s = m(i.duration) ? i.duration : 0;\n            e.live && t.config.liveDurationInfinity ? (i.duration = 1 / 0, this.updateSeekableRange(e)) : (a > s && a > n || !m(n)) && (this.log(\"Updating Media Source duration to \" + a.toFixed(3)), i.duration = a);\n          }\n        }, t.updateSeekableRange = function (e) {\n          var t = this.mediaSource,\n            r = e.fragments;\n          if (r.length && e.live && null != t && t.setLiveSeekableRange) {\n            var i = Math.max(0, r[0].start),\n              a = Math.max(i, i + e.totalduration);\n            this.log(\"Media Source duration is set to \" + t.duration + \". Setting seekable range to \" + i + \"-\" + a + \".\"), t.setLiveSeekableRange(i, a);\n          }\n        }, t.checkPendingTracks = function () {\n          var e = this.bufferCodecEventsExpected,\n            t = this.operationQueue,\n            r = this.pendingTracks,\n            i = Object.keys(r).length;\n          if (i && (!e || 2 === i || \"audiovideo\" in r)) {\n            this.createSourceBuffers(r), this.pendingTracks = {};\n            var a = this.getSourceBufferTypes();\n            if (a.length) this.hls.trigger(E.BUFFER_CREATED, {\n              tracks: this.tracks\n            }), a.forEach(function (e) {\n              t.executeNext(e);\n            });else {\n              var n = new Error(\"could not create source buffer for media codec(s)\");\n              this.hls.trigger(E.ERROR, {\n                type: T.MEDIA_ERROR,\n                details: S.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n                fatal: !0,\n                error: n,\n                reason: n.message\n              });\n            }\n          }\n        }, t.createSourceBuffers = function (e) {\n          var t = this,\n            r = this.sourceBuffer,\n            i = this.mediaSource;\n          if (!i) throw Error(\"createSourceBuffers called when mediaSource was null\");\n          var a = function (a) {\n            if (!r[a]) {\n              var n = e[a];\n              if (!n) throw Error(\"source buffer exists for track \" + a + \", however track does not\");\n              var s = n.levelCodec || n.codec;\n              s && \"audio\" === a.slice(0, 5) && (s = Ge(s, t.hls.config.preferManagedMediaSource));\n              var o = n.container + \";codecs=\" + s;\n              t.log(\"creating sourceBuffer(\" + o + \")\");\n              try {\n                var l = r[a] = i.addSourceBuffer(o),\n                  u = a;\n                t.addBufferListener(u, \"updatestart\", t._onSBUpdateStart), t.addBufferListener(u, \"updateend\", t._onSBUpdateEnd), t.addBufferListener(u, \"error\", t._onSBUpdateError), t.addBufferListener(u, \"bufferedchange\", function (e, r) {\n                  var i = r.removedRanges;\n                  null != i && i.length && t.hls.trigger(E.BUFFER_FLUSHED, {\n                    type: a\n                  });\n                }), t.tracks[a] = {\n                  buffer: l,\n                  codec: s,\n                  container: n.container,\n                  levelCodec: n.levelCodec,\n                  metadata: n.metadata,\n                  id: n.id\n                };\n              } catch (e) {\n                t.error(\"error while trying to add sourceBuffer: \" + e.message), t.hls.trigger(E.ERROR, {\n                  type: T.MEDIA_ERROR,\n                  details: S.BUFFER_ADD_CODEC_ERROR,\n                  fatal: !1,\n                  error: e,\n                  sourceBufferName: a,\n                  mimeType: o\n                });\n              }\n            }\n          };\n          for (var n in e) a(n);\n        }, t._onSBUpdateStart = function (e) {\n          this.operationQueue.current(e).onStart();\n        }, t._onSBUpdateEnd = function (e) {\n          var t;\n          if (\"closed\" !== (null == (t = this.mediaSource) ? void 0 : t.readyState)) {\n            var r = this.operationQueue;\n            r.current(e).onComplete(), r.shiftAndExecuteNext(e);\n          } else this.resetBuffer(e);\n        }, t._onSBUpdateError = function (e, t) {\n          var r,\n            i = new Error(e + \" SourceBuffer error. MediaSource readyState: \" + (null == (r = this.mediaSource) ? void 0 : r.readyState));\n          this.error(\"\" + i, t), this.hls.trigger(E.ERROR, {\n            type: T.MEDIA_ERROR,\n            details: S.BUFFER_APPENDING_ERROR,\n            sourceBufferName: e,\n            error: i,\n            fatal: !1\n          });\n          var a = this.operationQueue.current(e);\n          a && a.onError(i);\n        }, t.removeExecutor = function (e, t, r) {\n          var i = this.media,\n            a = this.mediaSource,\n            n = this.operationQueue,\n            s = this.sourceBuffer[e];\n          if (!i || !a || !s) return this.warn(\"Attempting to remove from the \" + e + \" SourceBuffer, but it does not exist\"), void n.shiftAndExecuteNext(e);\n          var o = m(i.duration) ? i.duration : 1 / 0,\n            l = m(a.duration) ? a.duration : 1 / 0,\n            u = Math.max(0, t),\n            d = Math.min(r, o, l);\n          d > u && (!s.ending || s.ended) ? (s.ended = !1, this.log(\"Removing [\" + u + \",\" + d + \"] from the \" + e + \" SourceBuffer\"), s.remove(u, d)) : n.shiftAndExecuteNext(e);\n        }, t.appendExecutor = function (e, t) {\n          var r = this.sourceBuffer[t];\n          if (r) r.ended = !1, r.appendBuffer(e);else if (!this.pendingTracks[t]) throw new Error(\"Attempting to append to the \" + t + \" SourceBuffer, but it does not exist\");\n        }, t.blockBuffers = function (e, t) {\n          var r = this;\n          if (void 0 === t && (t = this.getSourceBufferTypes()), !t.length) return this.log(\"Blocking operation requested, but no SourceBuffers exist\"), void Promise.resolve().then(e);\n          var i = this.operationQueue,\n            a = t.map(function (e) {\n              return i.appendBlocker(e);\n            });\n          Promise.all(a).then(function () {\n            e(), t.forEach(function (e) {\n              var t = r.sourceBuffer[e];\n              null != t && t.updating || i.shiftAndExecuteNext(e);\n            });\n          });\n        }, t.getSourceBufferTypes = function () {\n          return Object.keys(this.sourceBuffer);\n        }, t.addBufferListener = function (e, t, r) {\n          var i = this.sourceBuffer[e];\n          if (i) {\n            var a = r.bind(this, e);\n            this.listeners[e].push({\n              event: t,\n              listener: a\n            }), i.addEventListener(t, a);\n          }\n        }, t.removeBufferListeners = function (e) {\n          var t = this.sourceBuffer[e];\n          t && this.listeners[e].forEach(function (e) {\n            t.removeEventListener(e.event, e.listener);\n          });\n        }, s(e, [{\n          key: \"mediaSrc\",\n          get: function () {\n            var e,\n              t = (null == (e = this.media) ? void 0 : e.firstChild) || this.media;\n            return null == t ? void 0 : t.src;\n          }\n        }]), e;\n      }();\n    function hr(e) {\n      var t = e.querySelectorAll(\"source\");\n      [].slice.call(t).forEach(function (t) {\n        e.removeChild(t);\n      });\n    }\n    var fr = function () {\n        function e(e) {\n          this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners();\n        }\n        var t = e.prototype;\n        return t.setStreamController = function (e) {\n          this.streamController = e;\n        }, t.destroy = function () {\n          this.hls && this.unregisterListener(), this.timer && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null;\n        }, t.registerListeners = function () {\n          var e = this.hls;\n          e.on(E.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(E.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(E.MANIFEST_PARSED, this.onManifestParsed, this), e.on(E.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(E.BUFFER_CODECS, this.onBufferCodecs, this), e.on(E.MEDIA_DETACHING, this.onMediaDetaching, this);\n        }, t.unregisterListener = function () {\n          var e = this.hls;\n          e.off(E.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(E.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(E.MANIFEST_PARSED, this.onManifestParsed, this), e.off(E.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(E.BUFFER_CODECS, this.onBufferCodecs, this), e.off(E.MEDIA_DETACHING, this.onMediaDetaching, this);\n        }, t.onFpsDropLevelCapping = function (e, t) {\n          var r = this.hls.levels[t.droppedLevel];\n          this.isLevelAllowed(r) && this.restrictedLevels.push({\n            bitrate: r.bitrate,\n            height: r.height,\n            width: r.width\n          });\n        }, t.onMediaAttaching = function (e, t) {\n          this.media = t.media instanceof HTMLVideoElement ? t.media : null, this.clientRect = null, this.timer && this.hls.levels.length && this.detectPlayerSize();\n        }, t.onManifestParsed = function (e, t) {\n          var r = this.hls;\n          this.restrictedLevels = [], this.firstLevel = t.firstLevel, r.config.capLevelToPlayerSize && t.video && this.startCapping();\n        }, t.onLevelsUpdated = function (e, t) {\n          this.timer && m(this.autoLevelCapping) && this.detectPlayerSize();\n        }, t.onBufferCodecs = function (e, t) {\n          this.hls.config.capLevelToPlayerSize && t.video && this.startCapping();\n        }, t.onMediaDetaching = function () {\n          this.stopCapping();\n        }, t.detectPlayerSize = function () {\n          if (this.media) {\n            if (this.mediaHeight <= 0 || this.mediaWidth <= 0) return void (this.clientRect = null);\n            var e = this.hls.levels;\n            if (e.length) {\n              var t = this.hls,\n                r = this.getMaxLevel(e.length - 1);\n              r !== this.autoLevelCapping && k.log(\"Setting autoLevelCapping to \" + r + \": \" + e[r].height + \"p@\" + e[r].bitrate + \" for media \" + this.mediaWidth + \"x\" + this.mediaHeight), t.autoLevelCapping = r, t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping;\n            }\n          }\n        }, t.getMaxLevel = function (t) {\n          var r = this,\n            i = this.hls.levels;\n          if (!i.length) return -1;\n          var a = i.filter(function (e, i) {\n            return r.isLevelAllowed(e) && i <= t;\n          });\n          return this.clientRect = null, e.getMaxLevelByMediaSize(a, this.mediaWidth, this.mediaHeight);\n        }, t.startCapping = function () {\n          this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize());\n        }, t.stopCapping = function () {\n          this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0);\n        }, t.getDimensions = function () {\n          if (this.clientRect) return this.clientRect;\n          var e = this.media,\n            t = {\n              width: 0,\n              height: 0\n            };\n          if (e) {\n            var r = e.getBoundingClientRect();\n            t.width = r.width, t.height = r.height, t.width || t.height || (t.width = r.right - r.left || e.width || 0, t.height = r.bottom - r.top || e.height || 0);\n          }\n          return this.clientRect = t, t;\n        }, t.isLevelAllowed = function (e) {\n          return !this.restrictedLevels.some(function (t) {\n            return e.bitrate === t.bitrate && e.width === t.width && e.height === t.height;\n          });\n        }, e.getMaxLevelByMediaSize = function (e, t, r) {\n          if (null == e || !e.length) return -1;\n          for (var i, a, n = e.length - 1, s = Math.max(t, r), o = 0; o < e.length; o += 1) {\n            var l = e[o];\n            if ((l.width >= s || l.height >= s) && (i = l, !(a = e[o + 1]) || i.width !== a.width || i.height !== a.height)) {\n              n = o;\n              break;\n            }\n          }\n          return n;\n        }, s(e, [{\n          key: \"mediaWidth\",\n          get: function () {\n            return this.getDimensions().width * this.contentScaleFactor;\n          }\n        }, {\n          key: \"mediaHeight\",\n          get: function () {\n            return this.getDimensions().height * this.contentScaleFactor;\n          }\n        }, {\n          key: \"contentScaleFactor\",\n          get: function () {\n            var e = 1;\n            if (!this.hls.config.ignoreDevicePixelRatio) try {\n              e = self.devicePixelRatio;\n            } catch (e) {}\n            return e;\n          }\n        }]), e;\n      }(),\n      cr = function () {\n        function e(e) {\n          this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners();\n        }\n        var t = e.prototype;\n        return t.setStreamController = function (e) {\n          this.streamController = e;\n        }, t.registerListeners = function () {\n          this.hls.on(E.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        }, t.unregisterListeners = function () {\n          this.hls.off(E.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        }, t.destroy = function () {\n          this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null;\n        }, t.onMediaAttaching = function (e, t) {\n          var r = this.hls.config;\n          if (r.capLevelOnFPSDrop) {\n            var i = t.media instanceof self.HTMLVideoElement ? t.media : null;\n            this.media = i, i && \"function\" == typeof i.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), r.fpsDroppedMonitoringPeriod);\n          }\n        }, t.checkFPS = function (e, t, r) {\n          var i = performance.now();\n          if (t) {\n            if (this.lastTime) {\n              var a = i - this.lastTime,\n                n = r - this.lastDroppedFrames,\n                s = t - this.lastDecodedFrames,\n                o = 1e3 * n / a,\n                l = this.hls;\n              if (l.trigger(E.FPS_DROP, {\n                currentDropped: n,\n                currentDecoded: s,\n                totalDroppedFrames: r\n              }), o > 0 && n > l.config.fpsDroppedMonitoringThreshold * s) {\n                var u = l.currentLevel;\n                k.warn(\"drop FPS ratio greater than max allowed value for currentLevel: \" + u), u > 0 && (-1 === l.autoLevelCapping || l.autoLevelCapping >= u) && (u -= 1, l.trigger(E.FPS_DROP_LEVEL_CAPPING, {\n                  level: u,\n                  droppedLevel: l.currentLevel\n                }), l.autoLevelCapping = u, this.streamController.nextLevelSwitch());\n              }\n            }\n            this.lastTime = i, this.lastDroppedFrames = r, this.lastDecodedFrames = t;\n          }\n        }, t.checkFPSInterval = function () {\n          var e = this.media;\n          if (e) if (this.isVideoPlaybackQualityAvailable) {\n            var t = e.getVideoPlaybackQuality();\n            this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames);\n          } else this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount);\n        }, e;\n      }(),\n      vr = function () {\n        function e(e) {\n          this.hls = void 0, this.log = void 0, this.loader = null, this.uri = null, this.pathwayId = \".\", this.pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = e, this.log = k.log.bind(k, \"[content-steering]:\"), this.registerListeners();\n        }\n        var t = e.prototype;\n        return t.registerListeners = function () {\n          var e = this.hls;\n          e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(E.MANIFEST_PARSED, this.onManifestParsed, this), e.on(E.ERROR, this.onError, this);\n        }, t.unregisterListeners = function () {\n          var e = this.hls;\n          e && (e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(E.MANIFEST_PARSED, this.onManifestParsed, this), e.off(E.ERROR, this.onError, this));\n        }, t.startLoad = function () {\n          if (this.started = !0, this.clearTimeout(), this.enabled && this.uri) {\n            if (this.updated) {\n              var e = 1e3 * this.timeToLoad - (performance.now() - this.updated);\n              if (e > 0) return void this.scheduleRefresh(this.uri, e);\n            }\n            this.loadSteeringManifest(this.uri);\n          }\n        }, t.stopLoad = function () {\n          this.started = !1, this.loader && (this.loader.destroy(), this.loader = null), this.clearTimeout();\n        }, t.clearTimeout = function () {\n          -1 !== this.reloadTimer && (self.clearTimeout(this.reloadTimer), this.reloadTimer = -1);\n        }, t.destroy = function () {\n          this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null;\n        }, t.removeLevel = function (e) {\n          var t = this.levels;\n          t && (this.levels = t.filter(function (t) {\n            return t !== e;\n          }));\n        }, t.onManifestLoading = function () {\n          this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = \".\", this.levels = this.audioTracks = this.subtitleTracks = null;\n        }, t.onManifestLoaded = function (e, t) {\n          var r = t.contentSteering;\n          null !== r && (this.pathwayId = r.pathwayId, this.uri = r.uri, this.started && this.startLoad());\n        }, t.onManifestParsed = function (e, t) {\n          this.audioTracks = t.audioTracks, this.subtitleTracks = t.subtitleTracks;\n        }, t.onError = function (e, t) {\n          var r = t.errorAction;\n          if ((null == r ? void 0 : r.action) === qt && r.flags === Jt) {\n            var i = this.levels,\n              a = this.pathwayPriority,\n              n = this.pathwayId;\n            if (t.context) {\n              var s = t.context,\n                o = s.groupId,\n                l = s.pathwayId,\n                u = s.type;\n              o && i ? n = this.getPathwayForGroupId(o, u, n) : l && (n = l);\n            }\n            n in this.penalizedPathways || (this.penalizedPathways[n] = performance.now()), !a && i && (a = i.reduce(function (e, t) {\n              return -1 === e.indexOf(t.pathwayId) && e.push(t.pathwayId), e;\n            }, [])), a && a.length > 1 && (this.updatePathwayPriority(a), r.resolved = this.pathwayId !== n), r.resolved || k.warn(\"Could not resolve \" + t.details + ' (\"' + t.error.message + '\") with content-steering for Pathway: ' + n + \" levels: \" + (i ? i.length : i) + \" priorities: \" + JSON.stringify(a) + \" penalized: \" + JSON.stringify(this.penalizedPathways));\n          }\n        }, t.filterParsedLevels = function (e) {\n          this.levels = e;\n          var t = this.getLevelsForPathway(this.pathwayId);\n          if (0 === t.length) {\n            var r = e[0].pathwayId;\n            this.log(\"No levels found in Pathway \" + this.pathwayId + '. Setting initial Pathway to \"' + r + '\"'), t = this.getLevelsForPathway(r), this.pathwayId = r;\n          }\n          return t.length !== e.length ? (this.log(\"Found \" + t.length + \"/\" + e.length + ' levels in Pathway \"' + this.pathwayId + '\"'), t) : e;\n        }, t.getLevelsForPathway = function (e) {\n          return null === this.levels ? [] : this.levels.filter(function (t) {\n            return e === t.pathwayId;\n          });\n        }, t.updatePathwayPriority = function (e) {\n          var t;\n          this.pathwayPriority = e;\n          var r = this.penalizedPathways,\n            i = performance.now();\n          Object.keys(r).forEach(function (e) {\n            i - r[e] > 3e5 && delete r[e];\n          });\n          for (var a = 0; a < e.length; a++) {\n            var n = e[a];\n            if (!(n in r)) {\n              if (n === this.pathwayId) return;\n              var s = this.hls.nextLoadLevel,\n                o = this.hls.levels[s];\n              if ((t = this.getLevelsForPathway(n)).length > 0) {\n                this.log('Setting Pathway to \"' + n + '\"'), this.pathwayId = n, Mt(t), this.hls.trigger(E.LEVELS_UPDATED, {\n                  levels: t\n                });\n                var l = this.hls.levels[s];\n                o && l && this.levels && (l.attrs[\"STABLE-VARIANT-ID\"] !== o.attrs[\"STABLE-VARIANT-ID\"] && l.bitrate !== o.bitrate && this.log(\"Unstable Pathways change from bitrate \" + o.bitrate + \" to \" + l.bitrate), this.hls.nextLoadLevel = s);\n                break;\n              }\n            }\n          }\n        }, t.getPathwayForGroupId = function (e, t, r) {\n          for (var i = this.getLevelsForPathway(r).concat(this.levels || []), a = 0; a < i.length; a++) if (t === it && i[a].hasAudioGroup(e) || t === at && i[a].hasSubtitleGroup(e)) return i[a].pathwayId;\n          return r;\n        }, t.clonePathways = function (e) {\n          var t = this,\n            r = this.levels;\n          if (r) {\n            var i = {},\n              a = {};\n            e.forEach(function (e) {\n              var n = e.ID,\n                s = e[\"BASE-ID\"],\n                o = e[\"URI-REPLACEMENT\"];\n              if (!r.some(function (e) {\n                return e.pathwayId === n;\n              })) {\n                var l = t.getLevelsForPathway(s).map(function (e) {\n                  var t = new w(e.attrs);\n                  t[\"PATHWAY-ID\"] = n;\n                  var r = t.AUDIO && t.AUDIO + \"_clone_\" + n,\n                    s = t.SUBTITLES && t.SUBTITLES + \"_clone_\" + n;\n                  r && (i[t.AUDIO] = r, t.AUDIO = r), s && (a[t.SUBTITLES] = s, t.SUBTITLES = s);\n                  var l = mr(e.uri, t[\"STABLE-VARIANT-ID\"], \"PER-VARIANT-URIS\", o),\n                    u = new _t({\n                      attrs: t,\n                      audioCodec: e.audioCodec,\n                      bitrate: e.bitrate,\n                      height: e.height,\n                      name: e.name,\n                      url: l,\n                      videoCodec: e.videoCodec,\n                      width: e.width\n                    });\n                  if (e.audioGroups) for (var d = 1; d < e.audioGroups.length; d++) u.addGroupId(\"audio\", e.audioGroups[d] + \"_clone_\" + n);\n                  if (e.subtitleGroups) for (var h = 1; h < e.subtitleGroups.length; h++) u.addGroupId(\"text\", e.subtitleGroups[h] + \"_clone_\" + n);\n                  return u;\n                });\n                r.push.apply(r, l), gr(t.audioTracks, i, o, n), gr(t.subtitleTracks, a, o, n);\n              }\n            });\n          }\n        }, t.loadSteeringManifest = function (e) {\n          var t,\n            r = this,\n            i = this.hls.config,\n            a = i.loader;\n          this.loader && this.loader.destroy(), this.loader = new a(i);\n          try {\n            t = new self.URL(e);\n          } catch (t) {\n            return this.enabled = !1, void this.log(\"Failed to parse Steering Manifest URI: \" + e);\n          }\n          if (\"data:\" !== t.protocol) {\n            var n = 0 | (this.hls.bandwidthEstimate || i.abrEwmaDefaultEstimate);\n            t.searchParams.set(\"_HLS_pathway\", this.pathwayId), t.searchParams.set(\"_HLS_throughput\", \"\" + n);\n          }\n          var s = {\n              responseType: \"json\",\n              url: t.href\n            },\n            o = i.steeringManifestLoadPolicy.default,\n            l = o.errorRetry || o.timeoutRetry || {},\n            u = {\n              loadPolicy: o,\n              timeout: o.maxLoadTimeMs,\n              maxRetry: l.maxNumRetry || 0,\n              retryDelay: l.retryDelayMs || 0,\n              maxRetryDelay: l.maxRetryDelayMs || 0\n            },\n            d = {\n              onSuccess: function (e, i, a, n) {\n                r.log('Loaded steering manifest: \"' + t + '\"');\n                var s = e.data;\n                if (1 === s.VERSION) {\n                  r.updated = performance.now(), r.timeToLoad = s.TTL;\n                  var o = s[\"RELOAD-URI\"],\n                    l = s[\"PATHWAY-CLONES\"],\n                    u = s[\"PATHWAY-PRIORITY\"];\n                  if (o) try {\n                    r.uri = new self.URL(o, t).href;\n                  } catch (e) {\n                    return r.enabled = !1, void r.log(\"Failed to parse Steering Manifest RELOAD-URI: \" + o);\n                  }\n                  r.scheduleRefresh(r.uri || a.url), l && r.clonePathways(l);\n                  var d = {\n                    steeringManifest: s,\n                    url: t.toString()\n                  };\n                  r.hls.trigger(E.STEERING_MANIFEST_LOADED, d), u && r.updatePathwayPriority(u);\n                } else r.log(\"Steering VERSION \" + s.VERSION + \" not supported!\");\n              },\n              onError: function (e, t, i, a) {\n                if (r.log(\"Error loading steering manifest: \" + e.code + \" \" + e.text + \" (\" + t.url + \")\"), r.stopLoad(), 410 === e.code) return r.enabled = !1, void r.log(\"Steering manifest \" + t.url + \" no longer available\");\n                var n = 1e3 * r.timeToLoad;\n                if (429 !== e.code) r.scheduleRefresh(r.uri || t.url, n);else {\n                  var s = r.loader;\n                  if (\"function\" == typeof (null == s ? void 0 : s.getResponseHeader)) {\n                    var o = s.getResponseHeader(\"Retry-After\");\n                    o && (n = 1e3 * parseFloat(o));\n                  }\n                  r.log(\"Steering manifest \" + t.url + \" rate limited\");\n                }\n              },\n              onTimeout: function (e, t, i) {\n                r.log(\"Timeout loading steering manifest (\" + t.url + \")\"), r.scheduleRefresh(r.uri || t.url);\n              }\n            };\n          this.log(\"Requesting steering manifest: \" + t), this.loader.load(s, u, d);\n        }, t.scheduleRefresh = function (e, t) {\n          var r = this;\n          void 0 === t && (t = 1e3 * this.timeToLoad), this.clearTimeout(), this.reloadTimer = self.setTimeout(function () {\n            var t,\n              i = null == (t = r.hls) ? void 0 : t.media;\n            !i || i.ended ? r.scheduleRefresh(e, 1e3 * r.timeToLoad) : r.loadSteeringManifest(e);\n          }, t);\n        }, e;\n      }();\n    function gr(e, t, r, i) {\n      e && Object.keys(t).forEach(function (a) {\n        var n = e.filter(function (e) {\n          return e.groupId === a;\n        }).map(function (e) {\n          var n = o({}, e);\n          return n.details = void 0, n.attrs = new w(n.attrs), n.url = n.attrs.URI = mr(e.url, e.attrs[\"STABLE-RENDITION-ID\"], \"PER-RENDITION-URIS\", r), n.groupId = n.attrs[\"GROUP-ID\"] = t[a], n.attrs[\"PATHWAY-ID\"] = i, n;\n        });\n        e.push.apply(e, n);\n      });\n    }\n    function mr(e, t, r, i) {\n      var a,\n        n = i.HOST,\n        s = i.PARAMS,\n        o = i[r];\n      t && (a = null == o ? void 0 : o[t]) && (e = a);\n      var l = new self.URL(e);\n      return n && !a && (l.host = n), s && Object.keys(s).sort().forEach(function (e) {\n        e && l.searchParams.set(e, s[e]);\n      }), l.href;\n    }\n    var pr = /^age:\\s*[\\d.]+\\s*$/im,\n      yr = function () {\n        function e(e) {\n          this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = null, this.loader = null, this.stats = void 0, this.xhrSetup = e && e.xhrSetup || null, this.stats = new P(), this.retryDelay = 0;\n        }\n        var t = e.prototype;\n        return t.destroy = function () {\n          this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null, this.context = null, this.xhrSetup = null, this.stats = null;\n        }, t.abortInternal = function () {\n          var e = this.loader;\n          self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e && (e.onreadystatechange = null, e.onprogress = null, 4 !== e.readyState && (this.stats.aborted = !0, e.abort()));\n        }, t.abort = function () {\n          var e;\n          this.abortInternal(), null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader);\n        }, t.load = function (e, t, r) {\n          if (this.stats.loading.start) throw new Error(\"Loader can only be used once.\");\n          this.stats.loading.start = self.performance.now(), this.context = e, this.config = t, this.callbacks = r, this.loadInternal();\n        }, t.loadInternal = function () {\n          var e = this,\n            t = this.config,\n            r = this.context;\n          if (t && r) {\n            var i = this.loader = new self.XMLHttpRequest(),\n              a = this.stats;\n            a.loading.first = 0, a.loaded = 0, a.aborted = !1;\n            var n = this.xhrSetup;\n            n ? Promise.resolve().then(function () {\n              if (!e.stats.aborted) return n(i, r.url);\n            }).catch(function (e) {\n              return i.open(\"GET\", r.url, !0), n(i, r.url);\n            }).then(function () {\n              e.stats.aborted || e.openAndSendXhr(i, r, t);\n            }).catch(function (t) {\n              e.callbacks.onError({\n                code: i.status,\n                text: t.message\n              }, r, i, a);\n            }) : this.openAndSendXhr(i, r, t);\n          }\n        }, t.openAndSendXhr = function (e, t, r) {\n          e.readyState || e.open(\"GET\", t.url, !0);\n          var i = t.headers,\n            a = r.loadPolicy,\n            n = a.maxTimeToFirstByteMs,\n            s = a.maxLoadTimeMs;\n          if (i) for (var o in i) e.setRequestHeader(o, i[o]);\n          t.rangeEnd && e.setRequestHeader(\"Range\", \"bytes=\" + t.rangeStart + \"-\" + (t.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, self.clearTimeout(this.requestTimeout), r.timeout = n && m(n) ? n : s, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), r.timeout), e.send();\n        }, t.readystatechange = function () {\n          var e = this.context,\n            t = this.loader,\n            r = this.stats;\n          if (e && t) {\n            var i = t.readyState,\n              a = this.config;\n            if (!r.aborted && i >= 2 && (0 === r.loading.first && (r.loading.first = Math.max(self.performance.now(), r.loading.start), a.timeout !== a.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout), a.timeout = a.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), a.loadPolicy.maxLoadTimeMs - (r.loading.first - r.loading.start)))), 4 === i)) {\n              self.clearTimeout(this.requestTimeout), t.onreadystatechange = null, t.onprogress = null;\n              var n = t.status,\n                s = \"text\" !== t.responseType;\n              if (n >= 200 && n < 300 && (s && t.response || null !== t.responseText)) {\n                r.loading.end = Math.max(self.performance.now(), r.loading.first);\n                var o = s ? t.response : t.responseText,\n                  l = \"arraybuffer\" === t.responseType ? o.byteLength : o.length;\n                if (r.loaded = r.total = l, r.bwEstimate = 8e3 * r.total / (r.loading.end - r.loading.first), !this.callbacks) return;\n                var u = this.callbacks.onProgress;\n                if (u && u(r, e, o, t), !this.callbacks) return;\n                var d = {\n                  url: t.responseURL,\n                  data: o,\n                  code: n\n                };\n                this.callbacks.onSuccess(d, r, e, t);\n              } else {\n                var h = a.loadPolicy.errorRetry;\n                Ht(h, r.retry, !1, {\n                  url: e.url,\n                  data: void 0,\n                  code: n\n                }) ? this.retry(h) : (k.error(n + \" while loading \" + e.url), this.callbacks.onError({\n                  code: n,\n                  text: t.statusText\n                }, e, t, r));\n              }\n            }\n          }\n        }, t.loadtimeout = function () {\n          var e,\n            t = null == (e = this.config) ? void 0 : e.loadPolicy.timeoutRetry;\n          if (Ht(t, this.stats.retry, !0)) this.retry(t);else {\n            var r;\n            k.warn(\"timeout while loading \" + (null == (r = this.context) ? void 0 : r.url));\n            var i = this.callbacks;\n            i && (this.abortInternal(), i.onTimeout(this.stats, this.context, this.loader));\n          }\n        }, t.retry = function (e) {\n          var t = this.context,\n            r = this.stats;\n          this.retryDelay = Ut(e, r.retry), r.retry++, k.warn((status ? \"HTTP Status \" + status : \"Timeout\") + \" while loading \" + (null == t ? void 0 : t.url) + \", retrying \" + r.retry + \"/\" + e.maxNumRetry + \" in \" + this.retryDelay + \"ms\"), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n        }, t.loadprogress = function (e) {\n          var t = this.stats;\n          t.loaded = e.loaded, e.lengthComputable && (t.total = e.total);\n        }, t.getCacheAge = function () {\n          var e = null;\n          if (this.loader && pr.test(this.loader.getAllResponseHeaders())) {\n            var t = this.loader.getResponseHeader(\"age\");\n            e = t ? parseFloat(t) : null;\n          }\n          return e;\n        }, t.getResponseHeader = function (e) {\n          return this.loader && new RegExp(\"^\" + e + \":\\\\s*[\\\\d.]+\\\\s*$\", \"im\").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null;\n        }, e;\n      }(),\n      Er = function () {\n        function e() {\n          this.chunks = [], this.dataLength = 0;\n        }\n        var t = e.prototype;\n        return t.push = function (e) {\n          this.chunks.push(e), this.dataLength += e.length;\n        }, t.flush = function () {\n          var e,\n            t = this.chunks,\n            r = this.dataLength;\n          return t.length ? (e = 1 === t.length ? t[0] : function (e, t) {\n            for (var r = new Uint8Array(t), i = 0, a = 0; a < e.length; a++) {\n              var n = e[a];\n              r.set(n, i), i += n.length;\n            }\n            return r;\n          }(t, r), this.reset(), e) : new Uint8Array(0);\n        }, t.reset = function () {\n          this.chunks.length = 0, this.dataLength = 0;\n        }, e;\n      }(),\n      Tr = /(\\d+)-(\\d+)\\/(\\d+)/,\n      Sr = function () {\n        function e(e) {\n          this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = null, this.response = null, this.controller = void 0, this.context = null, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || Lr, this.controller = new self.AbortController(), this.stats = new P();\n        }\n        var t = e.prototype;\n        return t.destroy = function () {\n          this.loader = this.callbacks = this.context = this.config = this.request = null, this.abortInternal(), this.response = null, this.fetchSetup = this.controller = this.stats = null;\n        }, t.abortInternal = function () {\n          this.controller && !this.stats.loading.end && (this.stats.aborted = !0, this.controller.abort());\n        }, t.abort = function () {\n          var e;\n          this.abortInternal(), null != (e = this.callbacks) && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response);\n        }, t.load = function (e, t, r) {\n          var i = this,\n            a = this.stats;\n          if (a.loading.start) throw new Error(\"Loader can only be used once.\");\n          a.loading.start = self.performance.now();\n          var n = function (e, t) {\n              var r = {\n                method: \"GET\",\n                mode: \"cors\",\n                credentials: \"same-origin\",\n                signal: t,\n                headers: new self.Headers(o({}, e.headers))\n              };\n              return e.rangeEnd && r.headers.set(\"Range\", \"bytes=\" + e.rangeStart + \"-\" + String(e.rangeEnd - 1)), r;\n            }(e, this.controller.signal),\n            s = r.onProgress,\n            l = \"arraybuffer\" === e.responseType,\n            u = l ? \"byteLength\" : \"length\",\n            d = t.loadPolicy,\n            h = d.maxTimeToFirstByteMs,\n            f = d.maxLoadTimeMs;\n          this.context = e, this.config = t, this.callbacks = r, this.request = this.fetchSetup(e, n), self.clearTimeout(this.requestTimeout), t.timeout = h && m(h) ? h : f, this.requestTimeout = self.setTimeout(function () {\n            i.abortInternal(), r.onTimeout(a, e, i.response);\n          }, t.timeout), self.fetch(this.request).then(function (n) {\n            i.response = i.loader = n;\n            var o = Math.max(self.performance.now(), a.loading.start);\n            if (self.clearTimeout(i.requestTimeout), t.timeout = f, i.requestTimeout = self.setTimeout(function () {\n              i.abortInternal(), r.onTimeout(a, e, i.response);\n            }, f - (o - a.loading.start)), !n.ok) {\n              var u = n.status,\n                d = n.statusText;\n              throw new Ar(d || \"fetch, bad network response\", u, n);\n            }\n            return a.loading.first = o, a.total = function (e) {\n              var t = e.get(\"Content-Range\");\n              if (t) {\n                var r = function (e) {\n                  var t = Tr.exec(e);\n                  if (t) return parseInt(t[2]) - parseInt(t[1]) + 1;\n                }(t);\n                if (m(r)) return r;\n              }\n              var i = e.get(\"Content-Length\");\n              if (i) return parseInt(i);\n            }(n.headers) || a.total, s && m(t.highWaterMark) ? i.loadProgressively(n, a, e, t.highWaterMark, s) : l ? n.arrayBuffer() : \"json\" === e.responseType ? n.json() : n.text();\n          }).then(function (n) {\n            var o = i.response;\n            if (!o) throw new Error(\"loader destroyed\");\n            self.clearTimeout(i.requestTimeout), a.loading.end = Math.max(self.performance.now(), a.loading.first);\n            var l = n[u];\n            l && (a.loaded = a.total = l);\n            var d = {\n              url: o.url,\n              data: n,\n              code: o.status\n            };\n            s && !m(t.highWaterMark) && s(a, e, n, o), r.onSuccess(d, a, e, o);\n          }).catch(function (t) {\n            if (self.clearTimeout(i.requestTimeout), !a.aborted) {\n              var n = t && t.code || 0,\n                s = t ? t.message : null;\n              r.onError({\n                code: n,\n                text: s\n              }, e, t ? t.details : null, a);\n            }\n          });\n        }, t.getCacheAge = function () {\n          var e = null;\n          if (this.response) {\n            var t = this.response.headers.get(\"age\");\n            e = t ? parseFloat(t) : null;\n          }\n          return e;\n        }, t.getResponseHeader = function (e) {\n          return this.response ? this.response.headers.get(e) : null;\n        }, t.loadProgressively = function (e, t, r, i, a) {\n          void 0 === i && (i = 0);\n          var n = new Er(),\n            s = e.body.getReader();\n          return function o() {\n            return s.read().then(function (s) {\n              if (s.done) return n.dataLength && a(t, r, n.flush(), e), Promise.resolve(new ArrayBuffer(0));\n              var l = s.value,\n                u = l.length;\n              return t.loaded += u, u < i || n.dataLength ? (n.push(l), n.dataLength >= i && a(t, r, n.flush(), e)) : a(t, r, l, e), o();\n            }).catch(function () {\n              return Promise.reject();\n            });\n          }();\n        }, e;\n      }();\n    function Lr(e, t) {\n      return new self.Request(e.url, t);\n    }\n    var Rr,\n      Ar = function (e) {\n        function t(t, r, i) {\n          var a;\n          return (a = e.call(this, t) || this).code = void 0, a.details = void 0, a.code = r, a.details = i, a;\n        }\n        return l(t, e), t;\n      }(f(Error)),\n      br = i(i({\n        autoStartLoad: !0,\n        startPosition: -1,\n        defaultAudioCodec: void 0,\n        debug: !1,\n        capLevelOnFPSDrop: !1,\n        capLevelToPlayerSize: !1,\n        ignoreDevicePixelRatio: !1,\n        preferManagedMediaSource: !0,\n        initialLiveManifestSize: 1,\n        maxBufferLength: 30,\n        backBufferLength: 1 / 0,\n        frontBufferFlushThreshold: 1 / 0,\n        maxBufferSize: 6e7,\n        maxBufferHole: .1,\n        highBufferWatchdogPeriod: 2,\n        nudgeOffset: .1,\n        nudgeMaxRetry: 3,\n        maxFragLookUpTolerance: .25,\n        liveSyncDurationCount: 3,\n        liveMaxLatencyDurationCount: 1 / 0,\n        liveSyncDuration: void 0,\n        liveMaxLatencyDuration: void 0,\n        maxLiveSyncPlaybackRate: 1,\n        liveDurationInfinity: !1,\n        liveBackBufferLength: null,\n        maxMaxBufferLength: 600,\n        enableWorker: !0,\n        workerPath: null,\n        enableSoftwareAES: !0,\n        startLevel: void 0,\n        startFragPrefetch: !1,\n        fpsDroppedMonitoringPeriod: 5e3,\n        fpsDroppedMonitoringThreshold: .2,\n        appendErrorMaxRetry: 3,\n        loader: yr,\n        fLoader: void 0,\n        pLoader: void 0,\n        xhrSetup: void 0,\n        licenseXhrSetup: void 0,\n        licenseResponseCallback: void 0,\n        abrController: nr,\n        bufferController: dr,\n        capLevelController: fr,\n        errorController: Zt,\n        fpsController: cr,\n        stretchShortVideoTrack: !1,\n        maxAudioFramesDrift: 1,\n        forceKeyFrameOnDiscontinuity: !0,\n        abrEwmaFastLive: 3,\n        abrEwmaSlowLive: 9,\n        abrEwmaFastVoD: 3,\n        abrEwmaSlowVoD: 9,\n        abrEwmaDefaultEstimate: 5e5,\n        abrEwmaDefaultEstimateMax: 5e6,\n        abrBandWidthFactor: .95,\n        abrBandWidthUpFactor: .7,\n        abrMaxWithRealBitrate: !1,\n        maxStarvationDelay: 4,\n        maxLoadingDelay: 4,\n        minAutoBitrate: 0,\n        emeEnabled: !1,\n        widevineLicenseUrl: void 0,\n        drmSystems: {},\n        drmSystemOptions: {},\n        requestMediaKeySystemAccessFunc: null,\n        testBandwidth: !0,\n        progressive: !1,\n        lowLatencyMode: !0,\n        cmcd: void 0,\n        enableDateRangeMetadataCues: !0,\n        enableEmsgMetadataCues: !0,\n        enableID3MetadataCues: !0,\n        useMediaCapabilities: !1,\n        certLoadPolicy: {\n          default: {\n            maxTimeToFirstByteMs: 8e3,\n            maxLoadTimeMs: 2e4,\n            timeoutRetry: null,\n            errorRetry: null\n          }\n        },\n        keyLoadPolicy: {\n          default: {\n            maxTimeToFirstByteMs: 8e3,\n            maxLoadTimeMs: 2e4,\n            timeoutRetry: {\n              maxNumRetry: 1,\n              retryDelayMs: 1e3,\n              maxRetryDelayMs: 2e4,\n              backoff: \"linear\"\n            },\n            errorRetry: {\n              maxNumRetry: 8,\n              retryDelayMs: 1e3,\n              maxRetryDelayMs: 2e4,\n              backoff: \"linear\"\n            }\n          }\n        },\n        manifestLoadPolicy: {\n          default: {\n            maxTimeToFirstByteMs: 1 / 0,\n            maxLoadTimeMs: 2e4,\n            timeoutRetry: {\n              maxNumRetry: 2,\n              retryDelayMs: 0,\n              maxRetryDelayMs: 0\n            },\n            errorRetry: {\n              maxNumRetry: 1,\n              retryDelayMs: 1e3,\n              maxRetryDelayMs: 8e3\n            }\n          }\n        },\n        playlistLoadPolicy: {\n          default: {\n            maxTimeToFirstByteMs: 1e4,\n            maxLoadTimeMs: 2e4,\n            timeoutRetry: {\n              maxNumRetry: 2,\n              retryDelayMs: 0,\n              maxRetryDelayMs: 0\n            },\n            errorRetry: {\n              maxNumRetry: 2,\n              retryDelayMs: 1e3,\n              maxRetryDelayMs: 8e3\n            }\n          }\n        },\n        fragLoadPolicy: {\n          default: {\n            maxTimeToFirstByteMs: 1e4,\n            maxLoadTimeMs: 12e4,\n            timeoutRetry: {\n              maxNumRetry: 4,\n              retryDelayMs: 0,\n              maxRetryDelayMs: 0\n            },\n            errorRetry: {\n              maxNumRetry: 6,\n              retryDelayMs: 1e3,\n              maxRetryDelayMs: 8e3\n            }\n          }\n        },\n        steeringManifestLoadPolicy: {\n          default: {\n            maxTimeToFirstByteMs: 1e4,\n            maxLoadTimeMs: 2e4,\n            timeoutRetry: {\n              maxNumRetry: 2,\n              retryDelayMs: 0,\n              maxRetryDelayMs: 0\n            },\n            errorRetry: {\n              maxNumRetry: 1,\n              retryDelayMs: 1e3,\n              maxRetryDelayMs: 8e3\n            }\n          }\n        },\n        manifestLoadingTimeOut: 1e4,\n        manifestLoadingMaxRetry: 1,\n        manifestLoadingRetryDelay: 1e3,\n        manifestLoadingMaxRetryTimeout: 64e3,\n        levelLoadingTimeOut: 1e4,\n        levelLoadingMaxRetry: 4,\n        levelLoadingRetryDelay: 1e3,\n        levelLoadingMaxRetryTimeout: 64e3,\n        fragLoadingTimeOut: 2e4,\n        fragLoadingMaxRetry: 6,\n        fragLoadingRetryDelay: 1e3,\n        fragLoadingMaxRetryTimeout: 64e3\n      }, {\n        cueHandler: H,\n        enableWebVTT: !1,\n        enableIMSC1: !1,\n        enableCEA708Captions: !1,\n        captionsTextTrack1Label: \"English\",\n        captionsTextTrack1LanguageCode: \"en\",\n        captionsTextTrack2Label: \"Spanish\",\n        captionsTextTrack2LanguageCode: \"es\",\n        captionsTextTrack3Label: \"Unknown CC\",\n        captionsTextTrack3LanguageCode: \"\",\n        captionsTextTrack4Label: \"Unknown CC\",\n        captionsTextTrack4LanguageCode: \"\",\n        renderTextTracksNatively: !0\n      }), {}, {\n        subtitleStreamController: void 0,\n        subtitleTrackController: void 0,\n        timelineController: void 0,\n        audioStreamController: void 0,\n        audioTrackController: void 0,\n        emeController: void 0,\n        cmcdController: void 0,\n        contentSteeringController: vr\n      });\n    function Dr(e) {\n      return e && \"object\" == typeof e ? Array.isArray(e) ? e.map(Dr) : Object.keys(e).reduce(function (t, r) {\n        return t[r] = Dr(e[r]), t;\n      }, {}) : e;\n    }\n    function kr(e) {\n      var t = e.loader;\n      t !== Sr && t !== yr ? (k.log(\"[config]: Custom loader detected, cannot enable progressive streaming\"), e.progressive = !1) : function () {\n        if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try {\n          return new self.ReadableStream({}), !0;\n        } catch (e) {}\n        return !1;\n      }() && (e.loader = Sr, e.progressive = !0, e.enableSoftwareAES = !0, k.log(\"[config]: Progressive streaming enabled, using FetchLoader\"));\n    }\n    var _r = function (e) {\n      function t(t, r) {\n        var i;\n        return (i = e.call(this, t, \"[level-controller]\") || this)._levels = [], i._firstLevel = -1, i._maxAutoLevel = -1, i._startLevel = void 0, i.currentLevel = null, i.currentLevelIndex = -1, i.manualLevelIndex = -1, i.steering = void 0, i.onParsedComplete = void 0, i.steering = r, i._registerListeners(), i;\n      }\n      l(t, e);\n      var r = t.prototype;\n      return r._registerListeners = function () {\n        var e = this.hls;\n        e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(E.LEVEL_LOADED, this.onLevelLoaded, this), e.on(E.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(E.FRAG_BUFFERED, this.onFragBuffered, this), e.on(E.ERROR, this.onError, this);\n      }, r._unregisterListeners = function () {\n        var e = this.hls;\n        e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(E.LEVEL_LOADED, this.onLevelLoaded, this), e.off(E.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(E.FRAG_BUFFERED, this.onFragBuffered, this), e.off(E.ERROR, this.onError, this);\n      }, r.destroy = function () {\n        this._unregisterListeners(), this.steering = null, this.resetLevels(), e.prototype.destroy.call(this);\n      }, r.stopLoad = function () {\n        this._levels.forEach(function (e) {\n          e.loadError = 0, e.fragmentError = 0;\n        }), e.prototype.stopLoad.call(this);\n      }, r.resetLevels = function () {\n        this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = [], this._maxAutoLevel = -1;\n      }, r.onManifestLoading = function (e, t) {\n        this.resetLevels();\n      }, r.onManifestLoaded = function (e, t) {\n        var r = this.hls.config.preferManagedMediaSource,\n          i = [],\n          a = {},\n          n = {},\n          s = !1,\n          o = !1,\n          l = !1;\n        t.levels.forEach(function (e) {\n          var t,\n            u,\n            d = e.attrs,\n            h = e.audioCodec,\n            f = e.videoCodec;\n          -1 !== (null == (t = h) ? void 0 : t.indexOf(\"mp4a.40.34\")) && (Rr || (Rr = /chrome|firefox/i.test(navigator.userAgent)), Rr && (e.audioCodec = h = void 0)), h && (e.audioCodec = h = Ge(h, r)), 0 === (null == (u = f) ? void 0 : u.indexOf(\"avc1\")) && (f = e.videoCodec = function (e) {\n            var t = e.split(\".\");\n            if (t.length > 2) {\n              var r = t.shift() + \".\";\n              return (r += parseInt(t.shift()).toString(16)) + (\"000\" + parseInt(t.shift()).toString(16)).slice(-4);\n            }\n            return e;\n          }(f));\n          var c = e.width,\n            v = e.height,\n            g = e.unknownCodecs;\n          if (s || (s = !(!c || !v)), o || (o = !!f), l || (l = !!h), !(null != g && g.length || h && !Pe(h, \"audio\", r) || f && !Pe(f, \"video\", r))) {\n            var m = d.CODECS,\n              p = d[\"FRAME-RATE\"],\n              y = d[\"HDCP-LEVEL\"],\n              E = d[\"PATHWAY-ID\"],\n              T = d.RESOLUTION,\n              S = d[\"VIDEO-RANGE\"],\n              L = (E || \".\") + \"-\" + e.bitrate + \"-\" + T + \"-\" + p + \"-\" + m + \"-\" + S + \"-\" + y;\n            if (a[L]) {\n              if (a[L].uri === e.url || e.attrs[\"PATHWAY-ID\"]) a[L].addGroupId(\"audio\", d.AUDIO), a[L].addGroupId(\"text\", d.SUBTITLES);else {\n                var R = n[L] += 1;\n                e.attrs[\"PATHWAY-ID\"] = new Array(R + 1).join(\".\");\n                var A = new _t(e);\n                a[L] = A, i.push(A);\n              }\n            } else {\n              var b = new _t(e);\n              a[L] = b, n[L] = 1, i.push(b);\n            }\n          }\n        }), this.filterAndSortMediaOptions(i, t, s, o, l);\n      }, r.filterAndSortMediaOptions = function (e, t, r, i, a) {\n        var n = this,\n          s = [],\n          o = [],\n          l = e;\n        if ((r || i) && a && (l = l.filter(function (e) {\n          var t,\n            r = e.videoCodec,\n            i = e.videoRange,\n            a = e.width,\n            n = e.height;\n          return (!!r || !(!a || !n)) && !!(t = i) && Rt.indexOf(t) > -1;\n        })), 0 !== l.length) {\n          if (t.audioTracks) {\n            var u = this.hls.config.preferManagedMediaSource;\n            xr(s = t.audioTracks.filter(function (e) {\n              return !e.audioCodec || Pe(e.audioCodec, \"audio\", u);\n            }));\n          }\n          t.subtitles && xr(o = t.subtitles);\n          var d = l.slice(0);\n          l.sort(function (e, t) {\n            if (e.attrs[\"HDCP-LEVEL\"] !== t.attrs[\"HDCP-LEVEL\"]) return (e.attrs[\"HDCP-LEVEL\"] || \"\") > (t.attrs[\"HDCP-LEVEL\"] || \"\") ? 1 : -1;\n            if (r && e.height !== t.height) return e.height - t.height;\n            if (e.frameRate !== t.frameRate) return e.frameRate - t.frameRate;\n            if (e.videoRange !== t.videoRange) return Rt.indexOf(e.videoRange) - Rt.indexOf(t.videoRange);\n            if (e.videoCodec !== t.videoCodec) {\n              var i = Me(e.videoCodec),\n                a = Me(t.videoCodec);\n              if (i !== a) return a - i;\n            }\n            if (e.uri === t.uri && e.codecSet !== t.codecSet) {\n              var n = Ne(e.codecSet),\n                s = Ne(t.codecSet);\n              if (n !== s) return s - n;\n            }\n            return e.averageBitrate !== t.averageBitrate ? e.averageBitrate - t.averageBitrate : 0;\n          });\n          var h = d[0];\n          if (this.steering && (l = this.steering.filterParsedLevels(l)).length !== d.length) for (var f = 0; f < d.length; f++) if (d[f].pathwayId === l[0].pathwayId) {\n            h = d[f];\n            break;\n          }\n          this._levels = l;\n          for (var c = 0; c < l.length; c++) if (l[c] === h) {\n            var v;\n            this._firstLevel = c;\n            var g = h.bitrate,\n              m = this.hls.bandwidthEstimate;\n            if (this.log(\"manifest loaded, \" + l.length + \" level(s) found, first bitrate: \" + g), void 0 === (null == (v = this.hls.userConfig) ? void 0 : v.abrEwmaDefaultEstimate)) {\n              var p = Math.min(g, this.hls.config.abrEwmaDefaultEstimateMax);\n              p > m && m === br.abrEwmaDefaultEstimate && (this.hls.bandwidthEstimate = p);\n            }\n            break;\n          }\n          var y = a && !i,\n            L = {\n              levels: l,\n              audioTracks: s,\n              subtitleTracks: o,\n              sessionData: t.sessionData,\n              sessionKeys: t.sessionKeys,\n              firstLevel: this._firstLevel,\n              stats: t.stats,\n              audio: a,\n              video: i,\n              altAudio: !y && s.some(function (e) {\n                return !!e.url;\n              })\n            };\n          this.hls.trigger(E.MANIFEST_PARSED, L), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition);\n        } else Promise.resolve().then(function () {\n          if (n.hls) {\n            t.levels.length && n.warn(\"One or more CODECS in variant not supported: \" + JSON.stringify(t.levels[0].attrs));\n            var e = new Error(\"no level with compatible codecs found in manifest\");\n            n.hls.trigger(E.ERROR, {\n              type: T.MEDIA_ERROR,\n              details: S.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n              fatal: !0,\n              url: t.url,\n              error: e,\n              reason: e.message\n            });\n          }\n        });\n      }, r.onError = function (e, t) {\n        !t.fatal && t.context && t.context.type === rt && t.context.level === this.level && this.checkRetry(t);\n      }, r.onFragBuffered = function (e, t) {\n        var r = t.frag;\n        if (void 0 !== r && r.type === nt) {\n          var i = r.elementaryStreams;\n          if (!Object.keys(i).some(function (e) {\n            return !!i[e];\n          })) return;\n          var a = this._levels[r.level];\n          null != a && a.loadError && (this.log(\"Resetting level error count of \" + a.loadError + \" on frag buffered\"), a.loadError = 0);\n        }\n      }, r.onLevelLoaded = function (e, t) {\n        var r,\n          i,\n          a = t.level,\n          n = t.details,\n          s = this._levels[a];\n        if (!s) return this.warn(\"Invalid level index \" + a), void (null != (i = t.deliveryDirectives) && i.skip && (n.deltaUpdateFailed = !0));\n        a === this.currentLevelIndex ? (0 === s.fragmentError && (s.loadError = 0), this.playlistLoaded(a, t, s.details)) : null != (r = t.deliveryDirectives) && r.skip && (n.deltaUpdateFailed = !0);\n      }, r.loadPlaylist = function (t) {\n        e.prototype.loadPlaylist.call(this);\n        var r = this.currentLevelIndex,\n          i = this.currentLevel;\n        if (i && this.shouldLoadPlaylist(i)) {\n          var a = i.uri;\n          if (t) try {\n            a = t.addDirectives(a);\n          } catch (e) {\n            this.warn(\"Could not construct new URL with HLS Delivery Directives: \" + e);\n          }\n          var n = i.attrs[\"PATHWAY-ID\"];\n          this.log(\"Loading level index \" + r + (void 0 !== (null == t ? void 0 : t.msn) ? \" at sn \" + t.msn + \" part \" + t.part : \"\") + \" with\" + (n ? \" Pathway \" + n : \"\") + \" \" + a), this.clearTimer(), this.hls.trigger(E.LEVEL_LOADING, {\n            url: a,\n            level: r,\n            pathwayId: i.attrs[\"PATHWAY-ID\"],\n            id: 0,\n            deliveryDirectives: t || null\n          });\n        }\n      }, r.removeLevel = function (e) {\n        var t,\n          r = this,\n          i = this._levels.filter(function (t, i) {\n            return i !== e || (r.steering && r.steering.removeLevel(t), t === r.currentLevel && (r.currentLevel = null, r.currentLevelIndex = -1, t.details && t.details.fragments.forEach(function (e) {\n              return e.level = -1;\n            })), !1);\n          });\n        Mt(i), this._levels = i, this.currentLevelIndex > -1 && null != (t = this.currentLevel) && t.details && (this.currentLevelIndex = this.currentLevel.details.fragments[0].level), this.hls.trigger(E.LEVELS_UPDATED, {\n          levels: i\n        });\n      }, r.onLevelsUpdated = function (e, t) {\n        var r = t.levels;\n        this._levels = r;\n      }, r.checkMaxAutoUpdated = function () {\n        var e = this.hls,\n          t = e.autoLevelCapping,\n          r = e.maxAutoLevel,\n          i = e.maxHdcpLevel;\n        this._maxAutoLevel !== r && (this._maxAutoLevel = r, this.hls.trigger(E.MAX_AUTO_LEVEL_UPDATED, {\n          autoLevelCapping: t,\n          levels: this.levels,\n          maxAutoLevel: r,\n          minAutoLevel: this.hls.minAutoLevel,\n          maxHdcpLevel: i\n        }));\n      }, s(t, [{\n        key: \"levels\",\n        get: function () {\n          return 0 === this._levels.length ? null : this._levels;\n        }\n      }, {\n        key: \"level\",\n        get: function () {\n          return this.currentLevelIndex;\n        },\n        set: function (e) {\n          var t = this._levels;\n          if (0 !== t.length) {\n            if (e < 0 || e >= t.length) {\n              var r = new Error(\"invalid level idx\"),\n                i = e < 0;\n              if (this.hls.trigger(E.ERROR, {\n                type: T.OTHER_ERROR,\n                details: S.LEVEL_SWITCH_ERROR,\n                level: e,\n                fatal: i,\n                error: r,\n                reason: r.message\n              }), i) return;\n              e = Math.min(e, t.length - 1);\n            }\n            var a = this.currentLevelIndex,\n              n = this.currentLevel,\n              s = n ? n.attrs[\"PATHWAY-ID\"] : void 0,\n              o = t[e],\n              l = o.attrs[\"PATHWAY-ID\"];\n            if (this.currentLevelIndex = e, this.currentLevel = o, a !== e || !o.details || !n || s !== l) {\n              this.log(\"Switching to level \" + e + \" (\" + (o.height ? o.height + \"p \" : \"\") + (o.videoRange ? o.videoRange + \" \" : \"\") + (o.codecSet ? o.codecSet + \" \" : \"\") + \"@\" + o.bitrate + \")\" + (l ? \" with Pathway \" + l : \"\") + \" from level \" + a + (s ? \" with Pathway \" + s : \"\"));\n              var u = {\n                level: e,\n                attrs: o.attrs,\n                details: o.details,\n                bitrate: o.bitrate,\n                averageBitrate: o.averageBitrate,\n                maxBitrate: o.maxBitrate,\n                realBitrate: o.realBitrate,\n                width: o.width,\n                height: o.height,\n                codecSet: o.codecSet,\n                audioCodec: o.audioCodec,\n                videoCodec: o.videoCodec,\n                audioGroups: o.audioGroups,\n                subtitleGroups: o.subtitleGroups,\n                loaded: o.loaded,\n                loadError: o.loadError,\n                fragmentError: o.fragmentError,\n                name: o.name,\n                id: o.id,\n                uri: o.uri,\n                url: o.url,\n                urlId: 0,\n                audioGroupIds: o.audioGroupIds,\n                textGroupIds: o.textGroupIds\n              };\n              this.hls.trigger(E.LEVEL_SWITCHING, u);\n              var d = o.details;\n              if (!d || d.live) {\n                var h = this.switchParams(o.uri, null == n ? void 0 : n.details);\n                this.loadPlaylist(h);\n              }\n            }\n          }\n        }\n      }, {\n        key: \"manualLevel\",\n        get: function () {\n          return this.manualLevelIndex;\n        },\n        set: function (e) {\n          this.manualLevelIndex = e, void 0 === this._startLevel && (this._startLevel = e), -1 !== e && (this.level = e);\n        }\n      }, {\n        key: \"firstLevel\",\n        get: function () {\n          return this._firstLevel;\n        },\n        set: function (e) {\n          this._firstLevel = e;\n        }\n      }, {\n        key: \"startLevel\",\n        get: function () {\n          if (void 0 === this._startLevel) {\n            var e = this.hls.config.startLevel;\n            return void 0 !== e ? e : this.hls.firstAutoLevel;\n          }\n          return this._startLevel;\n        },\n        set: function (e) {\n          this._startLevel = e;\n        }\n      }, {\n        key: \"nextLoadLevel\",\n        get: function () {\n          return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel;\n        },\n        set: function (e) {\n          this.level = e, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = e);\n        }\n      }]), t;\n    }(er);\n    function xr(e) {\n      var t = {};\n      e.forEach(function (e) {\n        var r = e.groupId || \"\";\n        e.id = t[r] = t[r] || 0, t[r]++;\n      });\n    }\n    var wr = \"NOT_LOADED\",\n      Cr = \"APPENDING\",\n      Ir = \"PARTIAL\",\n      Pr = \"OK\",\n      Fr = function () {\n        function e(e) {\n          this.activePartLists = Object.create(null), this.endListFragments = Object.create(null), this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hasGaps = !1, this.hls = e, this._registerListeners();\n        }\n        var t = e.prototype;\n        return t._registerListeners = function () {\n          var e = this.hls;\n          e.on(E.BUFFER_APPENDED, this.onBufferAppended, this), e.on(E.FRAG_BUFFERED, this.onFragBuffered, this), e.on(E.FRAG_LOADED, this.onFragLoaded, this);\n        }, t._unregisterListeners = function () {\n          var e = this.hls;\n          e.off(E.BUFFER_APPENDED, this.onBufferAppended, this), e.off(E.FRAG_BUFFERED, this.onFragBuffered, this), e.off(E.FRAG_LOADED, this.onFragLoaded, this);\n        }, t.destroy = function () {\n          this._unregisterListeners(), this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null;\n        }, t.getAppendedFrag = function (e, t) {\n          var r = this.activePartLists[t];\n          if (r) for (var i = r.length; i--;) {\n            var a = r[i];\n            if (!a) break;\n            var n = a.end;\n            if (a.start <= e && null !== n && e <= n) return a;\n          }\n          return this.getBufferedFrag(e, t);\n        }, t.getBufferedFrag = function (e, t) {\n          for (var r = this.fragments, i = Object.keys(r), a = i.length; a--;) {\n            var n = r[i[a]];\n            if ((null == n ? void 0 : n.body.type) === t && n.buffered) {\n              var s = n.body;\n              if (s.start <= e && e <= s.end) return s;\n            }\n          }\n          return null;\n        }, t.detectEvictedFragments = function (e, t, r, i) {\n          var a = this;\n          this.timeRanges && (this.timeRanges[e] = t);\n          var n = (null == i ? void 0 : i.fragment.sn) || -1;\n          Object.keys(this.fragments).forEach(function (i) {\n            var s = a.fragments[i];\n            if (s && !(n >= s.body.sn)) if (s.buffered || s.loaded) {\n              var o = s.range[e];\n              o && o.time.some(function (e) {\n                var r = !a.isTimeBuffered(e.startPTS, e.endPTS, t);\n                return r && a.removeFragment(s.body), r;\n              });\n            } else s.body.type === r && a.removeFragment(s.body);\n          });\n        }, t.detectPartialFragments = function (e) {\n          var t = this,\n            r = this.timeRanges,\n            i = e.frag,\n            a = e.part;\n          if (r && \"initSegment\" !== i.sn) {\n            var n = Mr(i),\n              s = this.fragments[n];\n            if (!(!s || s.buffered && i.gap)) {\n              var o = !i.relurl;\n              Object.keys(r).forEach(function (e) {\n                var n = i.elementaryStreams[e];\n                if (n) {\n                  var l = r[e],\n                    u = o || !0 === n.partial;\n                  s.range[e] = t.getBufferedTimes(i, a, u, l);\n                }\n              }), s.loaded = null, Object.keys(s.range).length ? (s.buffered = !0, (s.body.endList = i.endList || s.body.endList) && (this.endListFragments[s.body.type] = s), Or(s) || this.removeParts(i.sn - 1, i.type)) : this.removeFragment(s.body);\n            }\n          }\n        }, t.removeParts = function (e, t) {\n          var r = this.activePartLists[t];\n          r && (this.activePartLists[t] = r.filter(function (t) {\n            return t.fragment.sn >= e;\n          }));\n        }, t.fragBuffered = function (e, t) {\n          var r = Mr(e),\n            i = this.fragments[r];\n          !i && t && (i = this.fragments[r] = {\n            body: e,\n            appendedPTS: null,\n            loaded: null,\n            buffered: !1,\n            range: Object.create(null)\n          }, e.gap && (this.hasGaps = !0)), i && (i.loaded = null, i.buffered = !0);\n        }, t.getBufferedTimes = function (e, t, r, i) {\n          for (var a = {\n              time: [],\n              partial: r\n            }, n = e.start, s = e.end, o = e.minEndPTS || s, l = e.maxStartPTS || n, u = 0; u < i.length; u++) {\n            var d = i.start(u) - this.bufferPadding,\n              h = i.end(u) + this.bufferPadding;\n            if (l >= d && o <= h) {\n              a.time.push({\n                startPTS: Math.max(n, i.start(u)),\n                endPTS: Math.min(s, i.end(u))\n              });\n              break;\n            }\n            if (n < h && s > d) {\n              var f = Math.max(n, i.start(u)),\n                c = Math.min(s, i.end(u));\n              c > f && (a.partial = !0, a.time.push({\n                startPTS: f,\n                endPTS: c\n              }));\n            } else if (s <= d) break;\n          }\n          return a;\n        }, t.getPartialFragment = function (e) {\n          var t,\n            r,\n            i,\n            a = null,\n            n = 0,\n            s = this.bufferPadding,\n            o = this.fragments;\n          return Object.keys(o).forEach(function (l) {\n            var u = o[l];\n            u && Or(u) && (r = u.body.start - s, i = u.body.end + s, e >= r && e <= i && (t = Math.min(e - r, i - e), n <= t && (a = u.body, n = t)));\n          }), a;\n        }, t.isEndListAppended = function (e) {\n          var t = this.endListFragments[e];\n          return void 0 !== t && (t.buffered || Or(t));\n        }, t.getState = function (e) {\n          var t = Mr(e),\n            r = this.fragments[t];\n          return r ? r.buffered ? Or(r) ? Ir : Pr : Cr : wr;\n        }, t.isTimeBuffered = function (e, t, r) {\n          for (var i, a, n = 0; n < r.length; n++) {\n            if (i = r.start(n) - this.bufferPadding, a = r.end(n) + this.bufferPadding, e >= i && t <= a) return !0;\n            if (t <= i) return !1;\n          }\n          return !1;\n        }, t.onFragLoaded = function (e, t) {\n          var r = t.frag,\n            i = t.part;\n          if (\"initSegment\" !== r.sn && !r.bitrateTest) {\n            var a = i ? null : t,\n              n = Mr(r);\n            this.fragments[n] = {\n              body: r,\n              appendedPTS: null,\n              loaded: a,\n              buffered: !1,\n              range: Object.create(null)\n            };\n          }\n        }, t.onBufferAppended = function (e, t) {\n          var r = this,\n            i = t.frag,\n            a = t.part,\n            n = t.timeRanges;\n          if (\"initSegment\" !== i.sn) {\n            var s = i.type;\n            if (a) {\n              var o = this.activePartLists[s];\n              o || (this.activePartLists[s] = o = []), o.push(a);\n            }\n            this.timeRanges = n, Object.keys(n).forEach(function (e) {\n              var t = n[e];\n              r.detectEvictedFragments(e, t, s, a);\n            });\n          }\n        }, t.onFragBuffered = function (e, t) {\n          this.detectPartialFragments(t);\n        }, t.hasFragment = function (e) {\n          var t = Mr(e);\n          return !!this.fragments[t];\n        }, t.hasParts = function (e) {\n          var t;\n          return !(null == (t = this.activePartLists[e]) || !t.length);\n        }, t.removeFragmentsInRange = function (e, t, r, i, a) {\n          var n = this;\n          i && !this.hasGaps || Object.keys(this.fragments).forEach(function (s) {\n            var o = n.fragments[s];\n            if (o) {\n              var l = o.body;\n              l.type !== r || i && !l.gap || l.start < t && l.end > e && (o.buffered || a) && n.removeFragment(l);\n            }\n          });\n        }, t.removeFragment = function (e) {\n          var t = Mr(e);\n          e.stats.loaded = 0, e.clearElementaryStreamInfo();\n          var r = this.activePartLists[e.type];\n          if (r) {\n            var i = e.sn;\n            this.activePartLists[e.type] = r.filter(function (e) {\n              return e.fragment.sn !== i;\n            });\n          }\n          delete this.fragments[t], e.endList && delete this.endListFragments[e.type];\n        }, t.removeAllFragments = function () {\n          this.fragments = Object.create(null), this.endListFragments = Object.create(null), this.activePartLists = Object.create(null), this.hasGaps = !1;\n        }, e;\n      }();\n    function Or(e) {\n      var t, r, i;\n      return e.buffered && (e.body.gap || (null == (t = e.range.video) ? void 0 : t.partial) || (null == (r = e.range.audio) ? void 0 : r.partial) || (null == (i = e.range.audiovideo) ? void 0 : i.partial));\n    }\n    function Mr(e) {\n      return e.type + \"_\" + e.level + \"_\" + e.sn;\n    }\n    var Nr = Math.pow(2, 17),\n      Br = function () {\n        function e(e) {\n          this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e;\n        }\n        var t = e.prototype;\n        return t.destroy = function () {\n          this.loader && (this.loader.destroy(), this.loader = null);\n        }, t.abort = function () {\n          this.loader && this.loader.abort();\n        }, t.load = function (e, t) {\n          var r = this,\n            a = e.url;\n          if (!a) return Promise.reject(new Hr({\n            type: T.NETWORK_ERROR,\n            details: S.FRAG_LOAD_ERROR,\n            fatal: !1,\n            frag: e,\n            error: new Error(\"Fragment does not have a \" + (a ? \"part list\" : \"url\")),\n            networkDetails: null\n          }));\n          this.abort();\n          var n = this.config,\n            s = n.fLoader,\n            o = n.loader;\n          return new Promise(function (l, u) {\n            if (r.loader && r.loader.destroy(), e.gap) {\n              if (e.tagList.some(function (e) {\n                return \"GAP\" === e[0];\n              })) return void u(Gr(e));\n              e.gap = !1;\n            }\n            var d = r.loader = e.loader = s ? new s(n) : new o(n),\n              h = Ur(e),\n              f = Gt(n.fragLoadPolicy.default),\n              c = {\n                loadPolicy: f,\n                timeout: f.maxLoadTimeMs,\n                maxRetry: 0,\n                retryDelay: 0,\n                maxRetryDelay: 0,\n                highWaterMark: \"initSegment\" === e.sn ? 1 / 0 : Nr\n              };\n            e.stats = d.stats, d.load(h, c, {\n              onSuccess: function (t, i, a, n) {\n                r.resetLoader(e, d);\n                var s = t.data;\n                a.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(s.slice(0, 16)), s = s.slice(16)), l({\n                  frag: e,\n                  part: null,\n                  payload: s,\n                  networkDetails: n\n                });\n              },\n              onError: function (t, n, s, o) {\n                r.resetLoader(e, d), u(new Hr({\n                  type: T.NETWORK_ERROR,\n                  details: S.FRAG_LOAD_ERROR,\n                  fatal: !1,\n                  frag: e,\n                  response: i({\n                    url: a,\n                    data: void 0\n                  }, t),\n                  error: new Error(\"HTTP Error \" + t.code + \" \" + t.text),\n                  networkDetails: s,\n                  stats: o\n                }));\n              },\n              onAbort: function (t, i, a) {\n                r.resetLoader(e, d), u(new Hr({\n                  type: T.NETWORK_ERROR,\n                  details: S.INTERNAL_ABORTED,\n                  fatal: !1,\n                  frag: e,\n                  error: new Error(\"Aborted\"),\n                  networkDetails: a,\n                  stats: t\n                }));\n              },\n              onTimeout: function (t, i, a) {\n                r.resetLoader(e, d), u(new Hr({\n                  type: T.NETWORK_ERROR,\n                  details: S.FRAG_LOAD_TIMEOUT,\n                  fatal: !1,\n                  frag: e,\n                  error: new Error(\"Timeout after \" + c.timeout + \"ms\"),\n                  networkDetails: a,\n                  stats: t\n                }));\n              },\n              onProgress: function (r, i, a, n) {\n                t && t({\n                  frag: e,\n                  part: null,\n                  payload: a,\n                  networkDetails: n\n                });\n              }\n            });\n          });\n        }, t.loadPart = function (e, t, r) {\n          var a = this;\n          this.abort();\n          var n = this.config,\n            s = n.fLoader,\n            o = n.loader;\n          return new Promise(function (l, u) {\n            if (a.loader && a.loader.destroy(), e.gap || t.gap) u(Gr(e, t));else {\n              var d = a.loader = e.loader = s ? new s(n) : new o(n),\n                h = Ur(e, t),\n                f = Gt(n.fragLoadPolicy.default),\n                c = {\n                  loadPolicy: f,\n                  timeout: f.maxLoadTimeMs,\n                  maxRetry: 0,\n                  retryDelay: 0,\n                  maxRetryDelay: 0,\n                  highWaterMark: Nr\n                };\n              t.stats = d.stats, d.load(h, c, {\n                onSuccess: function (i, n, s, o) {\n                  a.resetLoader(e, d), a.updateStatsFromPart(e, t);\n                  var u = {\n                    frag: e,\n                    part: t,\n                    payload: i.data,\n                    networkDetails: o\n                  };\n                  r(u), l(u);\n                },\n                onError: function (r, n, s, o) {\n                  a.resetLoader(e, d), u(new Hr({\n                    type: T.NETWORK_ERROR,\n                    details: S.FRAG_LOAD_ERROR,\n                    fatal: !1,\n                    frag: e,\n                    part: t,\n                    response: i({\n                      url: h.url,\n                      data: void 0\n                    }, r),\n                    error: new Error(\"HTTP Error \" + r.code + \" \" + r.text),\n                    networkDetails: s,\n                    stats: o\n                  }));\n                },\n                onAbort: function (r, i, n) {\n                  e.stats.aborted = t.stats.aborted, a.resetLoader(e, d), u(new Hr({\n                    type: T.NETWORK_ERROR,\n                    details: S.INTERNAL_ABORTED,\n                    fatal: !1,\n                    frag: e,\n                    part: t,\n                    error: new Error(\"Aborted\"),\n                    networkDetails: n,\n                    stats: r\n                  }));\n                },\n                onTimeout: function (r, i, n) {\n                  a.resetLoader(e, d), u(new Hr({\n                    type: T.NETWORK_ERROR,\n                    details: S.FRAG_LOAD_TIMEOUT,\n                    fatal: !1,\n                    frag: e,\n                    part: t,\n                    error: new Error(\"Timeout after \" + c.timeout + \"ms\"),\n                    networkDetails: n,\n                    stats: r\n                  }));\n                }\n              });\n            }\n          });\n        }, t.updateStatsFromPart = function (e, t) {\n          var r = e.stats,\n            i = t.stats,\n            a = i.total;\n          if (r.loaded += i.loaded, a) {\n            var n = Math.round(e.duration / t.duration),\n              s = Math.min(Math.round(r.loaded / a), n),\n              o = (n - s) * Math.round(r.loaded / s);\n            r.total = r.loaded + o;\n          } else r.total = Math.max(r.loaded, r.total);\n          var l = r.loading,\n            u = i.loading;\n          l.start ? l.first += u.first - u.start : (l.start = u.start, l.first = u.first), l.end = u.end;\n        }, t.resetLoader = function (e, t) {\n          e.loader = null, this.loader === t && (self.clearTimeout(this.partLoadTimeout), this.loader = null), t.destroy();\n        }, e;\n      }();\n    function Ur(e, t) {\n      void 0 === t && (t = null);\n      var r = t || e,\n        i = {\n          frag: e,\n          part: t,\n          responseType: \"arraybuffer\",\n          url: r.url,\n          headers: {},\n          rangeStart: 0,\n          rangeEnd: 0\n        },\n        a = r.byteRangeStartOffset,\n        n = r.byteRangeEndOffset;\n      if (m(a) && m(n)) {\n        var s,\n          o = a,\n          l = n;\n        if (\"initSegment\" === e.sn && \"AES-128\" === (null == (s = e.decryptdata) ? void 0 : s.method)) {\n          var u = n - a;\n          u % 16 && (l = n + (16 - u % 16)), 0 !== a && (i.resetIV = !0, o = a - 16);\n        }\n        i.rangeStart = o, i.rangeEnd = l;\n      }\n      return i;\n    }\n    function Gr(e, t) {\n      var r = new Error(\"GAP \" + (e.gap ? \"tag\" : \"attribute\") + \" found\"),\n        i = {\n          type: T.MEDIA_ERROR,\n          details: S.FRAG_GAP,\n          fatal: !1,\n          frag: e,\n          error: r,\n          networkDetails: null\n        };\n      return t && (i.part = t), (t || e).stats.aborted = !0, new Hr(i);\n    }\n    var Hr = function (e) {\n        function t(t) {\n          var r;\n          return (r = e.call(this, t.error.message) || this).data = void 0, r.data = t, r;\n        }\n        return l(t, e), t;\n      }(f(Error)),\n      Vr = function () {\n        function e(e) {\n          this.config = void 0, this.keyUriToKeyInfo = {}, this.emeController = null, this.config = e;\n        }\n        var t = e.prototype;\n        return t.abort = function (e) {\n          for (var t in this.keyUriToKeyInfo) {\n            var r = this.keyUriToKeyInfo[t].loader;\n            if (r) {\n              var i;\n              if (e && e !== (null == (i = r.context) ? void 0 : i.frag.type)) return;\n              r.abort();\n            }\n          }\n        }, t.detach = function () {\n          for (var e in this.keyUriToKeyInfo) {\n            var t = this.keyUriToKeyInfo[e];\n            (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) && delete this.keyUriToKeyInfo[e];\n          }\n        }, t.destroy = function () {\n          for (var e in this.detach(), this.keyUriToKeyInfo) {\n            var t = this.keyUriToKeyInfo[e].loader;\n            t && t.destroy();\n          }\n          this.keyUriToKeyInfo = {};\n        }, t.createKeyLoadError = function (e, t, r, i, a) {\n          return void 0 === t && (t = S.KEY_LOAD_ERROR), new Hr({\n            type: T.NETWORK_ERROR,\n            details: t,\n            fatal: !1,\n            frag: e,\n            response: a,\n            error: r,\n            networkDetails: i\n          });\n        }, t.loadClear = function (e, t) {\n          var r = this;\n          if (this.emeController && this.config.emeEnabled) for (var i = e.sn, a = e.cc, n = function () {\n              var e = t[s];\n              if (a <= e.cc && (\"initSegment\" === i || \"initSegment\" === e.sn || i < e.sn)) return r.emeController.selectKeySystemFormat(e).then(function (t) {\n                e.setKeyFormat(t);\n              }), 1;\n            }, s = 0; s < t.length && !n(); s++);\n        }, t.load = function (e) {\n          var t = this;\n          return !e.decryptdata && e.encrypted && this.emeController ? this.emeController.selectKeySystemFormat(e).then(function (r) {\n            return t.loadInternal(e, r);\n          }) : this.loadInternal(e);\n        }, t.loadInternal = function (e, t) {\n          var r, i;\n          t && e.setKeyFormat(t);\n          var a = e.decryptdata;\n          if (!a) {\n            var n = new Error(t ? \"Expected frag.decryptdata to be defined after setting format \" + t : \"Missing decryption data on fragment in onKeyLoading\");\n            return Promise.reject(this.createKeyLoadError(e, S.KEY_LOAD_ERROR, n));\n          }\n          var s = a.uri;\n          if (!s) return Promise.reject(this.createKeyLoadError(e, S.KEY_LOAD_ERROR, new Error('Invalid key URI: \"' + s + '\"')));\n          var o,\n            l = this.keyUriToKeyInfo[s];\n          if (null != (r = l) && r.decryptdata.key) return a.key = l.decryptdata.key, Promise.resolve({\n            frag: e,\n            keyInfo: l\n          });\n          if (null != (i = l) && i.keyLoadPromise) switch (null == (o = l.mediaKeySessionContext) ? void 0 : o.keyStatus) {\n            case void 0:\n            case \"status-pending\":\n            case \"usable\":\n            case \"usable-in-future\":\n              return l.keyLoadPromise.then(function (t) {\n                return a.key = t.keyInfo.decryptdata.key, {\n                  frag: e,\n                  keyInfo: l\n                };\n              });\n          }\n          switch (l = this.keyUriToKeyInfo[s] = {\n            decryptdata: a,\n            keyLoadPromise: null,\n            loader: null,\n            mediaKeySessionContext: null\n          }, a.method) {\n            case \"ISO-23001-7\":\n            case \"SAMPLE-AES\":\n            case \"SAMPLE-AES-CENC\":\n            case \"SAMPLE-AES-CTR\":\n              return \"identity\" === a.keyFormat ? this.loadKeyHTTP(l, e) : this.loadKeyEME(l, e);\n            case \"AES-128\":\n              return this.loadKeyHTTP(l, e);\n            default:\n              return Promise.reject(this.createKeyLoadError(e, S.KEY_LOAD_ERROR, new Error('Key supplied with unsupported METHOD: \"' + a.method + '\"')));\n          }\n        }, t.loadKeyEME = function (e, t) {\n          var r = {\n            frag: t,\n            keyInfo: e\n          };\n          if (this.emeController && this.config.emeEnabled) {\n            var i = this.emeController.loadKey(r);\n            if (i) return (e.keyLoadPromise = i.then(function (t) {\n              return e.mediaKeySessionContext = t, r;\n            })).catch(function (t) {\n              throw e.keyLoadPromise = null, t;\n            });\n          }\n          return Promise.resolve(r);\n        }, t.loadKeyHTTP = function (e, t) {\n          var r = this,\n            a = this.config,\n            n = new (0, a.loader)(a);\n          return t.keyLoader = e.loader = n, e.keyLoadPromise = new Promise(function (s, o) {\n            var l = {\n                keyInfo: e,\n                frag: t,\n                responseType: \"arraybuffer\",\n                url: e.decryptdata.uri\n              },\n              u = a.keyLoadPolicy.default,\n              d = {\n                loadPolicy: u,\n                timeout: u.maxLoadTimeMs,\n                maxRetry: 0,\n                retryDelay: 0,\n                maxRetryDelay: 0\n              },\n              h = {\n                onSuccess: function (e, t, i, a) {\n                  var n = i.frag,\n                    l = i.keyInfo,\n                    u = i.url;\n                  if (!n.decryptdata || l !== r.keyUriToKeyInfo[u]) return o(r.createKeyLoadError(n, S.KEY_LOAD_ERROR, new Error(\"after key load, decryptdata unset or changed\"), a));\n                  l.decryptdata.key = n.decryptdata.key = new Uint8Array(e.data), n.keyLoader = null, l.loader = null, s({\n                    frag: n,\n                    keyInfo: l\n                  });\n                },\n                onError: function (e, a, n, s) {\n                  r.resetLoader(a), o(r.createKeyLoadError(t, S.KEY_LOAD_ERROR, new Error(\"HTTP Error \" + e.code + \" loading key \" + e.text), n, i({\n                    url: l.url,\n                    data: void 0\n                  }, e)));\n                },\n                onTimeout: function (e, i, a) {\n                  r.resetLoader(i), o(r.createKeyLoadError(t, S.KEY_LOAD_TIMEOUT, new Error(\"key loading timed out\"), a));\n                },\n                onAbort: function (e, i, a) {\n                  r.resetLoader(i), o(r.createKeyLoadError(t, S.INTERNAL_ABORTED, new Error(\"key loading aborted\"), a));\n                }\n              };\n            n.load(l, d, h);\n          });\n        }, t.resetLoader = function (e) {\n          var t = e.frag,\n            r = e.keyInfo,\n            i = e.url,\n            a = r.loader;\n          t.keyLoader === a && (t.keyLoader = null, r.loader = null), delete this.keyUriToKeyInfo[i], a && a.destroy();\n        }, e;\n      }(),\n      Kr = function () {\n        function e() {\n          this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this);\n        }\n        var t = e.prototype;\n        return t.destroy = function () {\n          this.onHandlerDestroying(), this.onHandlerDestroyed();\n        }, t.onHandlerDestroying = function () {\n          this.clearNextTick(), this.clearInterval();\n        }, t.onHandlerDestroyed = function () {}, t.hasInterval = function () {\n          return !!this._tickInterval;\n        }, t.hasNextTick = function () {\n          return !!this._tickTimer;\n        }, t.setInterval = function (e) {\n          return !this._tickInterval && (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, e), !0);\n        }, t.clearInterval = function () {\n          return !!this._tickInterval && (self.clearInterval(this._tickInterval), this._tickInterval = null, !0);\n        }, t.clearNextTick = function () {\n          return !!this._tickTimer && (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0);\n        }, t.tick = function () {\n          this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0);\n        }, t.tickImmediate = function () {\n          this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0);\n        }, t.doTick = function () {}, e;\n      }(),\n      jr = function (e, t, r, i, a, n) {\n        void 0 === i && (i = 0), void 0 === a && (a = -1), void 0 === n && (n = !1), this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = {\n          start: 0,\n          executeStart: 0,\n          executeEnd: 0,\n          end: 0\n        }, this.buffering = {\n          audio: {\n            start: 0,\n            executeStart: 0,\n            executeEnd: 0,\n            end: 0\n          },\n          video: {\n            start: 0,\n            executeStart: 0,\n            executeEnd: 0,\n            end: 0\n          },\n          audiovideo: {\n            start: 0,\n            executeStart: 0,\n            executeEnd: 0,\n            end: 0\n          }\n        }, this.level = e, this.sn = t, this.id = r, this.size = i, this.part = a, this.partial = n;\n      };\n    function Wr(e, t) {\n      for (var r = 0, i = e.length; r < i; r++) {\n        var a;\n        if ((null == (a = e[r]) ? void 0 : a.cc) === t) return e[r];\n      }\n      return null;\n    }\n    function Yr(e, t) {\n      if (e) {\n        var r = e.start + t;\n        e.start = e.startPTS = r, e.endPTS = r + e.duration;\n      }\n    }\n    function qr(e, t) {\n      for (var r = t.fragments, i = 0, a = r.length; i < a; i++) Yr(r[i], e);\n      t.fragmentHint && Yr(t.fragmentHint, e), t.alignedSliding = !0;\n    }\n    function zr(e, t, r) {\n      t && (function (e, t, r) {\n        if (function (e, t, r) {\n          return !(!t || !(r.endCC > r.startCC || e && e.cc < r.startCC));\n        }(e, r, t)) {\n          var i = function (e, t) {\n            var r = e.fragments,\n              i = t.fragments;\n            if (i.length && r.length) {\n              var a = Wr(r, i[0].cc);\n              if (a && (!a || a.startPTS)) return a;\n              k.log(\"No frag in previous level to align on\");\n            } else k.log(\"No fragments to align\");\n          }(r, t);\n          i && m(i.start) && (k.log(\"Adjusting PTS using last level due to CC increase within current level \" + t.url), qr(i.start, t));\n        }\n      }(e, r, t), !r.alignedSliding && t && function (e, t) {\n        if (e.hasProgramDateTime && t.hasProgramDateTime) {\n          var r,\n            i,\n            a = e.fragments,\n            n = t.fragments;\n          if (a.length && n.length) {\n            var s = Math.min(t.endCC, e.endCC);\n            t.startCC < s && e.startCC < s && (r = Wr(n, s), i = Wr(a, s)), r && i || (i = Wr(a, (r = n[Math.floor(n.length / 2)]).cc) || a[Math.floor(a.length / 2)]);\n            var o = r.programDateTime,\n              l = i.programDateTime;\n            o && l && qr((l - o) / 1e3 - (i.start - r.start), e);\n          }\n        }\n      }(r, t), r.alignedSliding || !t || r.skippedSegments || Pt(t, r));\n    }\n    var Xr = function () {\n        function e(e, t) {\n          this.subtle = void 0, this.aesIV = void 0, this.subtle = e, this.aesIV = t;\n        }\n        return e.prototype.decrypt = function (e, t) {\n          return this.subtle.decrypt({\n            name: \"AES-CBC\",\n            iv: this.aesIV\n          }, t, e);\n        }, e;\n      }(),\n      Qr = function () {\n        function e(e, t) {\n          this.subtle = void 0, this.key = void 0, this.subtle = e, this.key = t;\n        }\n        return e.prototype.expandKey = function () {\n          return this.subtle.importKey(\"raw\", this.key, {\n            name: \"AES-CBC\"\n          }, !1, [\"encrypt\", \"decrypt\"]);\n        }, e;\n      }(),\n      Jr = function () {\n        function e() {\n          this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable();\n        }\n        var t = e.prototype;\n        return t.uint8ArrayToUint32Array_ = function (e) {\n          for (var t = new DataView(e), r = new Uint32Array(4), i = 0; i < 4; i++) r[i] = t.getUint32(4 * i);\n          return r;\n        }, t.initTable = function () {\n          var e = this.sBox,\n            t = this.invSBox,\n            r = this.subMix,\n            i = r[0],\n            a = r[1],\n            n = r[2],\n            s = r[3],\n            o = this.invSubMix,\n            l = o[0],\n            u = o[1],\n            d = o[2],\n            h = o[3],\n            f = new Uint32Array(256),\n            c = 0,\n            v = 0,\n            g = 0;\n          for (g = 0; g < 256; g++) f[g] = g < 128 ? g << 1 : g << 1 ^ 283;\n          for (g = 0; g < 256; g++) {\n            var m = v ^ v << 1 ^ v << 2 ^ v << 3 ^ v << 4;\n            m = m >>> 8 ^ 255 & m ^ 99, e[c] = m, t[m] = c;\n            var p = f[c],\n              y = f[p],\n              E = f[y],\n              T = 257 * f[m] ^ 16843008 * m;\n            i[c] = T << 24 | T >>> 8, a[c] = T << 16 | T >>> 16, n[c] = T << 8 | T >>> 24, s[c] = T, T = 16843009 * E ^ 65537 * y ^ 257 * p ^ 16843008 * c, l[m] = T << 24 | T >>> 8, u[m] = T << 16 | T >>> 16, d[m] = T << 8 | T >>> 24, h[m] = T, c ? (c = p ^ f[f[f[E ^ p]]], v ^= f[f[v]]) : c = v = 1;\n          }\n        }, t.expandKey = function (e) {\n          for (var t = this.uint8ArrayToUint32Array_(e), r = !0, i = 0; i < t.length && r;) r = t[i] === this.key[i], i++;\n          if (!r) {\n            this.key = t;\n            var a = this.keySize = t.length;\n            if (4 !== a && 6 !== a && 8 !== a) throw new Error(\"Invalid aes key size=\" + a);\n            var n,\n              s,\n              o,\n              l,\n              u = this.ksRows = 4 * (a + 6 + 1),\n              d = this.keySchedule = new Uint32Array(u),\n              h = this.invKeySchedule = new Uint32Array(u),\n              f = this.sBox,\n              c = this.rcon,\n              v = this.invSubMix,\n              g = v[0],\n              m = v[1],\n              p = v[2],\n              y = v[3];\n            for (n = 0; n < u; n++) n < a ? o = d[n] = t[n] : (l = o, n % a == 0 ? (l = f[(l = l << 8 | l >>> 24) >>> 24] << 24 | f[l >>> 16 & 255] << 16 | f[l >>> 8 & 255] << 8 | f[255 & l], l ^= c[n / a | 0] << 24) : a > 6 && n % a == 4 && (l = f[l >>> 24] << 24 | f[l >>> 16 & 255] << 16 | f[l >>> 8 & 255] << 8 | f[255 & l]), d[n] = o = (d[n - a] ^ l) >>> 0);\n            for (s = 0; s < u; s++) n = u - s, l = 3 & s ? d[n] : d[n - 4], h[s] = s < 4 || n <= 4 ? l : g[f[l >>> 24]] ^ m[f[l >>> 16 & 255]] ^ p[f[l >>> 8 & 255]] ^ y[f[255 & l]], h[s] = h[s] >>> 0;\n          }\n        }, t.networkToHostOrderSwap = function (e) {\n          return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24;\n        }, t.decrypt = function (e, t, r) {\n          for (var i, a, n, s, o, l, u, d, h, f, c, v, g, m, p = this.keySize + 6, y = this.invKeySchedule, E = this.invSBox, T = this.invSubMix, S = T[0], L = T[1], R = T[2], A = T[3], b = this.uint8ArrayToUint32Array_(r), D = b[0], k = b[1], _ = b[2], x = b[3], w = new Int32Array(e), C = new Int32Array(w.length), I = this.networkToHostOrderSwap; t < w.length;) {\n            for (h = I(w[t]), f = I(w[t + 1]), c = I(w[t + 2]), v = I(w[t + 3]), o = h ^ y[0], l = v ^ y[1], u = c ^ y[2], d = f ^ y[3], g = 4, m = 1; m < p; m++) i = S[o >>> 24] ^ L[l >> 16 & 255] ^ R[u >> 8 & 255] ^ A[255 & d] ^ y[g], a = S[l >>> 24] ^ L[u >> 16 & 255] ^ R[d >> 8 & 255] ^ A[255 & o] ^ y[g + 1], n = S[u >>> 24] ^ L[d >> 16 & 255] ^ R[o >> 8 & 255] ^ A[255 & l] ^ y[g + 2], s = S[d >>> 24] ^ L[o >> 16 & 255] ^ R[l >> 8 & 255] ^ A[255 & u] ^ y[g + 3], o = i, l = a, u = n, d = s, g += 4;\n            i = E[o >>> 24] << 24 ^ E[l >> 16 & 255] << 16 ^ E[u >> 8 & 255] << 8 ^ E[255 & d] ^ y[g], a = E[l >>> 24] << 24 ^ E[u >> 16 & 255] << 16 ^ E[d >> 8 & 255] << 8 ^ E[255 & o] ^ y[g + 1], n = E[u >>> 24] << 24 ^ E[d >> 16 & 255] << 16 ^ E[o >> 8 & 255] << 8 ^ E[255 & l] ^ y[g + 2], s = E[d >>> 24] << 24 ^ E[o >> 16 & 255] << 16 ^ E[l >> 8 & 255] << 8 ^ E[255 & u] ^ y[g + 3], C[t] = I(i ^ D), C[t + 1] = I(s ^ k), C[t + 2] = I(n ^ _), C[t + 3] = I(a ^ x), D = h, k = f, _ = c, x = v, t += 4;\n          }\n          return C.buffer;\n        }, e;\n      }(),\n      $r = function () {\n        function e(e, t) {\n          var r = (void 0 === t ? {} : t).removePKCS7Padding,\n            i = void 0 === r || r;\n          if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.useSoftware = e.enableSoftwareAES, this.removePKCS7Padding = i, i) try {\n            var a = self.crypto;\n            a && (this.subtle = a.subtle || a.webkitSubtle);\n          } catch (e) {}\n          null === this.subtle && (this.useSoftware = !0);\n        }\n        var t = e.prototype;\n        return t.destroy = function () {\n          this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null;\n        }, t.isSync = function () {\n          return this.useSoftware;\n        }, t.flush = function () {\n          var e = this.currentResult,\n            t = this.remainderData;\n          if (!e || t) return this.reset(), null;\n          var r,\n            i,\n            a,\n            n = new Uint8Array(e);\n          return this.reset(), this.removePKCS7Padding ? (i = (r = n).byteLength, (a = i && new DataView(r.buffer).getUint8(i - 1)) ? V(r, 0, i - a) : r) : n;\n        }, t.reset = function () {\n          this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null);\n        }, t.decrypt = function (e, t, r) {\n          var i = this;\n          return this.useSoftware ? new Promise(function (a, n) {\n            i.softwareDecrypt(new Uint8Array(e), t, r);\n            var s = i.flush();\n            s ? a(s.buffer) : n(new Error(\"[softwareDecrypt] Failed to decrypt data\"));\n          }) : this.webCryptoDecrypt(new Uint8Array(e), t, r);\n        }, t.softwareDecrypt = function (e, t, r) {\n          var i = this.currentIV,\n            a = this.currentResult,\n            n = this.remainderData;\n          this.logOnce(\"JS AES decrypt\"), n && (e = be(n, e), this.remainderData = null);\n          var s = this.getValidChunk(e);\n          if (!s.length) return null;\n          i && (r = i);\n          var o = this.softwareDecrypter;\n          o || (o = this.softwareDecrypter = new Jr()), o.expandKey(t);\n          var l = a;\n          return this.currentResult = o.decrypt(s.buffer, 0, r), this.currentIV = V(s, -16).buffer, l || null;\n        }, t.webCryptoDecrypt = function (e, t, r) {\n          var i = this,\n            a = this.subtle;\n          return this.key === t && this.fastAesKey || (this.key = t, this.fastAesKey = new Qr(a, t)), this.fastAesKey.expandKey().then(function (t) {\n            return a ? (i.logOnce(\"WebCrypto AES decrypt\"), new Xr(a, new Uint8Array(r)).decrypt(e.buffer, t)) : Promise.reject(new Error(\"web crypto not initialized\"));\n          }).catch(function (a) {\n            return k.warn(\"[decrypter]: WebCrypto Error, disable WebCrypto API, \" + a.name + \": \" + a.message), i.onWebCryptoError(e, t, r);\n          });\n        }, t.onWebCryptoError = function (e, t, r) {\n          this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, t, r);\n          var i = this.flush();\n          if (i) return i.buffer;\n          throw new Error(\"WebCrypto and softwareDecrypt: failed to decrypt data\");\n        }, t.getValidChunk = function (e) {\n          var t = e,\n            r = e.length - e.length % 16;\n          return r !== e.length && (t = V(e, 0, r), this.remainderData = V(e, r)), t;\n        }, t.logOnce = function (e) {\n          this.logEnabled && (k.log(\"[decrypter]: \" + e), this.logEnabled = !1);\n        }, e;\n      }(),\n      Zr = function (e) {\n        for (var t = \"\", r = e.length, i = 0; i < r; i++) t += \"[\" + e.start(i).toFixed(3) + \"-\" + e.end(i).toFixed(3) + \"]\";\n        return t;\n      },\n      ei = \"STOPPED\",\n      ti = \"IDLE\",\n      ri = \"KEY_LOADING\",\n      ii = \"FRAG_LOADING\",\n      ai = \"FRAG_LOADING_WAITING_RETRY\",\n      ni = \"PARSING\",\n      si = \"PARSED\",\n      oi = \"ENDED\",\n      li = \"ERROR\",\n      ui = \"WAITING_LEVEL\",\n      di = function (e) {\n        function t(t, r, i, a, n) {\n          var s;\n          return (s = e.call(this) || this).hls = void 0, s.fragPrevious = null, s.fragCurrent = null, s.fragmentTracker = void 0, s.transmuxer = null, s._state = ei, s.playlistType = void 0, s.media = null, s.mediaBuffer = null, s.config = void 0, s.bitrateTest = !1, s.lastCurrentTime = 0, s.nextLoadPosition = 0, s.startPosition = 0, s.startTimeOffset = null, s.loadedmetadata = !1, s.retryDate = 0, s.levels = null, s.fragmentLoader = void 0, s.keyLoader = void 0, s.levelLastLoaded = null, s.startFragRequested = !1, s.decrypter = void 0, s.initPTS = [], s.onvseeking = null, s.onvended = null, s.logPrefix = \"\", s.log = void 0, s.warn = void 0, s.playlistType = n, s.logPrefix = a, s.log = k.log.bind(k, a + \":\"), s.warn = k.warn.bind(k, a + \":\"), s.hls = t, s.fragmentLoader = new Br(t.config), s.keyLoader = i, s.fragmentTracker = r, s.config = t.config, s.decrypter = new $r(t.config), t.on(E.MANIFEST_LOADED, s.onManifestLoaded, function (e) {\n            if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return e;\n          }(s)), s;\n        }\n        l(t, e);\n        var r = t.prototype;\n        return r.doTick = function () {\n          this.onTickEnd();\n        }, r.onTickEnd = function () {}, r.startLoad = function (e) {}, r.stopLoad = function () {\n          this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType);\n          var e = this.fragCurrent;\n          null != e && e.loader && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = ei;\n        }, r._streamEnded = function (e, t) {\n          if (t.live || e.nextStart || !e.end || !this.media) return !1;\n          var r = t.partList;\n          if (null != r && r.length) {\n            var i = r[r.length - 1];\n            return or.isBuffered(this.media, i.start + i.duration / 2);\n          }\n          var a = t.fragments[t.fragments.length - 1].type;\n          return this.fragmentTracker.isEndListAppended(a);\n        }, r.getLevelDetails = function () {\n          var e;\n          if (this.levels && null !== this.levelLastLoaded) return null == (e = this.levelLastLoaded) ? void 0 : e.details;\n        }, r.onMediaAttached = function (e, t) {\n          var r = this.media = this.mediaBuffer = t.media;\n          this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), r.addEventListener(\"seeking\", this.onvseeking), r.addEventListener(\"ended\", this.onvended);\n          var i = this.config;\n          this.levels && i.autoStartLoad && this.state === ei && this.startLoad(i.startPosition);\n        }, r.onMediaDetaching = function () {\n          var e = this.media;\n          null != e && e.ended && (this.log(\"MSE detaching and video ended, reset startPosition\"), this.startPosition = this.lastCurrentTime = 0), e && this.onvseeking && this.onvended && (e.removeEventListener(\"seeking\", this.onvseeking), e.removeEventListener(\"ended\", this.onvended), this.onvseeking = this.onvended = null), this.keyLoader && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad();\n        }, r.onMediaSeeking = function () {\n          var e = this.config,\n            t = this.fragCurrent,\n            r = this.media,\n            i = this.mediaBuffer,\n            a = this.state,\n            n = r ? r.currentTime : 0,\n            s = or.bufferInfo(i || r, n, e.maxBufferHole);\n          if (this.log(\"media seeking to \" + (m(n) ? n.toFixed(3) : n) + \", state: \" + a), this.state === oi) this.resetLoadingState();else if (t) {\n            var o = e.maxFragLookUpTolerance,\n              l = t.start - o,\n              u = t.start + t.duration + o;\n            if (!s.len || u < s.start || l > s.end) {\n              var d = n > u;\n              (n < l || d) && (d && t.loader && (this.log(\"seeking outside of buffer while fragment load in progress, cancel fragment load\"), t.abortRequests(), this.resetLoadingState()), this.fragPrevious = null);\n            }\n          }\n          r && (this.fragmentTracker.removeFragmentsInRange(n, 1 / 0, this.playlistType, !0), this.lastCurrentTime = n), this.loadedmetadata || s.len || (this.nextLoadPosition = this.startPosition = n), this.tickImmediate();\n        }, r.onMediaEnded = function () {\n          this.startPosition = this.lastCurrentTime = 0;\n        }, r.onManifestLoaded = function (e, t) {\n          this.startTimeOffset = t.startTimeOffset, this.initPTS = [];\n        }, r.onHandlerDestroying = function () {\n          this.hls.off(E.MANIFEST_LOADED, this.onManifestLoaded, this), this.stopLoad(), e.prototype.onHandlerDestroying.call(this), this.hls = null;\n        }, r.onHandlerDestroyed = function () {\n          this.state = ei, this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, e.prototype.onHandlerDestroyed.call(this);\n        }, r.loadFragment = function (e, t, r) {\n          this._loadFragForPlayback(e, t, r);\n        }, r._loadFragForPlayback = function (e, t, r) {\n          var i = this;\n          this._doFragLoad(e, t, r, function (t) {\n            if (i.fragContextChanged(e)) return i.warn(\"Fragment \" + e.sn + (t.part ? \" p: \" + t.part.index : \"\") + \" of level \" + e.level + \" was dropped during download.\"), void i.fragmentTracker.removeFragment(e);\n            e.stats.chunkCount++, i._handleFragmentLoadProgress(t);\n          }).then(function (t) {\n            if (t) {\n              var r = i.state;\n              i.fragContextChanged(e) ? (r === ii || !i.fragCurrent && r === ni) && (i.fragmentTracker.removeFragment(e), i.state = ti) : (\"payload\" in t && (i.log(\"Loaded fragment \" + e.sn + \" of level \" + e.level), i.hls.trigger(E.FRAG_LOADED, t)), i._handleFragmentLoadComplete(t));\n            }\n          }).catch(function (t) {\n            i.state !== ei && i.state !== li && (i.warn(t), i.resetFragmentLoading(e));\n          });\n        }, r.clearTrackerIfNeeded = function (e) {\n          var t,\n            r = this.fragmentTracker;\n          if (r.getState(e) === Cr) {\n            var i = e.type,\n              a = this.getFwdBufferInfo(this.mediaBuffer, i),\n              n = Math.max(e.duration, a ? a.len : this.config.maxBufferLength);\n            this.reduceMaxBufferLength(n) && r.removeFragment(e);\n          } else 0 === (null == (t = this.mediaBuffer) ? void 0 : t.buffered.length) ? r.removeAllFragments() : r.hasParts(e.type) && (r.detectPartialFragments({\n            frag: e,\n            part: null,\n            stats: e.stats,\n            id: e.type\n          }), r.getState(e) === Ir && r.removeFragment(e));\n        }, r.checkLiveUpdate = function (e) {\n          if (e.updated && !e.live) {\n            var t = e.fragments[e.fragments.length - 1];\n            this.fragmentTracker.detectPartialFragments({\n              frag: t,\n              part: null,\n              stats: t.stats,\n              id: t.type\n            });\n          }\n          e.fragments[0] || (e.deltaUpdateFailed = !0);\n        }, r.flushMainBuffer = function (e, t, r) {\n          if (void 0 === r && (r = null), e - t) {\n            var i = {\n              startOffset: e,\n              endOffset: t,\n              type: r\n            };\n            this.hls.trigger(E.BUFFER_FLUSHING, i);\n          }\n        }, r._loadInitSegment = function (e, t) {\n          var r = this;\n          this._doFragLoad(e, t).then(function (t) {\n            if (!t || r.fragContextChanged(e) || !r.levels) throw new Error(\"init load aborted\");\n            return t;\n          }).then(function (t) {\n            var i = r.hls,\n              a = t.payload,\n              n = e.decryptdata;\n            if (a && a.byteLength > 0 && null != n && n.key && n.iv && \"AES-128\" === n.method) {\n              var s = self.performance.now();\n              return r.decrypter.decrypt(new Uint8Array(a), n.key.buffer, n.iv.buffer).catch(function (t) {\n                throw i.trigger(E.ERROR, {\n                  type: T.MEDIA_ERROR,\n                  details: S.FRAG_DECRYPT_ERROR,\n                  fatal: !1,\n                  error: t,\n                  reason: t.message,\n                  frag: e\n                }), t;\n              }).then(function (a) {\n                var n = self.performance.now();\n                return i.trigger(E.FRAG_DECRYPTED, {\n                  frag: e,\n                  payload: a,\n                  stats: {\n                    tstart: s,\n                    tdecrypt: n\n                  }\n                }), t.payload = a, r.completeInitSegmentLoad(t);\n              });\n            }\n            return r.completeInitSegmentLoad(t);\n          }).catch(function (t) {\n            r.state !== ei && r.state !== li && (r.warn(t), r.resetFragmentLoading(e));\n          });\n        }, r.completeInitSegmentLoad = function (e) {\n          if (!this.levels) throw new Error(\"init load aborted, missing levels\");\n          var t = e.frag.stats;\n          this.state = ti, e.frag.data = new Uint8Array(e.payload), t.parsing.start = t.buffering.start = self.performance.now(), t.parsing.end = t.buffering.end = self.performance.now(), this.tick();\n        }, r.fragContextChanged = function (e) {\n          var t = this.fragCurrent;\n          return !e || !t || e.sn !== t.sn || e.level !== t.level;\n        }, r.fragBufferedComplete = function (e, t) {\n          var r,\n            i,\n            a,\n            n,\n            s = this.mediaBuffer ? this.mediaBuffer : this.media;\n          if (this.log(\"Buffered \" + e.type + \" sn: \" + e.sn + (t ? \" part: \" + t.index : \"\") + \" of \" + (this.playlistType === nt ? \"level\" : \"track\") + \" \" + e.level + \" (frag:[\" + (null != (r = e.startPTS) ? r : NaN).toFixed(3) + \"-\" + (null != (i = e.endPTS) ? i : NaN).toFixed(3) + \"] > buffer:\" + (s ? Zr(or.getBuffered(s)) : \"(detached)\") + \")\"), \"initSegment\" !== e.sn) {\n            var o;\n            if (e.type !== ot) {\n              var l = e.elementaryStreams;\n              if (!Object.keys(l).some(function (e) {\n                return !!l[e];\n              })) return void (this.state = ti);\n            }\n            var u = null == (o = this.levels) ? void 0 : o[e.level];\n            null != u && u.fragmentError && (this.log(\"Resetting level fragment error count of \" + u.fragmentError + \" on frag buffered\"), u.fragmentError = 0);\n          }\n          this.state = ti, s && (!this.loadedmetadata && e.type == nt && s.buffered.length && (null == (a = this.fragCurrent) ? void 0 : a.sn) === (null == (n = this.fragPrevious) ? void 0 : n.sn) && (this.loadedmetadata = !0, this.seekToStartPos()), this.tick());\n        }, r.seekToStartPos = function () {}, r._handleFragmentLoadComplete = function (e) {\n          var t = this.transmuxer;\n          if (t) {\n            var r = e.frag,\n              i = e.part,\n              a = e.partsLoaded,\n              n = !a || 0 === a.length || a.some(function (e) {\n                return !e;\n              }),\n              s = new jr(r.level, r.sn, r.stats.chunkCount + 1, 0, i ? i.index : -1, !n);\n            t.flush(s);\n          }\n        }, r._handleFragmentLoadProgress = function (e) {}, r._doFragLoad = function (e, t, r, i) {\n          var a,\n            n = this;\n          void 0 === r && (r = null);\n          var s = null == t ? void 0 : t.details;\n          if (!this.levels || !s) throw new Error(\"frag load aborted, missing level\" + (s ? \"\" : \" detail\") + \"s\");\n          var o = null;\n          if (!e.encrypted || null != (a = e.decryptdata) && a.key ? !e.encrypted && s.encryptedFragments.length && this.keyLoader.loadClear(e, s.encryptedFragments) : (this.log(\"Loading key for \" + e.sn + \" of [\" + s.startSN + \"-\" + s.endSN + \"], \" + (\"[stream-controller]\" === this.logPrefix ? \"level\" : \"track\") + \" \" + e.level), this.state = ri, this.fragCurrent = e, o = this.keyLoader.load(e).then(function (e) {\n            if (!n.fragContextChanged(e.frag)) return n.hls.trigger(E.KEY_LOADED, e), n.state === ri && (n.state = ti), e;\n          }), this.hls.trigger(E.KEY_LOADING, {\n            frag: e\n          }), null === this.fragCurrent && (o = Promise.reject(new Error(\"frag load aborted, context changed in KEY_LOADING\")))), r = Math.max(e.start, r || 0), this.config.lowLatencyMode && \"initSegment\" !== e.sn) {\n            var l = s.partList;\n            if (l && i) {\n              r > e.end && s.fragmentHint && (e = s.fragmentHint);\n              var u = this.getNextPart(l, e, r);\n              if (u > -1) {\n                var d,\n                  h = l[u];\n                return this.log(\"Loading part sn: \" + e.sn + \" p: \" + h.index + \" cc: \" + e.cc + \" of playlist [\" + s.startSN + \"-\" + s.endSN + \"] parts [0-\" + u + \"-\" + (l.length - 1) + \"] \" + (\"[stream-controller]\" === this.logPrefix ? \"level\" : \"track\") + \": \" + e.level + \", target: \" + parseFloat(r.toFixed(3))), this.nextLoadPosition = h.start + h.duration, this.state = ii, d = o ? o.then(function (r) {\n                  return !r || n.fragContextChanged(r.frag) ? null : n.doFragPartsLoad(e, h, t, i);\n                }).catch(function (e) {\n                  return n.handleFragLoadError(e);\n                }) : this.doFragPartsLoad(e, h, t, i).catch(function (e) {\n                  return n.handleFragLoadError(e);\n                }), this.hls.trigger(E.FRAG_LOADING, {\n                  frag: e,\n                  part: h,\n                  targetBufferTime: r\n                }), null === this.fragCurrent ? Promise.reject(new Error(\"frag load aborted, context changed in FRAG_LOADING parts\")) : d;\n              }\n              if (!e.url || this.loadedEndOfParts(l, r)) return Promise.resolve(null);\n            }\n          }\n          this.log(\"Loading fragment \" + e.sn + \" cc: \" + e.cc + \" \" + (s ? \"of [\" + s.startSN + \"-\" + s.endSN + \"] \" : \"\") + (\"[stream-controller]\" === this.logPrefix ? \"level\" : \"track\") + \": \" + e.level + \", target: \" + parseFloat(r.toFixed(3))), m(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration), this.state = ii;\n          var f,\n            c = this.config.progressive;\n          return f = c && o ? o.then(function (t) {\n            return !t || n.fragContextChanged(null == t ? void 0 : t.frag) ? null : n.fragmentLoader.load(e, i);\n          }).catch(function (e) {\n            return n.handleFragLoadError(e);\n          }) : Promise.all([this.fragmentLoader.load(e, c ? i : void 0), o]).then(function (e) {\n            var t = e[0];\n            return !c && t && i && i(t), t;\n          }).catch(function (e) {\n            return n.handleFragLoadError(e);\n          }), this.hls.trigger(E.FRAG_LOADING, {\n            frag: e,\n            targetBufferTime: r\n          }), null === this.fragCurrent ? Promise.reject(new Error(\"frag load aborted, context changed in FRAG_LOADING\")) : f;\n        }, r.doFragPartsLoad = function (e, t, r, i) {\n          var a = this;\n          return new Promise(function (n, s) {\n            var o,\n              l = [],\n              u = null == (o = r.details) ? void 0 : o.partList;\n            !function t(o) {\n              a.fragmentLoader.loadPart(e, o, i).then(function (i) {\n                l[o.index] = i;\n                var s = i.part;\n                a.hls.trigger(E.FRAG_LOADED, i);\n                var d = Ft(r, e.sn, o.index + 1) || Ot(u, e.sn, o.index + 1);\n                if (!d) return n({\n                  frag: e,\n                  part: s,\n                  partsLoaded: l\n                });\n                t(d);\n              }).catch(s);\n            }(t);\n          });\n        }, r.handleFragLoadError = function (e) {\n          if (\"data\" in e) {\n            var t = e.data;\n            e.data && t.details === S.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : this.hls.trigger(E.ERROR, t);\n          } else this.hls.trigger(E.ERROR, {\n            type: T.OTHER_ERROR,\n            details: S.INTERNAL_EXCEPTION,\n            err: e,\n            error: e,\n            fatal: !0\n          });\n          return null;\n        }, r._handleTransmuxerFlush = function (e) {\n          var t = this.getCurrentContext(e);\n          if (t && this.state === ni) {\n            var r = t.frag,\n              i = t.part,\n              a = t.level,\n              n = self.performance.now();\n            r.stats.parsing.end = n, i && (i.stats.parsing.end = n), this.updateLevelTiming(r, i, a, e.partial);\n          } else this.fragCurrent || this.state === ei || this.state === li || (this.state = ti);\n        }, r.getCurrentContext = function (e) {\n          var t = this.levels,\n            r = this.fragCurrent,\n            i = e.level,\n            a = e.sn,\n            n = e.part;\n          if (null == t || !t[i]) return this.warn(\"Levels object was unset while buffering fragment \" + a + \" of level \" + i + \". The current chunk will not be buffered.\"), null;\n          var s = t[i],\n            o = n > -1 ? Ft(s, a, n) : null,\n            l = o ? o.fragment : function (e, t, r) {\n              if (null == e || !e.details) return null;\n              var i = e.details,\n                a = i.fragments[t - i.startSN];\n              return a || ((a = i.fragmentHint) && a.sn === t ? a : t < i.startSN && r && r.sn === t ? r : null);\n            }(s, a, r);\n          return l ? (r && r !== l && (l.stats = r.stats), {\n            frag: l,\n            part: o,\n            level: s\n          }) : null;\n        }, r.bufferFragmentData = function (e, t, r, i, a) {\n          var n;\n          if (e && this.state === ni) {\n            var s = e.data1,\n              o = e.data2,\n              l = s;\n            if (s && o && (l = be(s, o)), null != (n = l) && n.length) {\n              var u = {\n                type: e.type,\n                frag: t,\n                part: r,\n                chunkMeta: i,\n                parent: t.type,\n                data: l\n              };\n              if (this.hls.trigger(E.BUFFER_APPENDING, u), e.dropped && e.independent && !r) {\n                if (a) return;\n                this.flushBufferGap(t);\n              }\n            }\n          }\n        }, r.flushBufferGap = function (e) {\n          var t = this.media;\n          if (t) if (or.isBuffered(t, t.currentTime)) {\n            var r = t.currentTime,\n              i = or.bufferInfo(t, r, 0),\n              a = e.duration,\n              n = Math.min(2 * this.config.maxFragLookUpTolerance, .25 * a),\n              s = Math.max(Math.min(e.start - n, i.end - n), r + n);\n            e.start - s > n && this.flushMainBuffer(s, e.start);\n          } else this.flushMainBuffer(0, e.start);\n        }, r.getFwdBufferInfo = function (e, t) {\n          var r = this.getLoadPosition();\n          return m(r) ? this.getFwdBufferInfoAtPos(e, r, t) : null;\n        }, r.getFwdBufferInfoAtPos = function (e, t, r) {\n          var i = this.config.maxBufferHole,\n            a = or.bufferInfo(e, t, i);\n          if (0 === a.len && void 0 !== a.nextStart) {\n            var n = this.fragmentTracker.getBufferedFrag(t, r);\n            if (n && a.nextStart < n.end) return or.bufferInfo(e, t, Math.max(a.nextStart, i));\n          }\n          return a;\n        }, r.getMaxBufferLength = function (e) {\n          var t,\n            r = this.config;\n          return t = e ? Math.max(8 * r.maxBufferSize / e, r.maxBufferLength) : r.maxBufferLength, Math.min(t, r.maxMaxBufferLength);\n        }, r.reduceMaxBufferLength = function (e) {\n          var t = this.config,\n            r = e || t.maxBufferLength;\n          return t.maxMaxBufferLength >= r && (t.maxMaxBufferLength /= 2, this.warn(\"Reduce max buffer length to \" + t.maxMaxBufferLength + \"s\"), !0);\n        }, r.getAppendedFrag = function (e, t) {\n          var r = this.fragmentTracker.getAppendedFrag(e, nt);\n          return r && \"fragment\" in r ? r.fragment : r;\n        }, r.getNextFragment = function (e, t) {\n          var r = t.fragments,\n            i = r.length;\n          if (!i) return null;\n          var a,\n            n = this.config,\n            s = r[0].start;\n          if (t.live) {\n            var o = n.initialLiveManifestSize;\n            if (i < o) return this.warn(\"Not enough fragments to start playback (have: \" + i + \", need: \" + o + \")\"), null;\n            (!t.PTSKnown && !this.startFragRequested && -1 === this.startPosition || e < s) && (a = this.getInitialLiveFragment(t, r), this.startPosition = this.nextLoadPosition = a ? this.hls.liveSyncPosition || a.start : e);\n          } else e <= s && (a = r[0]);\n          if (!a) {\n            var l = n.lowLatencyMode ? t.partEnd : t.fragmentEnd;\n            a = this.getFragmentAtPosition(e, l, t);\n          }\n          return this.mapToInitFragWhenRequired(a);\n        }, r.isLoopLoading = function (e, t) {\n          var r = this.fragmentTracker.getState(e);\n          return (r === Pr || r === Ir && !!e.gap) && this.nextLoadPosition > t;\n        }, r.getNextFragmentLoopLoading = function (e, t, r, i, a) {\n          var n = e.gap,\n            s = this.getNextFragment(this.nextLoadPosition, t);\n          if (null === s) return s;\n          if (e = s, n && e && !e.gap && r.nextStart) {\n            var o = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, r.nextStart, i);\n            if (null !== o && r.len + o.len >= a) return this.log('buffer full after gaps in \"' + i + '\" playlist starting at sn: ' + e.sn), null;\n          }\n          return e;\n        }, r.mapToInitFragWhenRequired = function (e) {\n          return null == e || !e.initSegment || null != e && e.initSegment.data || this.bitrateTest ? e : e.initSegment;\n        }, r.getNextPart = function (e, t, r) {\n          for (var i = -1, a = !1, n = !0, s = 0, o = e.length; s < o; s++) {\n            var l = e[s];\n            if (n = n && !l.independent, i > -1 && r < l.start) break;\n            var u = l.loaded;\n            u ? i = -1 : (a || l.independent || n) && l.fragment === t && (i = s), a = u;\n          }\n          return i;\n        }, r.loadedEndOfParts = function (e, t) {\n          var r = e[e.length - 1];\n          return r && t > r.start && r.loaded;\n        }, r.getInitialLiveFragment = function (e, t) {\n          var r = this.fragPrevious,\n            i = null;\n          if (r) {\n            if (e.hasProgramDateTime && (this.log(\"Live playlist, switching playlist, load frag with same PDT: \" + r.programDateTime), i = function (e, t, r) {\n              if (null === t || !Array.isArray(e) || !e.length || !m(t)) return null;\n              if (t < (e[0].programDateTime || 0)) return null;\n              if (t >= (e[e.length - 1].endProgramDateTime || 0)) return null;\n              r = r || 0;\n              for (var i = 0; i < e.length; ++i) {\n                var a = e[i];\n                if (Wt(t, r, a)) return a;\n              }\n              return null;\n            }(t, r.endProgramDateTime, this.config.maxFragLookUpTolerance)), !i) {\n              var a = r.sn + 1;\n              if (a >= e.startSN && a <= e.endSN) {\n                var n = t[a - e.startSN];\n                r.cc === n.cc && (i = n, this.log(\"Live playlist, switching playlist, load frag with next SN: \" + i.sn));\n              }\n              i || (i = function (e, t) {\n                return Vt(e, function (e) {\n                  return e.cc < t ? 1 : e.cc > t ? -1 : 0;\n                });\n              }(t, r.cc), i && this.log(\"Live playlist, switching playlist, load frag with same CC: \" + i.sn));\n            }\n          } else {\n            var s = this.hls.liveSyncPosition;\n            null !== s && (i = this.getFragmentAtPosition(s, this.bitrateTest ? e.fragmentEnd : e.edge, e));\n          }\n          return i;\n        }, r.getFragmentAtPosition = function (e, t, r) {\n          var i,\n            a = this.config,\n            n = this.fragPrevious,\n            s = r.fragments,\n            o = r.endSN,\n            l = r.fragmentHint,\n            u = a.maxFragLookUpTolerance,\n            d = r.partList,\n            h = !!(a.lowLatencyMode && null != d && d.length && l);\n          if (h && l && !this.bitrateTest && (s = s.concat(l), o = l.sn), i = e < t ? Kt(n, s, e, e > t - u ? 0 : u) : s[s.length - 1]) {\n            var f = i.sn - r.startSN,\n              c = this.fragmentTracker.getState(i);\n            if ((c === Pr || c === Ir && i.gap) && (n = i), n && i.sn === n.sn && (!h || d[0].fragment.sn > i.sn) && n && i.level === n.level) {\n              var v = s[f + 1];\n              i = i.sn < o && this.fragmentTracker.getState(v) !== Pr ? v : null;\n            }\n          }\n          return i;\n        }, r.synchronizeToLiveEdge = function (e) {\n          var t = this.config,\n            r = this.media;\n          if (r) {\n            var i = this.hls.liveSyncPosition,\n              a = r.currentTime,\n              n = e.fragments[0].start,\n              s = e.edge,\n              o = a >= n - t.maxFragLookUpTolerance && a <= s;\n            if (null !== i && r.duration > i && (a < i || !o)) {\n              var l = void 0 !== t.liveMaxLatencyDuration ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration;\n              (!o && r.readyState < 4 || a < s - l) && (this.loadedmetadata || (this.nextLoadPosition = i), r.readyState && (this.warn(\"Playback: \" + a.toFixed(3) + \" is located too far from the end of live sliding playlist: \" + s + \", reset currentTime to : \" + i.toFixed(3)), r.currentTime = i));\n            }\n          }\n        }, r.alignPlaylists = function (e, t, r) {\n          var i = e.fragments.length;\n          if (!i) return this.warn(\"No fragments in live playlist\"), 0;\n          var a = e.fragments[0].start,\n            n = !t,\n            s = e.alignedSliding && m(a);\n          if (n || !s && !a) {\n            var o = this.fragPrevious;\n            zr(o, r, e);\n            var l = e.fragments[0].start;\n            return this.log(\"Live playlist sliding: \" + l.toFixed(2) + \" start-sn: \" + (t ? t.startSN : \"na\") + \"->\" + e.startSN + \" prev-sn: \" + (o ? o.sn : \"na\") + \" fragments: \" + i), l;\n          }\n          return a;\n        }, r.waitForCdnTuneIn = function (e) {\n          return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, 3 * e.partTarget);\n        }, r.setStartPosition = function (e, t) {\n          var r = this.startPosition;\n          if (r < t && (r = -1), -1 === r || -1 === this.lastCurrentTime) {\n            var i = null !== this.startTimeOffset,\n              a = i ? this.startTimeOffset : e.startTimeOffset;\n            null !== a && m(a) ? (r = t + a, a < 0 && (r += e.totalduration), r = Math.min(Math.max(t, r), t + e.totalduration), this.log(\"Start time offset \" + a + \" found in \" + (i ? \"multivariant\" : \"media\") + \" playlist, adjust startPosition to \" + r), this.startPosition = r) : e.live ? r = this.hls.liveSyncPosition || t : this.startPosition = r = 0, this.lastCurrentTime = r;\n          }\n          this.nextLoadPosition = r;\n        }, r.getLoadPosition = function () {\n          var e = this.media,\n            t = 0;\n          return this.loadedmetadata && e ? t = e.currentTime : this.nextLoadPosition && (t = this.nextLoadPosition), t;\n        }, r.handleFragLoadAborted = function (e, t) {\n          this.transmuxer && \"initSegment\" !== e.sn && e.stats.aborted && (this.warn(\"Fragment \" + e.sn + (t ? \" part \" + t.index : \"\") + \" of level \" + e.level + \" was aborted\"), this.resetFragmentLoading(e));\n        }, r.resetFragmentLoading = function (e) {\n          this.fragCurrent && (this.fragContextChanged(e) || this.state === ai) || (this.state = ti);\n        }, r.onFragmentOrKeyLoadError = function (e, t) {\n          if (t.chunkMeta && !t.frag) {\n            var r = this.getCurrentContext(t.chunkMeta);\n            r && (t.frag = r.frag);\n          }\n          var i = t.frag;\n          if (i && i.type === e && this.levels) if (this.fragContextChanged(i)) {\n            var a;\n            this.warn(\"Frag load error must match current frag to retry \" + i.url + \" > \" + (null == (a = this.fragCurrent) ? void 0 : a.url));\n          } else {\n            var n = t.details === S.FRAG_GAP;\n            n && this.fragmentTracker.fragBuffered(i, !0);\n            var s = t.errorAction,\n              o = s || {},\n              l = o.action,\n              u = o.retryCount,\n              d = void 0 === u ? 0 : u,\n              h = o.retryConfig;\n            if (s && l === Xt && h) {\n              this.resetStartWhenNotLoaded(this.levelLastLoaded);\n              var f = Ut(h, d);\n              this.warn(\"Fragment \" + i.sn + \" of \" + e + \" \" + i.level + \" errored with \" + t.details + \", retrying loading \" + (d + 1) + \"/\" + h.maxNumRetry + \" in \" + f + \"ms\"), s.resolved = !0, this.retryDate = self.performance.now() + f, this.state = ai;\n            } else if (h && s) {\n              if (this.resetFragmentErrors(e), !(d < h.maxNumRetry)) return void k.warn(t.details + \" reached or exceeded max retry (\" + d + \")\");\n              n || l === zt || (s.resolved = !0);\n            } else (null == s ? void 0 : s.action) === qt ? this.state = ui : this.state = li;\n            this.tickImmediate();\n          }\n        }, r.reduceLengthAndFlushBuffer = function (e) {\n          if (this.state === ni || this.state === si) {\n            var t = e.parent,\n              r = this.getFwdBufferInfo(this.mediaBuffer, t),\n              i = r && r.len > .5;\n            i && this.reduceMaxBufferLength(r.len);\n            var a = !i;\n            return a && this.warn(\"Buffer full error while media.currentTime is not buffered, flush \" + t + \" buffer\"), e.frag && (this.fragmentTracker.removeFragment(e.frag), this.nextLoadPosition = e.frag.start), this.resetLoadingState(), a;\n          }\n          return !1;\n        }, r.resetFragmentErrors = function (e) {\n          e === st && (this.fragCurrent = null), this.loadedmetadata || (this.startFragRequested = !1), this.state !== ei && (this.state = ti);\n        }, r.afterBufferFlushed = function (e, t, r) {\n          if (e) {\n            var i = or.getBuffered(e);\n            this.fragmentTracker.detectEvictedFragments(t, i, r), this.state === oi && this.resetLoadingState();\n          }\n        }, r.resetLoadingState = function () {\n          this.log(\"Reset loading state\"), this.fragCurrent = null, this.fragPrevious = null, this.state = ti;\n        }, r.resetStartWhenNotLoaded = function (e) {\n          if (!this.loadedmetadata) {\n            this.startFragRequested = !1;\n            var t = e ? e.details : null;\n            null != t && t.live ? (this.startPosition = -1, this.setStartPosition(t, 0), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition;\n          }\n        }, r.resetWhenMissingContext = function (e) {\n          this.warn(\"The loading context changed while buffering fragment \" + e.sn + \" of level \" + e.level + \". This chunk will not be buffered.\"), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(this.levelLastLoaded), this.resetLoadingState();\n        }, r.removeUnbufferedFrags = function (e) {\n          void 0 === e && (e = 0), this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0);\n        }, r.updateLevelTiming = function (e, t, r, i) {\n          var a,\n            n = this,\n            s = r.details;\n          if (s) {\n            if (!Object.keys(e.elementaryStreams).reduce(function (t, a) {\n              var o = e.elementaryStreams[a];\n              if (o) {\n                var l = o.endPTS - o.startPTS;\n                if (l <= 0) return n.warn(\"Could not parse fragment \" + e.sn + \" \" + a + \" duration reliably (\" + l + \")\"), t || !1;\n                var u = i ? 0 : Ct(s, e, o.startPTS, o.endPTS, o.startDTS, o.endDTS);\n                return n.hls.trigger(E.LEVEL_PTS_UPDATED, {\n                  details: s,\n                  level: r,\n                  drift: u,\n                  type: a,\n                  frag: e,\n                  start: o.startPTS,\n                  end: o.endPTS\n                }), !0;\n              }\n              return t;\n            }, !1) && null === (null == (a = this.transmuxer) ? void 0 : a.error)) {\n              var o = new Error(\"Found no media in fragment \" + e.sn + \" of level \" + e.level + \" resetting transmuxer to fallback to playlist timing\");\n              if (0 === r.fragmentError && (r.fragmentError++, e.gap = !0, this.fragmentTracker.removeFragment(e), this.fragmentTracker.fragBuffered(e, !0)), this.warn(o.message), this.hls.trigger(E.ERROR, {\n                type: T.MEDIA_ERROR,\n                details: S.FRAG_PARSING_ERROR,\n                fatal: !1,\n                error: o,\n                frag: e,\n                reason: \"Found no media in msn \" + e.sn + ' of level \"' + r.url + '\"'\n              }), !this.hls) return;\n              this.resetTransmuxer();\n            }\n            this.state = si, this.hls.trigger(E.FRAG_PARSED, {\n              frag: e,\n              part: t\n            });\n          } else this.warn(\"level.details undefined\");\n        }, r.resetTransmuxer = function () {\n          this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null);\n        }, r.recoverWorkerError = function (e) {\n          \"demuxerWorker\" === e.event && (this.fragmentTracker.removeAllFragments(), this.resetTransmuxer(), this.resetStartWhenNotLoaded(this.levelLastLoaded), this.resetLoadingState());\n        }, s(t, [{\n          key: \"state\",\n          get: function () {\n            return this._state;\n          },\n          set: function (e) {\n            var t = this._state;\n            t !== e && (this._state = e, this.log(t + \"->\" + e));\n          }\n        }]), t;\n      }(Kr);\n    function hi() {\n      return self.SourceBuffer || self.WebKitSourceBuffer;\n    }\n    function fi() {\n      if (!Ce()) return !1;\n      var e = hi();\n      return !e || e.prototype && \"function\" == typeof e.prototype.appendBuffer && \"function\" == typeof e.prototype.remove;\n    }\n    function ci(e, t) {\n      return void 0 === e && (e = \"\"), void 0 === t && (t = 9e4), {\n        type: e,\n        id: -1,\n        pid: -1,\n        inputTimeScale: t,\n        sequenceNumber: -1,\n        samples: [],\n        dropped: 0\n      };\n    }\n    var vi = function () {\n        function e() {\n          this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null;\n        }\n        var t = e.prototype;\n        return t.resetInitSegment = function (e, t, r, i) {\n          this._id3Track = {\n            type: \"id3\",\n            id: 3,\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: 0,\n            samples: [],\n            dropped: 0\n          };\n        }, t.resetTimeStamp = function (e) {\n          this.initPTS = e, this.resetContiguity();\n        }, t.resetContiguity = function () {\n          this.basePTS = null, this.lastPTS = null, this.frameIndex = 0;\n        }, t.canParse = function (e, t) {\n          return !1;\n        }, t.appendFrame = function (e, t, r) {}, t.demux = function (e, t) {\n          this.cachedData && (e = be(this.cachedData, e), this.cachedData = null);\n          var r,\n            i = Y(e, 0),\n            a = i ? i.length : 0,\n            n = this._audioTrack,\n            s = this._id3Track,\n            o = i ? X(i) : void 0,\n            l = e.length;\n          for ((null === this.basePTS || 0 === this.frameIndex && m(o)) && (this.basePTS = gi(o, t, this.initPTS), this.lastPTS = this.basePTS), null === this.lastPTS && (this.lastPTS = this.basePTS), i && i.length > 0 && s.samples.push({\n            pts: this.lastPTS,\n            dts: this.lastPTS,\n            data: i,\n            type: ct,\n            duration: Number.POSITIVE_INFINITY\n          }); a < l;) {\n            if (this.canParse(e, a)) {\n              var u = this.appendFrame(n, e, a);\n              u ? (this.frameIndex++, this.lastPTS = u.sample.pts, r = a += u.length) : a = l;\n            } else z(e, a) ? (i = Y(e, a), s.samples.push({\n              pts: this.lastPTS,\n              dts: this.lastPTS,\n              data: i,\n              type: ct,\n              duration: Number.POSITIVE_INFINITY\n            }), r = a += i.length) : a++;\n            if (a === l && r !== l) {\n              var d = V(e, r);\n              this.cachedData ? this.cachedData = be(this.cachedData, d) : this.cachedData = d;\n            }\n          }\n          return {\n            audioTrack: n,\n            videoTrack: ci(),\n            id3Track: s,\n            textTrack: ci()\n          };\n        }, t.demuxSampleAes = function (e, t, r) {\n          return Promise.reject(new Error(\"[\" + this + \"] This demuxer does not support Sample-AES decryption\"));\n        }, t.flush = function (e) {\n          var t = this.cachedData;\n          return t && (this.cachedData = null, this.demux(t, 0)), {\n            audioTrack: this._audioTrack,\n            videoTrack: ci(),\n            id3Track: this._id3Track,\n            textTrack: ci()\n          };\n        }, t.destroy = function () {}, e;\n      }(),\n      gi = function (e, t, r) {\n        return m(e) ? 90 * e : 9e4 * t + (r ? 9e4 * r.baseTime / r.timescale : 0);\n      };\n    function mi(e, t) {\n      return 255 === e[t] && 240 == (246 & e[t + 1]);\n    }\n    function pi(e, t) {\n      return 1 & e[t + 1] ? 7 : 9;\n    }\n    function yi(e, t) {\n      return (3 & e[t + 3]) << 11 | e[t + 4] << 3 | (224 & e[t + 5]) >>> 5;\n    }\n    function Ei(e, t) {\n      return t + 1 < e.length && mi(e, t);\n    }\n    function Ti(e, t) {\n      if (Ei(e, t)) {\n        var r = pi(e, t);\n        if (t + r >= e.length) return !1;\n        var i = yi(e, t);\n        if (i <= r) return !1;\n        var a = t + i;\n        return a === e.length || Ei(e, a);\n      }\n      return !1;\n    }\n    function Si(e, t, r, i, a) {\n      if (!e.samplerate) {\n        var n = function (e, t, r, i) {\n          var a,\n            n,\n            s,\n            o,\n            l = navigator.userAgent.toLowerCase(),\n            u = i,\n            d = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];\n          a = 1 + ((192 & t[r + 2]) >>> 6);\n          var h = (60 & t[r + 2]) >>> 2;\n          if (!(h > d.length - 1)) return s = (1 & t[r + 2]) << 2, s |= (192 & t[r + 3]) >>> 6, k.log(\"manifest codec:\" + i + \", ADTS type:\" + a + \", samplingIndex:\" + h), /firefox/i.test(l) ? h >= 6 ? (a = 5, o = new Array(4), n = h - 3) : (a = 2, o = new Array(2), n = h) : -1 !== l.indexOf(\"android\") ? (a = 2, o = new Array(2), n = h) : (a = 5, o = new Array(4), i && (-1 !== i.indexOf(\"mp4a.40.29\") || -1 !== i.indexOf(\"mp4a.40.5\")) || !i && h >= 6 ? n = h - 3 : ((i && -1 !== i.indexOf(\"mp4a.40.2\") && (h >= 6 && 1 === s || /vivaldi/i.test(l)) || !i && 1 === s) && (a = 2, o = new Array(2)), n = h)), o[0] = a << 3, o[0] |= (14 & h) >> 1, o[1] |= (1 & h) << 7, o[1] |= s << 3, 5 === a && (o[1] |= (14 & n) >> 1, o[2] = (1 & n) << 7, o[2] |= 8, o[3] = 0), {\n            config: o,\n            samplerate: d[h],\n            channelCount: s,\n            codec: \"mp4a.40.\" + a,\n            manifestCodec: u\n          };\n          var f = new Error(\"invalid ADTS sampling index:\" + h);\n          e.emit(E.ERROR, E.ERROR, {\n            type: T.MEDIA_ERROR,\n            details: S.FRAG_PARSING_ERROR,\n            fatal: !0,\n            error: f,\n            reason: f.message\n          });\n        }(t, r, i, a);\n        if (!n) return;\n        e.config = n.config, e.samplerate = n.samplerate, e.channelCount = n.channelCount, e.codec = n.codec, e.manifestCodec = n.manifestCodec, k.log(\"parsed codec:\" + e.codec + \", rate:\" + n.samplerate + \", channels:\" + n.channelCount);\n      }\n    }\n    function Li(e) {\n      return 9216e4 / e;\n    }\n    function Ri(e, t, r, i, a) {\n      var n,\n        s = i + a * Li(e.samplerate),\n        o = function (e, t) {\n          var r = pi(e, t);\n          if (t + r <= e.length) {\n            var i = yi(e, t) - r;\n            if (i > 0) return {\n              headerLength: r,\n              frameLength: i\n            };\n          }\n        }(t, r);\n      if (o) {\n        var l = o.frameLength,\n          u = o.headerLength,\n          d = u + l,\n          h = Math.max(0, r + d - t.length);\n        h ? (n = new Uint8Array(d - u)).set(t.subarray(r + u, t.length), 0) : n = t.subarray(r + u, r + d);\n        var f = {\n          unit: n,\n          pts: s\n        };\n        return h || e.samples.push(f), {\n          sample: f,\n          length: d,\n          missing: h\n        };\n      }\n      var c = t.length - r;\n      return (n = new Uint8Array(c)).set(t.subarray(r, t.length), 0), {\n        sample: {\n          unit: n,\n          pts: s\n        },\n        length: c,\n        missing: -1\n      };\n    }\n    var Ai = null,\n      bi = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],\n      Di = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],\n      ki = [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]],\n      _i = [0, 1, 1, 4];\n    function xi(e, t, r, i, a) {\n      if (!(r + 24 > t.length)) {\n        var n = wi(t, r);\n        if (n && r + n.frameLength <= t.length) {\n          var s = i + a * (9e4 * n.samplesPerFrame / n.sampleRate),\n            o = {\n              unit: t.subarray(r, r + n.frameLength),\n              pts: s,\n              dts: s\n            };\n          return e.config = [], e.channelCount = n.channelCount, e.samplerate = n.sampleRate, e.samples.push(o), {\n            sample: o,\n            length: n.frameLength,\n            missing: 0\n          };\n        }\n      }\n    }\n    function wi(e, t) {\n      var r = e[t + 1] >> 3 & 3,\n        i = e[t + 1] >> 1 & 3,\n        a = e[t + 2] >> 4 & 15,\n        n = e[t + 2] >> 2 & 3;\n      if (1 !== r && 0 !== a && 15 !== a && 3 !== n) {\n        var s = e[t + 2] >> 1 & 1,\n          o = e[t + 3] >> 6,\n          l = 1e3 * bi[14 * (3 === r ? 3 - i : 3 === i ? 3 : 4) + a - 1],\n          u = Di[3 * (3 === r ? 0 : 2 === r ? 1 : 2) + n],\n          d = 3 === o ? 1 : 2,\n          h = ki[r][i],\n          f = _i[i],\n          c = 8 * h * f,\n          v = Math.floor(h * l / u + s) * f;\n        if (null === Ai) {\n          var g = (navigator.userAgent || \"\").match(/Chrome\\/(\\d+)/i);\n          Ai = g ? parseInt(g[1]) : 0;\n        }\n        return !!Ai && Ai <= 87 && 2 === i && l >= 224e3 && 0 === o && (e[t + 3] = 128 | e[t + 3]), {\n          sampleRate: u,\n          channelCount: d,\n          frameLength: v,\n          samplesPerFrame: c\n        };\n      }\n    }\n    function Ci(e, t) {\n      return 255 === e[t] && 224 == (224 & e[t + 1]) && 0 != (6 & e[t + 1]);\n    }\n    function Ii(e, t) {\n      return t + 1 < e.length && Ci(e, t);\n    }\n    function Pi(e, t) {\n      if (t + 1 < e.length && Ci(e, t)) {\n        var r = wi(e, t),\n          i = 4;\n        null != r && r.frameLength && (i = r.frameLength);\n        var a = t + i;\n        return a === e.length || Ii(e, a);\n      }\n      return !1;\n    }\n    var Fi = function (e) {\n        function t(t, r) {\n          var i;\n          return (i = e.call(this) || this).observer = void 0, i.config = void 0, i.observer = t, i.config = r, i;\n        }\n        l(t, e);\n        var r = t.prototype;\n        return r.resetInitSegment = function (t, r, i, a) {\n          e.prototype.resetInitSegment.call(this, t, r, i, a), this._audioTrack = {\n            container: \"audio/adts\",\n            type: \"audio\",\n            id: 2,\n            pid: -1,\n            sequenceNumber: 0,\n            segmentCodec: \"aac\",\n            samples: [],\n            manifestCodec: r,\n            duration: a,\n            inputTimeScale: 9e4,\n            dropped: 0\n          };\n        }, t.probe = function (e) {\n          if (!e) return !1;\n          var t = Y(e, 0),\n            r = (null == t ? void 0 : t.length) || 0;\n          if (Pi(e, r)) return !1;\n          for (var i = e.length; r < i; r++) if (Ti(e, r)) return k.log(\"ADTS sync word found !\"), !0;\n          return !1;\n        }, r.canParse = function (e, t) {\n          return function (e, t) {\n            return function (e, t) {\n              return t + 5 < e.length;\n            }(e, t) && mi(e, t) && yi(e, t) <= e.length - t;\n          }(e, t);\n        }, r.appendFrame = function (e, t, r) {\n          Si(e, this.observer, t, r, e.manifestCodec);\n          var i = Ri(e, t, r, this.basePTS, this.frameIndex);\n          if (i && 0 === i.missing) return i;\n        }, t;\n      }(vi),\n      Oi = /\\/emsg[-/]ID3/i,\n      Mi = function () {\n        function e(e, t) {\n          this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = t;\n        }\n        var t = e.prototype;\n        return t.resetTimeStamp = function () {}, t.resetInitSegment = function (e, t, r, i) {\n          var a = this.videoTrack = ci(\"video\", 1),\n            n = this.audioTrack = ci(\"audio\", 1),\n            s = this.txtTrack = ci(\"text\", 1);\n          if (this.id3Track = ci(\"id3\", 1), this.timeOffset = 0, null != e && e.byteLength) {\n            var o = ye(e);\n            if (o.video) {\n              var l = o.video,\n                u = l.id,\n                d = l.timescale,\n                h = l.codec;\n              a.id = u, a.timescale = s.timescale = d, a.codec = h;\n            }\n            if (o.audio) {\n              var f = o.audio,\n                c = f.id,\n                v = f.timescale,\n                g = f.codec;\n              n.id = c, n.timescale = v, n.codec = g;\n            }\n            s.id = ue.text, a.sampleDuration = 0, a.duration = n.duration = i;\n          }\n        }, t.resetContiguity = function () {\n          this.remainderData = null;\n        }, e.probe = function (e) {\n          return function (e) {\n            for (var t = e.byteLength, r = 0; r < t;) {\n              var i = fe(e, r);\n              if (i > 8 && 109 === e[r + 4] && 111 === e[r + 5] && 111 === e[r + 6] && 102 === e[r + 7]) return !0;\n              r = i > 1 ? r + i : t;\n            }\n            return !1;\n          }(e);\n        }, t.demux = function (e, t) {\n          this.timeOffset = t;\n          var r = e,\n            i = this.videoTrack,\n            a = this.txtTrack;\n          if (this.config.progressive) {\n            this.remainderData && (r = be(this.remainderData, e));\n            var n = function (e) {\n              var t = {\n                  valid: null,\n                  remainder: null\n                },\n                r = me(e, [\"moof\"]);\n              if (r.length < 2) return t.remainder = e, t;\n              var i = r[r.length - 1];\n              return t.valid = V(e, 0, i.byteOffset - 8), t.remainder = V(e, i.byteOffset - 8), t;\n            }(r);\n            this.remainderData = n.remainder, i.samples = n.valid || new Uint8Array();\n          } else i.samples = r;\n          var s = this.extractID3Track(i, t);\n          return a.samples = De(t, i), {\n            videoTrack: i,\n            audioTrack: this.audioTrack,\n            id3Track: s,\n            textTrack: this.txtTrack\n          };\n        }, t.flush = function () {\n          var e = this.timeOffset,\n            t = this.videoTrack,\n            r = this.txtTrack;\n          t.samples = this.remainderData || new Uint8Array(), this.remainderData = null;\n          var i = this.extractID3Track(t, this.timeOffset);\n          return r.samples = De(e, t), {\n            videoTrack: t,\n            audioTrack: ci(),\n            id3Track: i,\n            textTrack: ci()\n          };\n        }, t.extractID3Track = function (e, t) {\n          var r = this.id3Track;\n          if (e.samples.length) {\n            var i = me(e.samples, [\"emsg\"]);\n            i && i.forEach(function (e) {\n              var i = function (e) {\n                var t = e[0],\n                  r = \"\",\n                  i = \"\",\n                  a = 0,\n                  n = 0,\n                  s = 0,\n                  o = 0,\n                  l = 0,\n                  u = 0;\n                if (0 === t) {\n                  for (; \"\\0\" !== de(e.subarray(u, u + 1));) r += de(e.subarray(u, u + 1)), u += 1;\n                  for (r += de(e.subarray(u, u + 1)), u += 1; \"\\0\" !== de(e.subarray(u, u + 1));) i += de(e.subarray(u, u + 1)), u += 1;\n                  i += de(e.subarray(u, u + 1)), u += 1, a = fe(e, 12), n = fe(e, 16), o = fe(e, 20), l = fe(e, 24), u = 28;\n                } else if (1 === t) {\n                  a = fe(e, u += 4);\n                  var d = fe(e, u += 4),\n                    h = fe(e, u += 4);\n                  for (u += 4, s = Math.pow(2, 32) * d + h, p(s) || (s = Number.MAX_SAFE_INTEGER, k.warn(\"Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box\")), o = fe(e, u), l = fe(e, u += 4), u += 4; \"\\0\" !== de(e.subarray(u, u + 1));) r += de(e.subarray(u, u + 1)), u += 1;\n                  for (r += de(e.subarray(u, u + 1)), u += 1; \"\\0\" !== de(e.subarray(u, u + 1));) i += de(e.subarray(u, u + 1)), u += 1;\n                  i += de(e.subarray(u, u + 1)), u += 1;\n                }\n                return {\n                  schemeIdUri: r,\n                  value: i,\n                  timeScale: a,\n                  presentationTime: s,\n                  presentationTimeDelta: n,\n                  eventDuration: o,\n                  id: l,\n                  payload: e.subarray(u, e.byteLength)\n                };\n              }(e);\n              if (Oi.test(i.schemeIdUri)) {\n                var a = m(i.presentationTime) ? i.presentationTime / i.timeScale : t + i.presentationTimeDelta / i.timeScale,\n                  n = 4294967295 === i.eventDuration ? Number.POSITIVE_INFINITY : i.eventDuration / i.timeScale;\n                n <= .001 && (n = Number.POSITIVE_INFINITY);\n                var s = i.payload;\n                r.samples.push({\n                  data: s,\n                  len: s.byteLength,\n                  dts: a,\n                  pts: a,\n                  type: gt,\n                  duration: n\n                });\n              }\n            });\n          }\n          return r;\n        }, t.demuxSampleAes = function (e, t, r) {\n          return Promise.reject(new Error(\"The MP4 demuxer does not support SAMPLE-AES decryption\"));\n        }, t.destroy = function () {}, e;\n      }(),\n      Ni = function () {\n        function e() {\n          this.VideoSample = null;\n        }\n        var t = e.prototype;\n        return t.createVideoSample = function (e, t, r, i) {\n          return {\n            key: e,\n            frame: !1,\n            pts: t,\n            dts: r,\n            units: [],\n            debug: i,\n            length: 0\n          };\n        }, t.getLastNalUnit = function (e) {\n          var t,\n            r,\n            i = this.VideoSample;\n          if (i && 0 !== i.units.length || (i = e[e.length - 1]), null != (t = i) && t.units) {\n            var a = i.units;\n            r = a[a.length - 1];\n          }\n          return r;\n        }, t.pushAccessUnit = function (e, t) {\n          if (e.units.length && e.frame) {\n            if (void 0 === e.pts) {\n              var r = t.samples,\n                i = r.length;\n              if (!i) return void t.dropped++;\n              var a = r[i - 1];\n              e.pts = a.pts, e.dts = a.dts;\n            }\n            t.samples.push(e);\n          }\n          e.debug.length && k.log(e.pts + \"/\" + e.dts + \":\" + e.debug);\n        }, e;\n      }(),\n      Bi = function () {\n        function e(e) {\n          this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0;\n        }\n        var t = e.prototype;\n        return t.loadWord = function () {\n          var e = this.data,\n            t = this.bytesAvailable,\n            r = e.byteLength - t,\n            i = new Uint8Array(4),\n            a = Math.min(4, t);\n          if (0 === a) throw new Error(\"no bytes available\");\n          i.set(e.subarray(r, r + a)), this.word = new DataView(i.buffer).getUint32(0), this.bitsAvailable = 8 * a, this.bytesAvailable -= a;\n        }, t.skipBits = function (e) {\n          var t;\n          e = Math.min(e, 8 * this.bytesAvailable + this.bitsAvailable), this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (e -= this.bitsAvailable, e -= (t = e >> 3) << 3, this.bytesAvailable -= t, this.loadWord(), this.word <<= e, this.bitsAvailable -= e);\n        }, t.readBits = function (e) {\n          var t = Math.min(this.bitsAvailable, e),\n            r = this.word >>> 32 - t;\n          if (e > 32 && k.error(\"Cannot read more than 32 bits at a time\"), this.bitsAvailable -= t, this.bitsAvailable > 0) this.word <<= t;else {\n            if (!(this.bytesAvailable > 0)) throw new Error(\"no bits available\");\n            this.loadWord();\n          }\n          return (t = e - t) > 0 && this.bitsAvailable ? r << t | this.readBits(t) : r;\n        }, t.skipLZ = function () {\n          var e;\n          for (e = 0; e < this.bitsAvailable; ++e) if (0 != (this.word & 2147483648 >>> e)) return this.word <<= e, this.bitsAvailable -= e, e;\n          return this.loadWord(), e + this.skipLZ();\n        }, t.skipUEG = function () {\n          this.skipBits(1 + this.skipLZ());\n        }, t.skipEG = function () {\n          this.skipBits(1 + this.skipLZ());\n        }, t.readUEG = function () {\n          var e = this.skipLZ();\n          return this.readBits(e + 1) - 1;\n        }, t.readEG = function () {\n          var e = this.readUEG();\n          return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1);\n        }, t.readBoolean = function () {\n          return 1 === this.readBits(1);\n        }, t.readUByte = function () {\n          return this.readBits(8);\n        }, t.readUShort = function () {\n          return this.readBits(16);\n        }, t.readUInt = function () {\n          return this.readBits(32);\n        }, t.skipScalingList = function (e) {\n          for (var t = 8, r = 8, i = 0; i < e; i++) 0 !== r && (r = (t + this.readEG() + 256) % 256), t = 0 === r ? t : r;\n        }, t.readSPS = function () {\n          var e,\n            t,\n            r,\n            i = 0,\n            a = 0,\n            n = 0,\n            s = 0,\n            o = this.readUByte.bind(this),\n            l = this.readBits.bind(this),\n            u = this.readUEG.bind(this),\n            d = this.readBoolean.bind(this),\n            h = this.skipBits.bind(this),\n            f = this.skipEG.bind(this),\n            c = this.skipUEG.bind(this),\n            v = this.skipScalingList.bind(this);\n          o();\n          var g = o();\n          if (l(5), h(3), o(), c(), 100 === g || 110 === g || 122 === g || 244 === g || 44 === g || 83 === g || 86 === g || 118 === g || 128 === g) {\n            var m = u();\n            if (3 === m && h(1), c(), c(), h(1), d()) for (t = 3 !== m ? 8 : 12, r = 0; r < t; r++) d() && v(r < 6 ? 16 : 64);\n          }\n          c();\n          var p = u();\n          if (0 === p) u();else if (1 === p) for (h(1), f(), f(), e = u(), r = 0; r < e; r++) f();\n          c(), h(1);\n          var y = u(),\n            E = u(),\n            T = l(1);\n          0 === T && h(1), h(1), d() && (i = u(), a = u(), n = u(), s = u());\n          var S = [1, 1];\n          if (d() && d()) switch (o()) {\n            case 1:\n              S = [1, 1];\n              break;\n            case 2:\n              S = [12, 11];\n              break;\n            case 3:\n              S = [10, 11];\n              break;\n            case 4:\n              S = [16, 11];\n              break;\n            case 5:\n              S = [40, 33];\n              break;\n            case 6:\n              S = [24, 11];\n              break;\n            case 7:\n              S = [20, 11];\n              break;\n            case 8:\n              S = [32, 11];\n              break;\n            case 9:\n              S = [80, 33];\n              break;\n            case 10:\n              S = [18, 11];\n              break;\n            case 11:\n              S = [15, 11];\n              break;\n            case 12:\n              S = [64, 33];\n              break;\n            case 13:\n              S = [160, 99];\n              break;\n            case 14:\n              S = [4, 3];\n              break;\n            case 15:\n              S = [3, 2];\n              break;\n            case 16:\n              S = [2, 1];\n              break;\n            case 255:\n              S = [o() << 8 | o(), o() << 8 | o()];\n          }\n          return {\n            width: Math.ceil(16 * (y + 1) - 2 * i - 2 * a),\n            height: (2 - T) * (E + 1) * 16 - (T ? 2 : 4) * (n + s),\n            pixelRatio: S\n          };\n        }, t.readSliceType = function () {\n          return this.readUByte(), this.readUEG(), this.readUEG();\n        }, e;\n      }(),\n      Ui = function (e) {\n        function t() {\n          return e.apply(this, arguments) || this;\n        }\n        l(t, e);\n        var r = t.prototype;\n        return r.parseAVCPES = function (e, t, r, i, a) {\n          var n,\n            s = this,\n            o = this.parseAVCNALu(e, r.data),\n            l = this.VideoSample,\n            u = !1;\n          r.data = null, l && o.length && !e.audFound && (this.pushAccessUnit(l, e), l = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts, \"\")), o.forEach(function (i) {\n            var o;\n            switch (i.type) {\n              case 1:\n                var d = !1;\n                n = !0;\n                var h,\n                  f = i.data;\n                if (u && f.length > 4) {\n                  var c = new Bi(f).readSliceType();\n                  2 !== c && 4 !== c && 7 !== c && 9 !== c || (d = !0);\n                }\n                d && null != (h = l) && h.frame && !l.key && (s.pushAccessUnit(l, e), l = s.VideoSample = null), l || (l = s.VideoSample = s.createVideoSample(!0, r.pts, r.dts, \"\")), l.frame = !0, l.key = d;\n                break;\n              case 5:\n                n = !0, null != (o = l) && o.frame && !l.key && (s.pushAccessUnit(l, e), l = s.VideoSample = null), l || (l = s.VideoSample = s.createVideoSample(!0, r.pts, r.dts, \"\")), l.key = !0, l.frame = !0;\n                break;\n              case 6:\n                n = !0, _e(i.data, 1, r.pts, t.samples);\n                break;\n              case 7:\n                var v, g;\n                n = !0, u = !0;\n                var m = i.data,\n                  p = new Bi(m).readSPS();\n                if (!e.sps || e.width !== p.width || e.height !== p.height || (null == (v = e.pixelRatio) ? void 0 : v[0]) !== p.pixelRatio[0] || (null == (g = e.pixelRatio) ? void 0 : g[1]) !== p.pixelRatio[1]) {\n                  e.width = p.width, e.height = p.height, e.pixelRatio = p.pixelRatio, e.sps = [m], e.duration = a;\n                  for (var y = m.subarray(1, 4), E = \"avc1.\", T = 0; T < 3; T++) {\n                    var S = y[T].toString(16);\n                    S.length < 2 && (S = \"0\" + S), E += S;\n                  }\n                  e.codec = E;\n                }\n                break;\n              case 8:\n                n = !0, e.pps = [i.data];\n                break;\n              case 9:\n                n = !0, e.audFound = !0, l && s.pushAccessUnit(l, e), l = s.VideoSample = s.createVideoSample(!1, r.pts, r.dts, \"\");\n                break;\n              case 12:\n                n = !0;\n                break;\n              default:\n                n = !1, l && (l.debug += \"unknown NAL \" + i.type + \" \");\n            }\n            l && n && l.units.push(i);\n          }), i && l && (this.pushAccessUnit(l, e), this.VideoSample = null);\n        }, r.parseAVCNALu = function (e, t) {\n          var r,\n            i,\n            a = t.byteLength,\n            n = e.naluState || 0,\n            s = n,\n            o = [],\n            l = 0,\n            u = -1,\n            d = 0;\n          for (-1 === n && (u = 0, d = 31 & t[0], n = 0, l = 1); l < a;) if (r = t[l++], n) {\n            if (1 !== n) {\n              if (r) {\n                if (1 === r) {\n                  if (i = l - n - 1, u >= 0) {\n                    var h = {\n                      data: t.subarray(u, i),\n                      type: d\n                    };\n                    o.push(h);\n                  } else {\n                    var f = this.getLastNalUnit(e.samples);\n                    f && (s && l <= 4 - s && f.state && (f.data = f.data.subarray(0, f.data.byteLength - s)), i > 0 && (f.data = be(f.data, t.subarray(0, i)), f.state = 0));\n                  }\n                  l < a ? (u = l, d = 31 & t[l], n = 0) : n = -1;\n                } else n = 0;\n              } else n = 3;\n            } else n = r ? 0 : 2;\n          } else n = r ? 0 : 1;\n          if (u >= 0 && n >= 0) {\n            var c = {\n              data: t.subarray(u, a),\n              type: d,\n              state: n\n            };\n            o.push(c);\n          }\n          if (0 === o.length) {\n            var v = this.getLastNalUnit(e.samples);\n            v && (v.data = be(v.data, t));\n          }\n          return e.naluState = n, o;\n        }, t;\n      }(Ni),\n      Gi = function () {\n        function e(e, t, r) {\n          this.keyData = void 0, this.decrypter = void 0, this.keyData = r, this.decrypter = new $r(t, {\n            removePKCS7Padding: !1\n          });\n        }\n        var t = e.prototype;\n        return t.decryptBuffer = function (e) {\n          return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer);\n        }, t.decryptAacSample = function (e, t, r) {\n          var i = this,\n            a = e[t].unit;\n          if (!(a.length <= 16)) {\n            var n = a.subarray(16, a.length - a.length % 16),\n              s = n.buffer.slice(n.byteOffset, n.byteOffset + n.length);\n            this.decryptBuffer(s).then(function (n) {\n              var s = new Uint8Array(n);\n              a.set(s, 16), i.decrypter.isSync() || i.decryptAacSamples(e, t + 1, r);\n            });\n          }\n        }, t.decryptAacSamples = function (e, t, r) {\n          for (;; t++) {\n            if (t >= e.length) return void r();\n            if (!(e[t].unit.length < 32 || (this.decryptAacSample(e, t, r), this.decrypter.isSync()))) return;\n          }\n        }, t.getAvcEncryptedData = function (e) {\n          for (var t = 16 * Math.floor((e.length - 48) / 160) + 16, r = new Int8Array(t), i = 0, a = 32; a < e.length - 16; a += 160, i += 16) r.set(e.subarray(a, a + 16), i);\n          return r;\n        }, t.getAvcDecryptedUnit = function (e, t) {\n          for (var r = new Uint8Array(t), i = 0, a = 32; a < e.length - 16; a += 160, i += 16) e.set(r.subarray(i, i + 16), a);\n          return e;\n        }, t.decryptAvcSample = function (e, t, r, i, a) {\n          var n = this,\n            s = xe(a.data),\n            o = this.getAvcEncryptedData(s);\n          this.decryptBuffer(o.buffer).then(function (o) {\n            a.data = n.getAvcDecryptedUnit(s, o), n.decrypter.isSync() || n.decryptAvcSamples(e, t, r + 1, i);\n          });\n        }, t.decryptAvcSamples = function (e, t, r, i) {\n          if (e instanceof Uint8Array) throw new Error(\"Cannot decrypt samples of type Uint8Array\");\n          for (;; t++, r = 0) {\n            if (t >= e.length) return void i();\n            for (var a = e[t].units; !(r >= a.length); r++) {\n              var n = a[r];\n              if (!(n.data.length <= 48 || 1 !== n.type && 5 !== n.type || (this.decryptAvcSample(e, t, r, i, n), this.decrypter.isSync()))) return;\n            }\n          }\n        }, e;\n      }(),\n      Hi = 188,\n      Vi = function () {\n        function e(e, t, r) {\n          this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this._pmtId = -1, this._videoTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.remainderData = null, this.videoParser = void 0, this.observer = e, this.config = t, this.typeSupported = r, this.videoParser = new Ui();\n        }\n        e.probe = function (t) {\n          var r = e.syncOffset(t);\n          return r > 0 && k.warn(\"MPEG2-TS detected but first sync word found @ offset \" + r), -1 !== r;\n        }, e.syncOffset = function (e) {\n          for (var t = e.length, r = Math.min(940, t - Hi) + 1, i = 0; i < r;) {\n            for (var a = !1, n = -1, s = 0, o = i; o < t; o += Hi) {\n              if (71 !== e[o] || t - o !== Hi && 71 !== e[o + Hi]) {\n                if (s) return -1;\n                break;\n              }\n              if (s++, -1 === n && 0 !== (n = o) && (r = Math.min(n + 18612, e.length - Hi) + 1), a || (a = 0 === Ki(e, o)), a && s > 1 && (0 === n && s > 2 || o + Hi > r)) return n;\n            }\n            i++;\n          }\n          return -1;\n        }, e.createTrack = function (e, t) {\n          return {\n            container: \"video\" === e || \"audio\" === e ? \"video/mp2t\" : void 0,\n            type: e,\n            id: ue[e],\n            pid: -1,\n            inputTimeScale: 9e4,\n            sequenceNumber: 0,\n            samples: [],\n            dropped: 0,\n            duration: \"audio\" === e ? t : void 0\n          };\n        };\n        var t = e.prototype;\n        return t.resetInitSegment = function (t, r, i, a) {\n          this.pmtParsed = !1, this._pmtId = -1, this._videoTrack = e.createTrack(\"video\"), this._audioTrack = e.createTrack(\"audio\", a), this._id3Track = e.createTrack(\"id3\"), this._txtTrack = e.createTrack(\"text\"), this._audioTrack.segmentCodec = \"aac\", this.aacOverFlow = null, this.remainderData = null, this.audioCodec = r, this.videoCodec = i, this._duration = a;\n        }, t.resetTimeStamp = function () {}, t.resetContiguity = function () {\n          var e = this._audioTrack,\n            t = this._videoTrack,\n            r = this._id3Track;\n          e && (e.pesData = null), t && (t.pesData = null), r && (r.pesData = null), this.aacOverFlow = null, this.remainderData = null;\n        }, t.demux = function (t, r, i, a) {\n          var n;\n          void 0 === i && (i = !1), void 0 === a && (a = !1), i || (this.sampleAes = null);\n          var s = this._videoTrack,\n            o = this._audioTrack,\n            l = this._id3Track,\n            u = this._txtTrack,\n            d = s.pid,\n            h = s.pesData,\n            f = o.pid,\n            c = l.pid,\n            v = o.pesData,\n            g = l.pesData,\n            m = null,\n            p = this.pmtParsed,\n            y = this._pmtId,\n            L = t.length;\n          if (this.remainderData && (L = (t = be(this.remainderData, t)).length, this.remainderData = null), L < Hi && !a) return this.remainderData = t, {\n            audioTrack: o,\n            videoTrack: s,\n            id3Track: l,\n            textTrack: u\n          };\n          var R = Math.max(0, e.syncOffset(t));\n          (L -= (L - R) % Hi) < t.byteLength && !a && (this.remainderData = new Uint8Array(t.buffer, L, t.buffer.byteLength - L));\n          for (var A = 0, b = R; b < L; b += Hi) if (71 === t[b]) {\n            var D = !!(64 & t[b + 1]),\n              _ = Ki(t, b),\n              x = void 0;\n            if ((48 & t[b + 3]) >> 4 > 1) {\n              if ((x = b + 5 + t[b + 4]) === b + Hi) continue;\n            } else x = b + 4;\n            switch (_) {\n              case d:\n                D && (h && (n = qi(h)) && this.videoParser.parseAVCPES(s, u, n, !1, this._duration), h = {\n                  data: [],\n                  size: 0\n                }), h && (h.data.push(t.subarray(x, b + Hi)), h.size += b + Hi - x);\n                break;\n              case f:\n                if (D) {\n                  if (v && (n = qi(v))) switch (o.segmentCodec) {\n                    case \"aac\":\n                      this.parseAACPES(o, n);\n                      break;\n                    case \"mp3\":\n                      this.parseMPEGPES(o, n);\n                  }\n                  v = {\n                    data: [],\n                    size: 0\n                  };\n                }\n                v && (v.data.push(t.subarray(x, b + Hi)), v.size += b + Hi - x);\n                break;\n              case c:\n                D && (g && (n = qi(g)) && this.parseID3PES(l, n), g = {\n                  data: [],\n                  size: 0\n                }), g && (g.data.push(t.subarray(x, b + Hi)), g.size += b + Hi - x);\n                break;\n              case 0:\n                D && (x += t[x] + 1), y = this._pmtId = ji(t, x);\n                break;\n              case y:\n                D && (x += t[x] + 1);\n                var w = Wi(t, x, this.typeSupported, i);\n                (d = w.videoPid) > 0 && (s.pid = d, s.segmentCodec = w.segmentVideoCodec), (f = w.audioPid) > 0 && (o.pid = f, o.segmentCodec = w.segmentAudioCodec), (c = w.id3Pid) > 0 && (l.pid = c), null === m || p || (k.warn(\"MPEG-TS PMT found at \" + b + \" after unknown PID '\" + m + \"'. Backtracking to sync byte @\" + R + \" to parse all TS packets.\"), m = null, b = R - 188), p = this.pmtParsed = !0;\n                break;\n              case 17:\n              case 8191:\n                break;\n              default:\n                m = _;\n            }\n          } else A++;\n          if (A > 0) {\n            var C = new Error(\"Found \" + A + \" TS packet/s that do not start with 0x47\");\n            this.observer.emit(E.ERROR, E.ERROR, {\n              type: T.MEDIA_ERROR,\n              details: S.FRAG_PARSING_ERROR,\n              fatal: !1,\n              error: C,\n              reason: C.message\n            });\n          }\n          s.pesData = h, o.pesData = v, l.pesData = g;\n          var I = {\n            audioTrack: o,\n            videoTrack: s,\n            id3Track: l,\n            textTrack: u\n          };\n          return a && this.extractRemainingSamples(I), I;\n        }, t.flush = function () {\n          var e,\n            t = this.remainderData;\n          return this.remainderData = null, e = t ? this.demux(t, -1, !1, !0) : {\n            videoTrack: this._videoTrack,\n            audioTrack: this._audioTrack,\n            id3Track: this._id3Track,\n            textTrack: this._txtTrack\n          }, this.extractRemainingSamples(e), this.sampleAes ? this.decrypt(e, this.sampleAes) : e;\n        }, t.extractRemainingSamples = function (e) {\n          var t,\n            r = e.audioTrack,\n            i = e.videoTrack,\n            a = e.id3Track,\n            n = e.textTrack,\n            s = i.pesData,\n            o = r.pesData,\n            l = a.pesData;\n          if (s && (t = qi(s)) ? (this.videoParser.parseAVCPES(i, n, t, !0, this._duration), i.pesData = null) : i.pesData = s, o && (t = qi(o))) {\n            switch (r.segmentCodec) {\n              case \"aac\":\n                this.parseAACPES(r, t);\n                break;\n              case \"mp3\":\n                this.parseMPEGPES(r, t);\n            }\n            r.pesData = null;\n          } else null != o && o.size && k.log(\"last AAC PES packet truncated,might overlap between fragments\"), r.pesData = o;\n          l && (t = qi(l)) ? (this.parseID3PES(a, t), a.pesData = null) : a.pesData = l;\n        }, t.demuxSampleAes = function (e, t, r) {\n          var i = this.demux(e, r, !0, !this.config.progressive),\n            a = this.sampleAes = new Gi(this.observer, this.config, t);\n          return this.decrypt(i, a);\n        }, t.decrypt = function (e, t) {\n          return new Promise(function (r) {\n            var i = e.audioTrack,\n              a = e.videoTrack;\n            i.samples && \"aac\" === i.segmentCodec ? t.decryptAacSamples(i.samples, 0, function () {\n              a.samples ? t.decryptAvcSamples(a.samples, 0, 0, function () {\n                r(e);\n              }) : r(e);\n            }) : a.samples && t.decryptAvcSamples(a.samples, 0, 0, function () {\n              r(e);\n            });\n          });\n        }, t.destroy = function () {\n          this._duration = 0;\n        }, t.parseAACPES = function (e, t) {\n          var r,\n            i,\n            a,\n            n = 0,\n            s = this.aacOverFlow,\n            o = t.data;\n          if (s) {\n            this.aacOverFlow = null;\n            var l = s.missing,\n              u = s.sample.unit.byteLength;\n            if (-1 === l) o = be(s.sample.unit, o);else {\n              var d = u - l;\n              s.sample.unit.set(o.subarray(0, l), d), e.samples.push(s.sample), n = s.missing;\n            }\n          }\n          for (r = n, i = o.length; r < i - 1 && !Ei(o, r); r++);\n          if (r !== n) {\n            var h,\n              f = r < i - 1;\n            h = f ? \"AAC PES did not start with ADTS header,offset:\" + r : \"No ADTS header found in AAC PES\";\n            var c = new Error(h);\n            if (k.warn(\"parsing error: \" + h), this.observer.emit(E.ERROR, E.ERROR, {\n              type: T.MEDIA_ERROR,\n              details: S.FRAG_PARSING_ERROR,\n              fatal: !1,\n              levelRetry: f,\n              error: c,\n              reason: h\n            }), !f) return;\n          }\n          if (Si(e, this.observer, o, r, this.audioCodec), void 0 !== t.pts) a = t.pts;else {\n            if (!s) return void k.warn(\"[tsdemuxer]: AAC PES unknown PTS\");\n            var v = Li(e.samplerate);\n            a = s.sample.pts + v;\n          }\n          for (var g, m = 0; r < i;) {\n            if (r += (g = Ri(e, o, r, a, m)).length, g.missing) {\n              this.aacOverFlow = g;\n              break;\n            }\n            for (m++; r < i - 1 && !Ei(o, r); r++);\n          }\n        }, t.parseMPEGPES = function (e, t) {\n          var r = t.data,\n            i = r.length,\n            a = 0,\n            n = 0,\n            s = t.pts;\n          if (void 0 !== s) {\n            for (; n < i;) if (Ii(r, n)) {\n              var o = xi(e, r, n, s, a);\n              if (!o) break;\n              n += o.length, a++;\n            } else n++;\n          } else k.warn(\"[tsdemuxer]: MPEG PES unknown PTS\");\n        }, t.parseAC3PES = function (e, t) {}, t.parseID3PES = function (e, t) {\n          if (void 0 !== t.pts) {\n            var r = o({}, t, {\n              type: this._videoTrack ? gt : ct,\n              duration: Number.POSITIVE_INFINITY\n            });\n            e.samples.push(r);\n          } else k.warn(\"[tsdemuxer]: ID3 PES unknown PTS\");\n        }, e;\n      }();\n    function Ki(e, t) {\n      return ((31 & e[t + 1]) << 8) + e[t + 2];\n    }\n    function ji(e, t) {\n      return (31 & e[t + 10]) << 8 | e[t + 11];\n    }\n    function Wi(e, t, r, i) {\n      var a = {\n          audioPid: -1,\n          videoPid: -1,\n          id3Pid: -1,\n          segmentVideoCodec: \"avc\",\n          segmentAudioCodec: \"aac\"\n        },\n        n = t + 3 + ((15 & e[t + 1]) << 8 | e[t + 2]) - 4;\n      for (t += 12 + ((15 & e[t + 10]) << 8 | e[t + 11]); t < n;) {\n        var s = Ki(e, t),\n          o = (15 & e[t + 3]) << 8 | e[t + 4];\n        switch (e[t]) {\n          case 207:\n            if (!i) {\n              Yi(\"ADTS AAC\");\n              break;\n            }\n          case 15:\n            -1 === a.audioPid && (a.audioPid = s);\n            break;\n          case 21:\n            -1 === a.id3Pid && (a.id3Pid = s);\n            break;\n          case 219:\n            if (!i) {\n              Yi(\"H.264\");\n              break;\n            }\n          case 27:\n            -1 === a.videoPid && (a.videoPid = s, a.segmentVideoCodec = \"avc\");\n            break;\n          case 3:\n          case 4:\n            r.mpeg || r.mp3 ? -1 === a.audioPid && (a.audioPid = s, a.segmentAudioCodec = \"mp3\") : k.log(\"MPEG audio found, not supported in this browser\");\n            break;\n          case 193:\n            if (!i) {\n              Yi(\"AC-3\");\n              break;\n            }\n          case 129:\n            k.warn(\"AC-3 in M2TS support not included in build\");\n            break;\n          case 6:\n            if (-1 === a.audioPid && o > 0) for (var l = t + 5, u = o; u > 2;) {\n              106 === e[l] && k.warn(\"AC-3 in M2TS support not included in build\");\n              var d = e[l + 1] + 2;\n              l += d, u -= d;\n            }\n            break;\n          case 194:\n          case 135:\n            k.warn(\"Unsupported EC-3 in M2TS found\");\n            break;\n          case 36:\n            k.warn(\"Unsupported HEVC in M2TS found\");\n        }\n        t += o + 5;\n      }\n      return a;\n    }\n    function Yi(e) {\n      k.log(e + \" with AES-128-CBC encryption found in unencrypted stream\");\n    }\n    function qi(e) {\n      var t,\n        r,\n        i,\n        a,\n        n,\n        s = 0,\n        o = e.data;\n      if (!e || 0 === e.size) return null;\n      for (; o[0].length < 19 && o.length > 1;) o[0] = be(o[0], o[1]), o.splice(1, 1);\n      if (1 === ((t = o[0])[0] << 16) + (t[1] << 8) + t[2]) {\n        if ((r = (t[4] << 8) + t[5]) && r > e.size - 6) return null;\n        var l = t[7];\n        192 & l && (a = 536870912 * (14 & t[9]) + 4194304 * (255 & t[10]) + 16384 * (254 & t[11]) + 128 * (255 & t[12]) + (254 & t[13]) / 2, 64 & l ? a - (n = 536870912 * (14 & t[14]) + 4194304 * (255 & t[15]) + 16384 * (254 & t[16]) + 128 * (255 & t[17]) + (254 & t[18]) / 2) > 54e5 && (k.warn(Math.round((a - n) / 9e4) + \"s delta between PTS and DTS, align them\"), a = n) : n = a);\n        var u = (i = t[8]) + 9;\n        if (e.size <= u) return null;\n        e.size -= u;\n        for (var d = new Uint8Array(e.size), h = 0, f = o.length; h < f; h++) {\n          var c = (t = o[h]).byteLength;\n          if (u) {\n            if (u > c) {\n              u -= c;\n              continue;\n            }\n            t = t.subarray(u), c -= u, u = 0;\n          }\n          d.set(t, s), s += c;\n        }\n        return r && (r -= i + 3), {\n          data: d,\n          pts: a,\n          dts: n,\n          len: r\n        };\n      }\n      return null;\n    }\n    var zi = function (e) {\n        function t() {\n          return e.apply(this, arguments) || this;\n        }\n        l(t, e);\n        var r = t.prototype;\n        return r.resetInitSegment = function (t, r, i, a) {\n          e.prototype.resetInitSegment.call(this, t, r, i, a), this._audioTrack = {\n            container: \"audio/mpeg\",\n            type: \"audio\",\n            id: 2,\n            pid: -1,\n            sequenceNumber: 0,\n            segmentCodec: \"mp3\",\n            samples: [],\n            manifestCodec: r,\n            duration: a,\n            inputTimeScale: 9e4,\n            dropped: 0\n          };\n        }, t.probe = function (e) {\n          if (!e) return !1;\n          var t = Y(e, 0),\n            r = (null == t ? void 0 : t.length) || 0;\n          if (t && 11 === e[r] && 119 === e[r + 1] && void 0 !== X(t) && function (e, t) {\n            var r = 0,\n              i = 5;\n            t += i;\n            for (var a = new Uint32Array(1), n = new Uint32Array(1), s = new Uint8Array(1); i > 0;) {\n              s[0] = e[t];\n              var o = Math.min(i, 8),\n                l = 8 - o;\n              n[0] = 4278190080 >>> 24 + l << l, a[0] = (s[0] & n[0]) >> l, r = r ? r << o | a[0] : a[0], t += 1, i -= o;\n            }\n            return r;\n          }(e, r) <= 16) return !1;\n          for (var i = e.length; r < i; r++) if (Pi(e, r)) return k.log(\"MPEG Audio sync word found !\"), !0;\n          return !1;\n        }, r.canParse = function (e, t) {\n          return function (e, t) {\n            return Ci(e, t) && 4 <= e.length - t;\n          }(e, t);\n        }, r.appendFrame = function (e, t, r) {\n          if (null !== this.basePTS) return xi(e, t, r, this.basePTS, this.frameIndex);\n        }, t;\n      }(vi),\n      Xi = function () {\n        function e() {}\n        return e.getSilentFrame = function (e, t) {\n          if (\"mp4a.40.2\" === e) {\n            if (1 === t) return new Uint8Array([0, 200, 0, 128, 35, 128]);\n            if (2 === t) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);\n            if (3 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);\n            if (4 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);\n            if (5 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);\n            if (6 === t) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);\n          } else {\n            if (1 === t) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);\n            if (2 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);\n            if (3 === t) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);\n          }\n        }, e;\n      }(),\n      Qi = Math.pow(2, 32) - 1,\n      Ji = function () {\n        function e() {}\n        return e.init = function () {\n          var t;\n          for (t in e.types = {\n            avc1: [],\n            avcC: [],\n            btrt: [],\n            dinf: [],\n            dref: [],\n            esds: [],\n            ftyp: [],\n            hdlr: [],\n            mdat: [],\n            mdhd: [],\n            mdia: [],\n            mfhd: [],\n            minf: [],\n            moof: [],\n            moov: [],\n            mp4a: [],\n            \".mp3\": [],\n            dac3: [],\n            \"ac-3\": [],\n            mvex: [],\n            mvhd: [],\n            pasp: [],\n            sdtp: [],\n            stbl: [],\n            stco: [],\n            stsc: [],\n            stsd: [],\n            stsz: [],\n            stts: [],\n            tfdt: [],\n            tfhd: [],\n            traf: [],\n            trak: [],\n            trun: [],\n            trex: [],\n            tkhd: [],\n            vmhd: [],\n            smhd: []\n          }, e.types) e.types.hasOwnProperty(t) && (e.types[t] = [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3)]);\n          var r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),\n            i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);\n          e.HDLR_TYPES = {\n            video: r,\n            audio: i\n          };\n          var a = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),\n            n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);\n          e.STTS = e.STSC = e.STCO = n, e.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), e.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), e.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), e.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);\n          var s = new Uint8Array([105, 115, 111, 109]),\n            o = new Uint8Array([97, 118, 99, 49]),\n            l = new Uint8Array([0, 0, 0, 1]);\n          e.FTYP = e.box(e.types.ftyp, s, l, s, o), e.DINF = e.box(e.types.dinf, e.box(e.types.dref, a));\n        }, e.box = function (e) {\n          for (var t = 8, r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++) i[a - 1] = arguments[a];\n          for (var n = i.length, s = n; n--;) t += i[n].byteLength;\n          var o = new Uint8Array(t);\n          for (o[0] = t >> 24 & 255, o[1] = t >> 16 & 255, o[2] = t >> 8 & 255, o[3] = 255 & t, o.set(e, 4), n = 0, t = 8; n < s; n++) o.set(i[n], t), t += i[n].byteLength;\n          return o;\n        }, e.hdlr = function (t) {\n          return e.box(e.types.hdlr, e.HDLR_TYPES[t]);\n        }, e.mdat = function (t) {\n          return e.box(e.types.mdat, t);\n        }, e.mdhd = function (t, r) {\n          r *= t;\n          var i = Math.floor(r / (Qi + 1)),\n            a = Math.floor(r % (Qi + 1));\n          return e.box(e.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, 85, 196, 0, 0]));\n        }, e.mdia = function (t) {\n          return e.box(e.types.mdia, e.mdhd(t.timescale, t.duration), e.hdlr(t.type), e.minf(t));\n        }, e.mfhd = function (t) {\n          return e.box(e.types.mfhd, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t]));\n        }, e.minf = function (t) {\n          return \"audio\" === t.type ? e.box(e.types.minf, e.box(e.types.smhd, e.SMHD), e.DINF, e.stbl(t)) : e.box(e.types.minf, e.box(e.types.vmhd, e.VMHD), e.DINF, e.stbl(t));\n        }, e.moof = function (t, r, i) {\n          return e.box(e.types.moof, e.mfhd(t), e.traf(i, r));\n        }, e.moov = function (t) {\n          for (var r = t.length, i = []; r--;) i[r] = e.trak(t[r]);\n          return e.box.apply(null, [e.types.moov, e.mvhd(t[0].timescale, t[0].duration)].concat(i).concat(e.mvex(t)));\n        }, e.mvex = function (t) {\n          for (var r = t.length, i = []; r--;) i[r] = e.trex(t[r]);\n          return e.box.apply(null, [e.types.mvex].concat(i));\n        }, e.mvhd = function (t, r) {\n          r *= t;\n          var i = Math.floor(r / (Qi + 1)),\n            a = Math.floor(r % (Qi + 1)),\n            n = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);\n          return e.box(e.types.mvhd, n);\n        }, e.sdtp = function (t) {\n          var r,\n            i,\n            a = t.samples || [],\n            n = new Uint8Array(4 + a.length);\n          for (r = 0; r < a.length; r++) i = a[r].flags, n[r + 4] = i.dependsOn << 4 | i.isDependedOn << 2 | i.hasRedundancy;\n          return e.box(e.types.sdtp, n);\n        }, e.stbl = function (t) {\n          return e.box(e.types.stbl, e.stsd(t), e.box(e.types.stts, e.STTS), e.box(e.types.stsc, e.STSC), e.box(e.types.stsz, e.STSZ), e.box(e.types.stco, e.STCO));\n        }, e.avc1 = function (t) {\n          var r,\n            i,\n            a,\n            n = [],\n            s = [];\n          for (r = 0; r < t.sps.length; r++) a = (i = t.sps[r]).byteLength, n.push(a >>> 8 & 255), n.push(255 & a), n = n.concat(Array.prototype.slice.call(i));\n          for (r = 0; r < t.pps.length; r++) a = (i = t.pps[r]).byteLength, s.push(a >>> 8 & 255), s.push(255 & a), s = s.concat(Array.prototype.slice.call(i));\n          var o = e.box(e.types.avcC, new Uint8Array([1, n[3], n[4], n[5], 255, 224 | t.sps.length].concat(n).concat([t.pps.length]).concat(s))),\n            l = t.width,\n            u = t.height,\n            d = t.pixelRatio[0],\n            h = t.pixelRatio[1];\n          return e.box(e.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, 255 & l, u >> 8 & 255, 255 & u, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), o, e.box(e.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), e.box(e.types.pasp, new Uint8Array([d >> 24, d >> 16 & 255, d >> 8 & 255, 255 & d, h >> 24, h >> 16 & 255, h >> 8 & 255, 255 & h])));\n        }, e.esds = function (e) {\n          var t = e.config.length;\n          return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2]));\n        }, e.audioStsd = function (e) {\n          var t = e.samplerate;\n          return new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, t >> 8 & 255, 255 & t, 0, 0]);\n        }, e.mp4a = function (t) {\n          return e.box(e.types.mp4a, e.audioStsd(t), e.box(e.types.esds, e.esds(t)));\n        }, e.mp3 = function (t) {\n          return e.box(e.types[\".mp3\"], e.audioStsd(t));\n        }, e.ac3 = function (t) {\n          return e.box(e.types[\"ac-3\"], e.audioStsd(t), e.box(e.types.dac3, t.config));\n        }, e.stsd = function (t) {\n          return \"audio\" === t.type ? \"mp3\" === t.segmentCodec && \"mp3\" === t.codec ? e.box(e.types.stsd, e.STSD, e.mp3(t)) : \"ac3\" === t.segmentCodec ? e.box(e.types.stsd, e.STSD, e.ac3(t)) : e.box(e.types.stsd, e.STSD, e.mp4a(t)) : e.box(e.types.stsd, e.STSD, e.avc1(t));\n        }, e.tkhd = function (t) {\n          var r = t.id,\n            i = t.duration * t.timescale,\n            a = t.width,\n            n = t.height,\n            s = Math.floor(i / (Qi + 1)),\n            o = Math.floor(i % (Qi + 1));\n          return e.box(e.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, o >> 24, o >> 16 & 255, o >> 8 & 255, 255 & o, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, a >> 8 & 255, 255 & a, 0, 0, n >> 8 & 255, 255 & n, 0, 0]));\n        }, e.traf = function (t, r) {\n          var i = e.sdtp(t),\n            a = t.id,\n            n = Math.floor(r / (Qi + 1)),\n            s = Math.floor(r % (Qi + 1));\n          return e.box(e.types.traf, e.box(e.types.tfhd, new Uint8Array([0, 0, 0, 0, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a])), e.box(e.types.tfdt, new Uint8Array([1, 0, 0, 0, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s])), e.trun(t, i.length + 16 + 20 + 8 + 16 + 8 + 8), i);\n        }, e.trak = function (t) {\n          return t.duration = t.duration || 4294967295, e.box(e.types.trak, e.tkhd(t), e.mdia(t));\n        }, e.trex = function (t) {\n          var r = t.id;\n          return e.box(e.types.trex, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]));\n        }, e.trun = function (t, r) {\n          var i,\n            a,\n            n,\n            s,\n            o,\n            l,\n            u = t.samples || [],\n            d = u.length,\n            h = 12 + 16 * d,\n            f = new Uint8Array(h);\n          for (r += 8 + h, f.set([\"video\" === t.type ? 1 : 0, 0, 15, 1, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, 255 & d, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r], 0), i = 0; i < d; i++) n = (a = u[i]).duration, s = a.size, o = a.flags, l = a.cts, f.set([n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, o.isLeading << 2 | o.dependsOn, o.isDependedOn << 6 | o.hasRedundancy << 4 | o.paddingValue << 1 | o.isNonSync, 61440 & o.degradPrio, 15 & o.degradPrio, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l], 12 + 16 * i);\n          return e.box(e.types.trun, f);\n        }, e.initSegment = function (t) {\n          e.types || e.init();\n          var r = e.moov(t);\n          return be(e.FTYP, r);\n        }, e;\n      }();\n    function $i(e, t) {\n      return void 0 === t && (t = !1), function (e, t, r, i) {\n        void 0 === r && (r = 1), void 0 === i && (i = !1);\n        var a = e * t * r;\n        return i ? Math.round(a) : a;\n      }(e, 1e3, 1 / 9e4, t);\n    }\n    Ji.types = void 0, Ji.HDLR_TYPES = void 0, Ji.STTS = void 0, Ji.STSC = void 0, Ji.STCO = void 0, Ji.STSZ = void 0, Ji.VMHD = void 0, Ji.SMHD = void 0, Ji.STSD = void 0, Ji.FTYP = void 0, Ji.DINF = void 0;\n    var Zi = null,\n      ea = null,\n      ta = function () {\n        function e(e, t, r, i) {\n          if (this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextAvcDts = null, this.nextAudioPts = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.videoTrackConfig = void 0, this.observer = e, this.config = t, this.typeSupported = r, this.ISGenerated = !1, null === Zi) {\n            var a = (navigator.userAgent || \"\").match(/Chrome\\/(\\d+)/i);\n            Zi = a ? parseInt(a[1]) : 0;\n          }\n          if (null === ea) {\n            var n = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n            ea = n ? parseInt(n[1]) : 0;\n          }\n        }\n        var t = e.prototype;\n        return t.destroy = function () {\n          this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;\n        }, t.resetTimeStamp = function (e) {\n          k.log(\"[mp4-remuxer]: initPTS & initDTS reset\"), this._initPTS = this._initDTS = e;\n        }, t.resetNextTimestamp = function () {\n          k.log(\"[mp4-remuxer]: reset next timestamp\"), this.isVideoContiguous = !1, this.isAudioContiguous = !1;\n        }, t.resetInitSegment = function () {\n          k.log(\"[mp4-remuxer]: ISGenerated flag reset\"), this.ISGenerated = !1, this.videoTrackConfig = void 0;\n        }, t.getVideoStartPts = function (e) {\n          var t = !1,\n            r = e.reduce(function (e, r) {\n              var i = r.pts - e;\n              return i < -4294967296 ? (t = !0, ra(e, r.pts)) : i > 0 ? e : r.pts;\n            }, e[0].pts);\n          return t && k.debug(\"PTS rollover detected\"), r;\n        }, t.remux = function (e, t, r, i, a, n, s, o) {\n          var l,\n            u,\n            d,\n            h,\n            f,\n            c,\n            v = a,\n            g = a,\n            m = e.pid > -1,\n            p = t.pid > -1,\n            y = t.samples.length,\n            E = e.samples.length > 0,\n            T = s && y > 0 || y > 1;\n          if ((!m || E) && (!p || T) || this.ISGenerated || s) {\n            if (this.ISGenerated) {\n              var S,\n                L,\n                R,\n                A,\n                b = this.videoTrackConfig;\n              !b || t.width === b.width && t.height === b.height && (null == (S = t.pixelRatio) ? void 0 : S[0]) === (null == (L = b.pixelRatio) ? void 0 : L[0]) && (null == (R = t.pixelRatio) ? void 0 : R[1]) === (null == (A = b.pixelRatio) ? void 0 : A[1]) || this.resetInitSegment();\n            } else d = this.generateIS(e, t, a, n);\n            var D,\n              _ = this.isVideoContiguous,\n              x = -1;\n            if (T && (x = function (e) {\n              for (var t = 0; t < e.length; t++) if (e[t].key) return t;\n              return -1;\n            }(t.samples), !_ && this.config.forceKeyFrameOnDiscontinuity)) if (c = !0, x > 0) {\n              k.warn(\"[mp4-remuxer]: Dropped \" + x + \" out of \" + y + \" video samples due to a missing keyframe\");\n              var w = this.getVideoStartPts(t.samples);\n              t.samples = t.samples.slice(x), t.dropped += x, D = g += (t.samples[0].pts - w) / t.inputTimeScale;\n            } else -1 === x && (k.warn(\"[mp4-remuxer]: No keyframe found out of \" + y + \" video samples\"), c = !1);\n            if (this.ISGenerated) {\n              if (E && T) {\n                var C = this.getVideoStartPts(t.samples),\n                  I = (ra(e.samples[0].pts, C) - C) / t.inputTimeScale;\n                v += Math.max(0, I), g += Math.max(0, -I);\n              }\n              if (E) {\n                if (e.samplerate || (k.warn(\"[mp4-remuxer]: regenerate InitSegment as audio detected\"), d = this.generateIS(e, t, a, n)), u = this.remuxAudio(e, v, this.isAudioContiguous, n, p || T || o === st ? g : void 0), T) {\n                  var P = u ? u.endPTS - u.startPTS : 0;\n                  t.inputTimeScale || (k.warn(\"[mp4-remuxer]: regenerate InitSegment as video detected\"), d = this.generateIS(e, t, a, n)), l = this.remuxVideo(t, g, _, P);\n                }\n              } else T && (l = this.remuxVideo(t, g, _, 0));\n              l && (l.firstKeyFrame = x, l.independent = -1 !== x, l.firstKeyFramePTS = D);\n            }\n          }\n          return this.ISGenerated && this._initPTS && this._initDTS && (r.samples.length && (f = ia(r, a, this._initPTS, this._initDTS)), i.samples.length && (h = aa(i, a, this._initPTS))), {\n            audio: u,\n            video: l,\n            initSegment: d,\n            independent: c,\n            text: h,\n            id3: f\n          };\n        }, t.generateIS = function (e, t, r, i) {\n          var a,\n            n,\n            s,\n            o = e.samples,\n            l = t.samples,\n            u = this.typeSupported,\n            d = {},\n            h = this._initPTS,\n            f = !h || i,\n            c = \"audio/mp4\";\n          if (f && (a = n = 1 / 0), e.config && o.length) {\n            switch (e.timescale = e.samplerate, e.segmentCodec) {\n              case \"mp3\":\n                u.mpeg ? (c = \"audio/mpeg\", e.codec = \"\") : u.mp3 && (e.codec = \"mp3\");\n                break;\n              case \"ac3\":\n                e.codec = \"ac-3\";\n            }\n            d.audio = {\n              id: \"audio\",\n              container: c,\n              codec: e.codec,\n              initSegment: \"mp3\" === e.segmentCodec && u.mpeg ? new Uint8Array(0) : Ji.initSegment([e]),\n              metadata: {\n                channelCount: e.channelCount\n              }\n            }, f && (s = e.inputTimeScale, h && s === h.timescale ? f = !1 : a = n = o[0].pts - Math.round(s * r));\n          }\n          if (t.sps && t.pps && l.length) {\n            if (t.timescale = t.inputTimeScale, d.video = {\n              id: \"main\",\n              container: \"video/mp4\",\n              codec: t.codec,\n              initSegment: Ji.initSegment([t]),\n              metadata: {\n                width: t.width,\n                height: t.height\n              }\n            }, f) if (s = t.inputTimeScale, h && s === h.timescale) f = !1;else {\n              var v = this.getVideoStartPts(l),\n                g = Math.round(s * r);\n              n = Math.min(n, ra(l[0].dts, v) - g), a = Math.min(a, v - g);\n            }\n            this.videoTrackConfig = {\n              width: t.width,\n              height: t.height,\n              pixelRatio: t.pixelRatio\n            };\n          }\n          if (Object.keys(d).length) return this.ISGenerated = !0, f ? (this._initPTS = {\n            baseTime: a,\n            timescale: s\n          }, this._initDTS = {\n            baseTime: n,\n            timescale: s\n          }) : a = s = void 0, {\n            tracks: d,\n            initPTS: a,\n            timescale: s\n          };\n        }, t.remuxVideo = function (e, t, r, i) {\n          var a,\n            n,\n            s = e.inputTimeScale,\n            l = e.samples,\n            u = [],\n            d = l.length,\n            h = this._initPTS,\n            f = this.nextAvcDts,\n            c = 8,\n            v = this.videoSampleDuration,\n            g = Number.POSITIVE_INFINITY,\n            m = Number.NEGATIVE_INFINITY,\n            p = !1;\n          if (!r || null === f) {\n            var y = t * s,\n              L = l[0].pts - ra(l[0].dts, l[0].pts);\n            Zi && null !== f && Math.abs(y - L - f) < 15e3 ? r = !0 : f = y - L;\n          }\n          for (var R = h.baseTime * s / h.timescale, A = 0; A < d; A++) {\n            var b = l[A];\n            b.pts = ra(b.pts - R, f), b.dts = ra(b.dts - R, f), b.dts < l[A > 0 ? A - 1 : A].dts && (p = !0);\n          }\n          p && l.sort(function (e, t) {\n            var r = e.dts - t.dts,\n              i = e.pts - t.pts;\n            return r || i;\n          }), a = l[0].dts;\n          var D = (n = l[l.length - 1].dts) - a,\n            _ = D ? Math.round(D / (d - 1)) : v || e.inputTimeScale / 30;\n          if (r) {\n            var x = a - f,\n              w = x > _,\n              C = x < -1;\n            if ((w || C) && (w ? k.warn(\"AVC: \" + $i(x, !0) + \" ms (\" + x + \"dts) hole between fragments detected at \" + t.toFixed(3)) : k.warn(\"AVC: \" + $i(-x, !0) + \" ms (\" + x + \"dts) overlapping between fragments detected at \" + t.toFixed(3)), !C || f >= l[0].pts || Zi)) {\n              a = f;\n              var I = l[0].pts - x;\n              if (w) l[0].dts = a, l[0].pts = I;else for (var P = 0; P < l.length && !(l[P].dts > I); P++) l[P].dts -= x, l[P].pts -= x;\n              k.log(\"Video: Initial PTS/DTS adjusted: \" + $i(I, !0) + \"/\" + $i(a, !0) + \", delta: \" + $i(x, !0) + \" ms\");\n            }\n          }\n          for (var F = 0, O = 0, M = a = Math.max(0, a), N = 0; N < d; N++) {\n            for (var B = l[N], U = B.units, G = U.length, H = 0, V = 0; V < G; V++) H += U[V].data.length;\n            O += H, F += G, B.length = H, B.dts < M ? (B.dts = M, M += _ / 4 | 0 || 1) : M = B.dts, g = Math.min(B.pts, g), m = Math.max(B.pts, m);\n          }\n          n = l[d - 1].dts;\n          var K,\n            j = O + 4 * F + 8;\n          try {\n            K = new Uint8Array(j);\n          } catch (e) {\n            return void this.observer.emit(E.ERROR, E.ERROR, {\n              type: T.MUX_ERROR,\n              details: S.REMUX_ALLOC_ERROR,\n              fatal: !1,\n              error: e,\n              bytes: j,\n              reason: \"fail allocating video mdat \" + j\n            });\n          }\n          var W = new DataView(K.buffer);\n          W.setUint32(0, j), K.set(Ji.types.mdat, 4);\n          for (var Y = !1, q = Number.POSITIVE_INFINITY, z = Number.POSITIVE_INFINITY, X = Number.NEGATIVE_INFINITY, Q = Number.NEGATIVE_INFINITY, J = 0; J < d; J++) {\n            for (var $ = l[J], Z = $.units, ee = 0, te = 0, re = Z.length; te < re; te++) {\n              var ie = Z[te],\n                ae = ie.data,\n                ne = ie.data.byteLength;\n              W.setUint32(c, ne), c += 4, K.set(ae, c), c += ne, ee += 4 + ne;\n            }\n            var se = void 0;\n            if (J < d - 1) v = l[J + 1].dts - $.dts, se = l[J + 1].pts - $.pts;else {\n              var oe = this.config,\n                le = J > 0 ? $.dts - l[J - 1].dts : _;\n              if (se = J > 0 ? $.pts - l[J - 1].pts : _, oe.stretchShortVideoTrack && null !== this.nextAudioPts) {\n                var ue = Math.floor(oe.maxBufferHole * s),\n                  de = (i ? g + i * s : this.nextAudioPts) - $.pts;\n                de > ue ? ((v = de - le) < 0 ? v = le : Y = !0, k.log(\"[mp4-remuxer]: It is approximately \" + de / 90 + \" ms to the next segment; using duration \" + v / 90 + \" ms for the last video frame.\")) : v = le;\n              } else v = le;\n            }\n            var he = Math.round($.pts - $.dts);\n            q = Math.min(q, v), X = Math.max(X, v), z = Math.min(z, se), Q = Math.max(Q, se), u.push(new na($.key, v, ee, he));\n          }\n          if (u.length) if (Zi) {\n            if (Zi < 70) {\n              var fe = u[0].flags;\n              fe.dependsOn = 2, fe.isNonSync = 0;\n            }\n          } else if (ea && Q - z < X - q && _ / X < .025 && 0 === u[0].cts) {\n            k.warn(\"Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.\");\n            for (var ce = a, ve = 0, ge = u.length; ve < ge; ve++) {\n              var me = ce + u[ve].duration,\n                pe = ce + u[ve].cts;\n              if (ve < ge - 1) {\n                var ye = me + u[ve + 1].cts;\n                u[ve].duration = ye - pe;\n              } else u[ve].duration = ve ? u[ve - 1].duration : _;\n              u[ve].cts = 0, ce = me;\n            }\n          }\n          v = Y || !v ? _ : v, this.nextAvcDts = f = n + v, this.videoSampleDuration = v, this.isVideoContiguous = !0;\n          var Ee = {\n            data1: Ji.moof(e.sequenceNumber++, a, o({}, e, {\n              samples: u\n            })),\n            data2: K,\n            startPTS: g / s,\n            endPTS: (m + v) / s,\n            startDTS: a / s,\n            endDTS: f / s,\n            type: \"video\",\n            hasAudio: !1,\n            hasVideo: !0,\n            nb: u.length,\n            dropped: e.dropped\n          };\n          return e.samples = [], e.dropped = 0, Ee;\n        }, t.getSamplesPerFrame = function (e) {\n          switch (e.segmentCodec) {\n            case \"mp3\":\n              return 1152;\n            case \"ac3\":\n              return 1536;\n            default:\n              return 1024;\n          }\n        }, t.remuxAudio = function (e, t, r, i, a) {\n          var n = e.inputTimeScale,\n            s = n / (e.samplerate ? e.samplerate : n),\n            l = this.getSamplesPerFrame(e),\n            u = l * s,\n            d = this._initPTS,\n            h = \"mp3\" === e.segmentCodec && this.typeSupported.mpeg,\n            f = [],\n            c = void 0 !== a,\n            v = e.samples,\n            g = h ? 0 : 8,\n            m = this.nextAudioPts || -1,\n            p = t * n,\n            y = d.baseTime * n / d.timescale;\n          if (this.isAudioContiguous = r = r || v.length && m > 0 && (i && Math.abs(p - m) < 9e3 || Math.abs(ra(v[0].pts - y, p) - m) < 20 * u), v.forEach(function (e) {\n            e.pts = ra(e.pts - y, p);\n          }), !r || m < 0) {\n            if (v = v.filter(function (e) {\n              return e.pts >= 0;\n            }), !v.length) return;\n            m = 0 === a ? 0 : i && !c ? Math.max(0, p) : v[0].pts;\n          }\n          if (\"aac\" === e.segmentCodec) for (var L = this.config.maxAudioFramesDrift, R = 0, A = m; R < v.length; R++) {\n            var b = v[R],\n              D = b.pts,\n              _ = D - A,\n              x = Math.abs(1e3 * _ / n);\n            if (_ <= -L * u && c) 0 === R && (k.warn(\"Audio frame @ \" + (D / n).toFixed(3) + \"s overlaps nextAudioPts by \" + Math.round(1e3 * _ / n) + \" ms.\"), this.nextAudioPts = m = A = D);else if (_ >= L * u && x < 1e4 && c) {\n              var w = Math.round(_ / u);\n              (A = D - w * u) < 0 && (w--, A += u), 0 === R && (this.nextAudioPts = m = A), k.warn(\"[mp4-remuxer]: Injecting \" + w + \" audio frame @ \" + (A / n).toFixed(3) + \"s due to \" + Math.round(1e3 * _ / n) + \" ms gap.\");\n              for (var C = 0; C < w; C++) {\n                var I = Math.max(A, 0),\n                  P = Xi.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);\n                P || (k.log(\"[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.\"), P = b.unit.subarray()), v.splice(R, 0, {\n                  unit: P,\n                  pts: I\n                }), A += u, R++;\n              }\n            }\n            b.pts = A, A += u;\n          }\n          for (var F, O = null, M = null, N = 0, B = v.length; B--;) N += v[B].unit.byteLength;\n          for (var U = 0, G = v.length; U < G; U++) {\n            var H = v[U],\n              V = H.unit,\n              K = H.pts;\n            if (null !== M) f[U - 1].duration = Math.round((K - M) / s);else {\n              if (r && \"aac\" === e.segmentCodec && (K = m), O = K, !(N > 0)) return;\n              N += g;\n              try {\n                F = new Uint8Array(N);\n              } catch (e) {\n                return void this.observer.emit(E.ERROR, E.ERROR, {\n                  type: T.MUX_ERROR,\n                  details: S.REMUX_ALLOC_ERROR,\n                  fatal: !1,\n                  error: e,\n                  bytes: N,\n                  reason: \"fail allocating audio mdat \" + N\n                });\n              }\n              h || (new DataView(F.buffer).setUint32(0, N), F.set(Ji.types.mdat, 4));\n            }\n            F.set(V, g);\n            var j = V.byteLength;\n            g += j, f.push(new na(!0, l, j, 0)), M = K;\n          }\n          var W = f.length;\n          if (W) {\n            var Y = f[f.length - 1];\n            this.nextAudioPts = m = M + s * Y.duration;\n            var q = h ? new Uint8Array(0) : Ji.moof(e.sequenceNumber++, O / s, o({}, e, {\n              samples: f\n            }));\n            e.samples = [];\n            var z = O / n,\n              X = m / n,\n              Q = {\n                data1: q,\n                data2: F,\n                startPTS: z,\n                endPTS: X,\n                startDTS: z,\n                endDTS: X,\n                type: \"audio\",\n                hasAudio: !0,\n                hasVideo: !1,\n                nb: W\n              };\n            return this.isAudioContiguous = !0, Q;\n          }\n        }, t.remuxEmptyAudio = function (e, t, r, i) {\n          var a = e.inputTimeScale,\n            n = a / (e.samplerate ? e.samplerate : a),\n            s = this.nextAudioPts,\n            o = this._initDTS,\n            l = 9e4 * o.baseTime / o.timescale,\n            u = (null !== s ? s : i.startDTS * a) + l,\n            d = i.endDTS * a + l,\n            h = 1024 * n,\n            f = Math.ceil((d - u) / h),\n            c = Xi.getSilentFrame(e.manifestCodec || e.codec, e.channelCount);\n          if (k.warn(\"[mp4-remuxer]: remux empty Audio\"), c) {\n            for (var v = [], g = 0; g < f; g++) {\n              var m = u + g * h;\n              v.push({\n                unit: c,\n                pts: m,\n                dts: m\n              });\n            }\n            return e.samples = v, this.remuxAudio(e, t, r, !1);\n          }\n          k.trace(\"[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec\");\n        }, e;\n      }();\n    function ra(e, t) {\n      var r;\n      if (null === t) return e;\n      for (r = t < e ? -8589934592 : 8589934592; Math.abs(e - t) > 4294967296;) e += r;\n      return e;\n    }\n    function ia(e, t, r, i) {\n      var a = e.samples.length;\n      if (a) {\n        for (var n = e.inputTimeScale, s = 0; s < a; s++) {\n          var o = e.samples[s];\n          o.pts = ra(o.pts - r.baseTime * n / r.timescale, t * n) / n, o.dts = ra(o.dts - i.baseTime * n / i.timescale, t * n) / n;\n        }\n        var l = e.samples;\n        return e.samples = [], {\n          samples: l\n        };\n      }\n    }\n    function aa(e, t, r) {\n      var i = e.samples.length;\n      if (i) {\n        for (var a = e.inputTimeScale, n = 0; n < i; n++) {\n          var s = e.samples[n];\n          s.pts = ra(s.pts - r.baseTime * a / r.timescale, t * a) / a;\n        }\n        e.samples.sort(function (e, t) {\n          return e.pts - t.pts;\n        });\n        var o = e.samples;\n        return e.samples = [], {\n          samples: o\n        };\n      }\n    }\n    var na = function (e, t, r, i) {\n        this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = t, this.size = r, this.cts = i, this.flags = {\n          isLeading: 0,\n          isDependedOn: 0,\n          hasRedundancy: 0,\n          degradPrio: 0,\n          dependsOn: e ? 2 : 1,\n          isNonSync: e ? 0 : 1\n        };\n      },\n      sa = function () {\n        function e() {\n          this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null;\n        }\n        var t = e.prototype;\n        return t.destroy = function () {}, t.resetTimeStamp = function (e) {\n          this.initPTS = e, this.lastEndTime = null;\n        }, t.resetNextTimestamp = function () {\n          this.lastEndTime = null;\n        }, t.resetInitSegment = function (e, t, r, i) {\n          this.audioCodec = t, this.videoCodec = r, this.generateInitSegment(Re(e, i)), this.emitInitSegment = !0;\n        }, t.generateInitSegment = function (e) {\n          var t = this.audioCodec,\n            r = this.videoCodec;\n          if (null == e || !e.byteLength) return this.initTracks = void 0, void (this.initData = void 0);\n          var i = this.initData = ye(e);\n          i.audio && (t = oa(i.audio, F)), i.video && (r = oa(i.video, O));\n          var a = {};\n          i.audio && i.video ? a.audiovideo = {\n            container: \"video/mp4\",\n            codec: t + \",\" + r,\n            initSegment: e,\n            id: \"main\"\n          } : i.audio ? a.audio = {\n            container: \"audio/mp4\",\n            codec: t,\n            initSegment: e,\n            id: \"audio\"\n          } : i.video ? a.video = {\n            container: \"video/mp4\",\n            codec: r,\n            initSegment: e,\n            id: \"main\"\n          } : k.warn(\"[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.\"), this.initTracks = a;\n        }, t.remux = function (e, t, r, i, a, n) {\n          var s,\n            o,\n            l = this.initPTS,\n            u = this.lastEndTime,\n            d = {\n              audio: void 0,\n              video: void 0,\n              text: i,\n              id3: r,\n              initSegment: void 0\n            };\n          m(u) || (u = this.lastEndTime = a || 0);\n          var h = t.samples;\n          if (null == h || !h.length) return d;\n          var f = {\n              initPTS: void 0,\n              timescale: 1\n            },\n            c = this.initData;\n          if (null != (s = c) && s.length || (this.generateInitSegment(h), c = this.initData), null == (o = c) || !o.length) return k.warn(\"[passthrough-remuxer.ts]: Failed to generate initSegment.\"), d;\n          this.emitInitSegment && (f.tracks = this.initTracks, this.emitInitSegment = !1);\n          var v = function (e, t) {\n              for (var r = 0, i = 0, a = 0, n = me(e, [\"moof\", \"traf\"]), s = 0; s < n.length; s++) {\n                var o = n[s],\n                  l = me(o, [\"tfhd\"])[0],\n                  u = t[fe(l, 4)];\n                if (u) {\n                  var d = u.default,\n                    h = fe(l, 0) | (null == d ? void 0 : d.flags),\n                    f = null == d ? void 0 : d.duration;\n                  8 & h && (f = fe(l, 2 & h ? 12 : 8));\n                  for (var c = u.timescale || 9e4, v = me(o, [\"trun\"]), g = 0; g < v.length; g++) !(r = Ae(v[g])) && f && (r = f * fe(v[g], 4)), u.type === O ? i += r / c : u.type === F && (a += r / c);\n                }\n              }\n              if (0 === i && 0 === a) {\n                for (var p = 1 / 0, y = 0, E = 0, T = me(e, [\"sidx\"]), S = 0; S < T.length; S++) {\n                  var L = pe(T[S]);\n                  if (null != L && L.references) {\n                    p = Math.min(p, L.earliestPresentationTime / L.timescale);\n                    var R = L.references.reduce(function (e, t) {\n                      return e + t.info.duration || 0;\n                    }, 0);\n                    E = (y = Math.max(y, R + L.earliestPresentationTime / L.timescale)) - p;\n                  }\n                }\n                if (E && m(E)) return E;\n              }\n              return i || a;\n            }(h, c),\n            g = function (e, t) {\n              return me(t, [\"moof\", \"traf\"]).reduce(function (t, r) {\n                var i = me(r, [\"tfdt\"])[0],\n                  a = i[0],\n                  n = me(r, [\"tfhd\"]).reduce(function (t, r) {\n                    var n = fe(r, 4),\n                      s = e[n];\n                    if (s) {\n                      var o = fe(i, 4);\n                      if (1 === a) {\n                        if (o === oe) return k.warn(\"[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time\"), t;\n                        o *= oe + 1, o += fe(i, 8);\n                      }\n                      var l = o / (s.timescale || 9e4);\n                      if (m(l) && (null === t || l < t)) return l;\n                    }\n                    return t;\n                  }, null);\n                return null !== n && m(n) && (null === t || n < t) ? n : t;\n              }, null);\n            }(c, h),\n            p = null === g ? a : g;\n          ((function (e, t, r, i) {\n            if (null === e) return !0;\n            var a = Math.max(i, 1),\n              n = t - e.baseTime / e.timescale;\n            return Math.abs(n - r) > a;\n          })(l, p, a, v) || f.timescale !== l.timescale && n) && (f.initPTS = p - a, l && 1 === l.timescale && k.warn(\"Adjusting initPTS by \" + (f.initPTS - l.baseTime)), this.initPTS = l = {\n            baseTime: f.initPTS,\n            timescale: 1\n          });\n          var y = e ? p - l.baseTime / l.timescale : u,\n            E = y + v;\n          !function (e, t, r) {\n            me(t, [\"moof\", \"traf\"]).forEach(function (t) {\n              me(t, [\"tfhd\"]).forEach(function (i) {\n                var a = fe(i, 4),\n                  n = e[a];\n                if (n) {\n                  var s = n.timescale || 9e4;\n                  me(t, [\"tfdt\"]).forEach(function (e) {\n                    var t = e[0],\n                      i = r * s;\n                    if (i) {\n                      var a = fe(e, 4);\n                      if (0 === t) a -= i, ge(e, 4, a = Math.max(a, 0));else {\n                        a *= Math.pow(2, 32), a += fe(e, 8), a -= i, a = Math.max(a, 0);\n                        var n = Math.floor(a / (oe + 1)),\n                          o = Math.floor(a % (oe + 1));\n                        ge(e, 4, n), ge(e, 8, o);\n                      }\n                    }\n                  });\n                }\n              });\n            });\n          }(c, h, l.baseTime / l.timescale), v > 0 ? this.lastEndTime = E : (k.warn(\"Duration parsed from mp4 should be greater than zero\"), this.resetNextTimestamp());\n          var T = !!c.audio,\n            S = !!c.video,\n            L = \"\";\n          T && (L += \"audio\"), S && (L += \"video\");\n          var R = {\n            data1: h,\n            startPTS: y,\n            startDTS: y,\n            endPTS: E,\n            endDTS: E,\n            type: L,\n            hasAudio: T,\n            hasVideo: S,\n            nb: 1,\n            dropped: 0\n          };\n          return d.audio = \"audio\" === R.type ? R : void 0, d.video = \"audio\" !== R.type ? R : void 0, d.initSegment = f, d.id3 = ia(r, a, l, l), i.samples.length && (d.text = aa(i, a, l)), d;\n        }, e;\n      }();\n    function oa(e, t) {\n      var r = null == e ? void 0 : e.codec;\n      if (r && r.length > 4) return r;\n      if (t === F) {\n        if (\"ec-3\" === r || \"ac-3\" === r || \"alac\" === r) return r;\n        if (\"fLaC\" === r || \"Opus\" === r) return Ge(r, !1);\n        var i = \"mp4a.40.5\";\n        return k.info('Parsed audio codec \"' + r + '\" or audio object type not handled. Using \"' + i + '\"'), i;\n      }\n      return k.warn('Unhandled video codec \"' + r + '\"'), \"hvc1\" === r || \"hev1\" === r ? \"hvc1.1.6.L120.90\" : \"av01\" === r ? \"av01.0.04M.08\" : \"avc1.42e01e\";\n    }\n    var la,\n      ua = \"undefined\" != typeof self ? self : void 0;\n    try {\n      la = self.performance.now.bind(self.performance);\n    } catch (e) {\n      k.debug(\"Unable to use Performance API on this environment\"), la = null == ua ? void 0 : ua.Date.now;\n    }\n    var da = [{\n        demux: Mi,\n        remux: sa\n      }, {\n        demux: Vi,\n        remux: ta\n      }, {\n        demux: Fi,\n        remux: ta\n      }, {\n        demux: zi,\n        remux: ta\n      }],\n      ha = function () {\n        function e(e, t, r, i, a) {\n          this.async = !1, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = t, this.config = r, this.vendor = i, this.id = a;\n        }\n        var t = e.prototype;\n        return t.configure = function (e) {\n          this.transmuxConfig = e, this.decrypter && this.decrypter.reset();\n        }, t.push = function (e, t, r, i) {\n          var a = this,\n            n = r.transmuxing;\n          n.executeStart = la();\n          var s = new Uint8Array(e),\n            o = this.currentTransmuxState,\n            l = this.transmuxConfig;\n          i && (this.currentTransmuxState = i);\n          var u = i || o,\n            d = u.contiguous,\n            h = u.discontinuity,\n            f = u.trackSwitch,\n            c = u.accurateTimeOffset,\n            v = u.timeOffset,\n            g = u.initSegmentChange,\n            m = l.audioCodec,\n            p = l.videoCodec,\n            y = l.defaultInitPts,\n            L = l.duration,\n            R = l.initSegmentData,\n            A = function (e, t) {\n              var r = null;\n              return e.byteLength > 0 && null != (null == t ? void 0 : t.key) && null !== t.iv && null != t.method && (r = t), r;\n            }(s, t);\n          if (A && \"AES-128\" === A.method) {\n            var b = this.getDecrypter();\n            if (!b.isSync()) return this.decryptionPromise = b.webCryptoDecrypt(s, A.key.buffer, A.iv.buffer).then(function (e) {\n              var t = a.push(e, null, r);\n              return a.decryptionPromise = null, t;\n            }), this.decryptionPromise;\n            var D = b.softwareDecrypt(s, A.key.buffer, A.iv.buffer);\n            if (r.part > -1 && (D = b.flush()), !D) return n.executeEnd = la(), fa(r);\n            s = new Uint8Array(D);\n          }\n          var _ = this.needsProbing(h, f);\n          if (_) {\n            var x = this.configureTransmuxer(s);\n            if (x) return k.warn(\"[transmuxer] \" + x.message), this.observer.emit(E.ERROR, E.ERROR, {\n              type: T.MEDIA_ERROR,\n              details: S.FRAG_PARSING_ERROR,\n              fatal: !1,\n              error: x,\n              reason: x.message\n            }), n.executeEnd = la(), fa(r);\n          }\n          (h || f || g || _) && this.resetInitSegment(R, m, p, L, t), (h || g || _) && this.resetInitialTimestamp(y), d || this.resetContiguity();\n          var w = this.transmux(s, A, v, c, r),\n            C = this.currentTransmuxState;\n          return C.contiguous = !0, C.discontinuity = !1, C.trackSwitch = !1, n.executeEnd = la(), w;\n        }, t.flush = function (e) {\n          var t = this,\n            r = e.transmuxing;\n          r.executeStart = la();\n          var i = this.decrypter,\n            a = this.currentTransmuxState,\n            n = this.decryptionPromise;\n          if (n) return n.then(function () {\n            return t.flush(e);\n          });\n          var s = [],\n            o = a.timeOffset;\n          if (i) {\n            var l = i.flush();\n            l && s.push(this.push(l, null, e));\n          }\n          var u = this.demuxer,\n            d = this.remuxer;\n          if (!u || !d) return r.executeEnd = la(), [fa(e)];\n          var h = u.flush(o);\n          return ca(h) ? h.then(function (r) {\n            return t.flushRemux(s, r, e), s;\n          }) : (this.flushRemux(s, h, e), s);\n        }, t.flushRemux = function (e, t, r) {\n          var i = t.audioTrack,\n            a = t.videoTrack,\n            n = t.id3Track,\n            s = t.textTrack,\n            o = this.currentTransmuxState,\n            l = o.accurateTimeOffset,\n            u = o.timeOffset;\n          k.log(\"[transmuxer.ts]: Flushed fragment \" + r.sn + (r.part > -1 ? \" p: \" + r.part : \"\") + \" of level \" + r.level);\n          var d = this.remuxer.remux(i, a, n, s, u, l, !0, this.id);\n          e.push({\n            remuxResult: d,\n            chunkMeta: r\n          }), r.transmuxing.executeEnd = la();\n        }, t.resetInitialTimestamp = function (e) {\n          var t = this.demuxer,\n            r = this.remuxer;\n          t && r && (t.resetTimeStamp(e), r.resetTimeStamp(e));\n        }, t.resetContiguity = function () {\n          var e = this.demuxer,\n            t = this.remuxer;\n          e && t && (e.resetContiguity(), t.resetNextTimestamp());\n        }, t.resetInitSegment = function (e, t, r, i, a) {\n          var n = this.demuxer,\n            s = this.remuxer;\n          n && s && (n.resetInitSegment(e, t, r, i), s.resetInitSegment(e, t, r, a));\n        }, t.destroy = function () {\n          this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0);\n        }, t.transmux = function (e, t, r, i, a) {\n          return t && \"SAMPLE-AES\" === t.method ? this.transmuxSampleAes(e, t, r, i, a) : this.transmuxUnencrypted(e, r, i, a);\n        }, t.transmuxUnencrypted = function (e, t, r, i) {\n          var a = this.demuxer.demux(e, t, !1, !this.config.progressive),\n            n = a.audioTrack,\n            s = a.videoTrack,\n            o = a.id3Track,\n            l = a.textTrack;\n          return {\n            remuxResult: this.remuxer.remux(n, s, o, l, t, r, !1, this.id),\n            chunkMeta: i\n          };\n        }, t.transmuxSampleAes = function (e, t, r, i, a) {\n          var n = this;\n          return this.demuxer.demuxSampleAes(e, t, r).then(function (e) {\n            return {\n              remuxResult: n.remuxer.remux(e.audioTrack, e.videoTrack, e.id3Track, e.textTrack, r, i, !1, n.id),\n              chunkMeta: a\n            };\n          });\n        }, t.configureTransmuxer = function (e) {\n          for (var t, r = this.config, i = this.observer, a = this.typeSupported, n = this.vendor, s = 0, o = da.length; s < o; s++) {\n            var l;\n            if (null != (l = da[s].demux) && l.probe(e)) {\n              t = da[s];\n              break;\n            }\n          }\n          if (!t) return new Error(\"Failed to find demuxer by probing fragment data\");\n          var u = this.demuxer,\n            d = this.remuxer,\n            h = t.remux,\n            f = t.demux;\n          d && d instanceof h || (this.remuxer = new h(i, r, a, n)), u && u instanceof f || (this.demuxer = new f(i, r, a), this.probe = f.probe);\n        }, t.needsProbing = function (e, t) {\n          return !this.demuxer || !this.remuxer || e || t;\n        }, t.getDecrypter = function () {\n          var e = this.decrypter;\n          return e || (e = this.decrypter = new $r(this.config)), e;\n        }, e;\n      }(),\n      fa = function (e) {\n        return {\n          remuxResult: {},\n          chunkMeta: e\n        };\n      };\n    function ca(e) {\n      return \"then\" in e && e.then instanceof Function;\n    }\n    var va = function (e, t, r, i, a) {\n        this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = t, this.initSegmentData = r, this.duration = i, this.defaultInitPts = a || null;\n      },\n      ga = function (e, t, r, i, a, n) {\n        this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = t, this.accurateTimeOffset = r, this.trackSwitch = i, this.timeOffset = a, this.initSegmentChange = n;\n      },\n      ma = {\n        exports: {}\n      };\n    !function (e) {\n      var t = Object.prototype.hasOwnProperty,\n        r = \"~\";\n      function i() {}\n      function a(e, t, r) {\n        this.fn = e, this.context = t, this.once = r || !1;\n      }\n      function n(e, t, i, n, s) {\n        if (\"function\" != typeof i) throw new TypeError(\"The listener must be a function\");\n        var o = new a(i, n || e, s),\n          l = r ? r + t : t;\n        return e._events[l] ? e._events[l].fn ? e._events[l] = [e._events[l], o] : e._events[l].push(o) : (e._events[l] = o, e._eventsCount++), e;\n      }\n      function s(e, t) {\n        0 == --e._eventsCount ? e._events = new i() : delete e._events[t];\n      }\n      function o() {\n        this._events = new i(), this._eventsCount = 0;\n      }\n      Object.create && (i.prototype = Object.create(null), new i().__proto__ || (r = !1)), o.prototype.eventNames = function () {\n        var e,\n          i,\n          a = [];\n        if (0 === this._eventsCount) return a;\n        for (i in e = this._events) t.call(e, i) && a.push(r ? i.slice(1) : i);\n        return Object.getOwnPropertySymbols ? a.concat(Object.getOwnPropertySymbols(e)) : a;\n      }, o.prototype.listeners = function (e) {\n        var t = r ? r + e : e,\n          i = this._events[t];\n        if (!i) return [];\n        if (i.fn) return [i.fn];\n        for (var a = 0, n = i.length, s = new Array(n); a < n; a++) s[a] = i[a].fn;\n        return s;\n      }, o.prototype.listenerCount = function (e) {\n        var t = r ? r + e : e,\n          i = this._events[t];\n        return i ? i.fn ? 1 : i.length : 0;\n      }, o.prototype.emit = function (e, t, i, a, n, s) {\n        var o = r ? r + e : e;\n        if (!this._events[o]) return !1;\n        var l,\n          u,\n          d = this._events[o],\n          h = arguments.length;\n        if (d.fn) {\n          switch (d.once && this.removeListener(e, d.fn, void 0, !0), h) {\n            case 1:\n              return d.fn.call(d.context), !0;\n            case 2:\n              return d.fn.call(d.context, t), !0;\n            case 3:\n              return d.fn.call(d.context, t, i), !0;\n            case 4:\n              return d.fn.call(d.context, t, i, a), !0;\n            case 5:\n              return d.fn.call(d.context, t, i, a, n), !0;\n            case 6:\n              return d.fn.call(d.context, t, i, a, n, s), !0;\n          }\n          for (u = 1, l = new Array(h - 1); u < h; u++) l[u - 1] = arguments[u];\n          d.fn.apply(d.context, l);\n        } else {\n          var f,\n            c = d.length;\n          for (u = 0; u < c; u++) switch (d[u].once && this.removeListener(e, d[u].fn, void 0, !0), h) {\n            case 1:\n              d[u].fn.call(d[u].context);\n              break;\n            case 2:\n              d[u].fn.call(d[u].context, t);\n              break;\n            case 3:\n              d[u].fn.call(d[u].context, t, i);\n              break;\n            case 4:\n              d[u].fn.call(d[u].context, t, i, a);\n              break;\n            default:\n              if (!l) for (f = 1, l = new Array(h - 1); f < h; f++) l[f - 1] = arguments[f];\n              d[u].fn.apply(d[u].context, l);\n          }\n        }\n        return !0;\n      }, o.prototype.on = function (e, t, r) {\n        return n(this, e, t, r, !1);\n      }, o.prototype.once = function (e, t, r) {\n        return n(this, e, t, r, !0);\n      }, o.prototype.removeListener = function (e, t, i, a) {\n        var n = r ? r + e : e;\n        if (!this._events[n]) return this;\n        if (!t) return s(this, n), this;\n        var o = this._events[n];\n        if (o.fn) o.fn !== t || a && !o.once || i && o.context !== i || s(this, n);else {\n          for (var l = 0, u = [], d = o.length; l < d; l++) (o[l].fn !== t || a && !o[l].once || i && o[l].context !== i) && u.push(o[l]);\n          u.length ? this._events[n] = 1 === u.length ? u[0] : u : s(this, n);\n        }\n        return this;\n      }, o.prototype.removeAllListeners = function (e) {\n        var t;\n        return e ? (t = r ? r + e : e, this._events[t] && s(this, t)) : (this._events = new i(), this._eventsCount = 0), this;\n      }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = r, o.EventEmitter = o, e.exports = o;\n    }(ma);\n    var pa = c(ma.exports);\n    function ya(e, t) {\n      if (!((r = t.remuxResult).audio || r.video || r.text || r.id3 || r.initSegment)) return !1;\n      var r,\n        i = [],\n        a = t.remuxResult,\n        n = a.audio,\n        s = a.video;\n      return n && Ea(i, n), s && Ea(i, s), e.postMessage({\n        event: \"transmuxComplete\",\n        data: t\n      }, i), !0;\n    }\n    function Ea(e, t) {\n      t.data1 && e.push(t.data1.buffer), t.data2 && e.push(t.data2.buffer);\n    }\n    function Ta(e, t, r) {\n      t.reduce(function (t, r) {\n        return ya(e, r) || t;\n      }, !1) || e.postMessage({\n        event: \"transmuxComplete\",\n        data: t[0]\n      }), e.postMessage({\n        event: \"flush\",\n        data: r\n      });\n    }\n    void 0 !== t && t && function (e) {\n      var t = new pa(),\n        r = function (t, r) {\n          e.postMessage({\n            event: t,\n            data: r\n          });\n        };\n      t.on(E.FRAG_DECRYPTED, r), t.on(E.ERROR, r);\n      var i = function () {\n        var e = function (e) {\n          var t = function (t) {\n            r(\"workerLog\", {\n              logType: e,\n              message: t\n            });\n          };\n          k[e] = t;\n        };\n        for (var t in k) e(t);\n      };\n      e.addEventListener(\"message\", function (a) {\n        var n = a.data;\n        switch (n.cmd) {\n          case \"init\":\n            var s = JSON.parse(n.config);\n            e.transmuxer = new ha(t, n.typeSupported, s, n.vendor, n.id), D(s.debug, n.id), i(), r(\"init\", null);\n            break;\n          case \"configure\":\n            e.transmuxer.configure(n.config);\n            break;\n          case \"demux\":\n            var o = e.transmuxer.push(n.data, n.decryptdata, n.chunkMeta, n.state);\n            ca(o) ? (e.transmuxer.async = !0, o.then(function (t) {\n              ya(e, t);\n            }).catch(function (e) {\n              r(E.ERROR, {\n                type: T.MEDIA_ERROR,\n                details: S.FRAG_PARSING_ERROR,\n                chunkMeta: n.chunkMeta,\n                fatal: !1,\n                error: e,\n                err: e,\n                reason: \"transmuxer-worker push error\"\n              });\n            })) : (e.transmuxer.async = !1, ya(e, o));\n            break;\n          case \"flush\":\n            var l = n.chunkMeta,\n              u = e.transmuxer.flush(l);\n            ca(u) || e.transmuxer.async ? (ca(u) || (u = Promise.resolve(u)), u.then(function (t) {\n              Ta(e, t, l);\n            }).catch(function (e) {\n              r(E.ERROR, {\n                type: T.MEDIA_ERROR,\n                details: S.FRAG_PARSING_ERROR,\n                chunkMeta: n.chunkMeta,\n                fatal: !1,\n                error: e,\n                err: e,\n                reason: \"transmuxer-worker flush error\"\n              });\n            })) : Ta(e, u, l);\n        }\n      });\n    }(self);\n    var Sa = function () {\n        function t(t, r, i, a) {\n          var n = this;\n          this.error = null, this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0;\n          var s = t.config;\n          this.hls = t, this.id = r, this.useWorker = !!s.enableWorker, this.onTransmuxComplete = i, this.onFlush = a;\n          var o = function (e, t) {\n            (t = t || {}).frag = n.frag, t.id = n.id, e === E.ERROR && (n.error = t.error), n.hls.trigger(e, t);\n          };\n          this.observer = new pa(), this.observer.on(E.FRAG_DECRYPTED, o), this.observer.on(E.ERROR, o);\n          var l,\n            u,\n            d,\n            h,\n            f = Ce(s.preferManagedMediaSource) || {\n              isTypeSupported: function () {\n                return !1;\n              }\n            },\n            c = {\n              mpeg: f.isTypeSupported(\"audio/mpeg\"),\n              mp3: f.isTypeSupported('audio/mp4; codecs=\"mp3\"'),\n              ac3: !1\n            },\n            v = navigator.vendor;\n          if (!this.useWorker || \"undefined\" == typeof Worker || (s.workerPath, 0)) this.transmuxer = new ha(this.observer, c, s, v, r);else try {\n            s.workerPath ? (k.log(\"loading Web Worker \" + s.workerPath + ' for \"' + r + '\"'), this.workerContext = (d = s.workerPath, h = new self.URL(d, self.location.href).href, {\n              worker: new self.Worker(h),\n              scriptURL: h\n            })) : (k.log('injecting Web Worker for \"' + r + '\"'), this.workerContext = (l = new self.Blob([\"var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(\" + e.toString() + \")(true);\"], {\n              type: \"text/javascript\"\n            }), u = self.URL.createObjectURL(l), {\n              worker: new self.Worker(u),\n              objectURL: u\n            })), this.onwmsg = function (e) {\n              return n.onWorkerMessage(e);\n            };\n            var g = this.workerContext.worker;\n            g.addEventListener(\"message\", this.onwmsg), g.onerror = function (e) {\n              var t = new Error(e.message + \"  (\" + e.filename + \":\" + e.lineno + \")\");\n              s.enableWorker = !1, k.warn('Error in \"' + r + '\" Web Worker, fallback to inline'), n.hls.trigger(E.ERROR, {\n                type: T.OTHER_ERROR,\n                details: S.INTERNAL_EXCEPTION,\n                fatal: !1,\n                event: \"demuxerWorker\",\n                error: t\n              });\n            }, g.postMessage({\n              cmd: \"init\",\n              typeSupported: c,\n              vendor: v,\n              id: r,\n              config: JSON.stringify(s)\n            });\n          } catch (e) {\n            k.warn('Error setting up \"' + r + '\" Web Worker, fallback to inline', e), this.resetWorker(), this.error = null, this.transmuxer = new ha(this.observer, c, s, v, r);\n          }\n        }\n        var r = t.prototype;\n        return r.resetWorker = function () {\n          if (this.workerContext) {\n            var e = this.workerContext,\n              t = e.worker,\n              r = e.objectURL;\n            r && self.URL.revokeObjectURL(r), t.removeEventListener(\"message\", this.onwmsg), t.onerror = null, t.terminate(), this.workerContext = null;\n          }\n        }, r.destroy = function () {\n          if (this.workerContext) this.resetWorker(), this.onwmsg = void 0;else {\n            var e = this.transmuxer;\n            e && (e.destroy(), this.transmuxer = null);\n          }\n          var t = this.observer;\n          t && t.removeAllListeners(), this.frag = null, this.observer = null, this.hls = null;\n        }, r.push = function (e, t, r, i, a, n, s, o, l, u) {\n          var d,\n            h,\n            f = this;\n          l.transmuxing.start = self.performance.now();\n          var c = this.transmuxer,\n            v = n ? n.start : a.start,\n            g = a.decryptdata,\n            m = this.frag,\n            p = !(m && a.cc === m.cc),\n            y = !(m && l.level === m.level),\n            E = m ? l.sn - m.sn : -1,\n            T = this.part ? l.part - this.part.index : -1,\n            S = 0 === E && l.id > 1 && l.id === (null == m ? void 0 : m.stats.chunkCount),\n            L = !y && (1 === E || 0 === E && (1 === T || S && T <= 0)),\n            R = self.performance.now();\n          (y || E || 0 === a.stats.parsing.start) && (a.stats.parsing.start = R), !n || !T && L || (n.stats.parsing.start = R);\n          var A = !(m && (null == (d = a.initSegment) ? void 0 : d.url) === (null == (h = m.initSegment) ? void 0 : h.url)),\n            b = new ga(p, L, o, y, v, A);\n          if (!L || p || A) {\n            k.log(\"[transmuxer-interface, \" + a.type + \"]: Starting new transmux session for sn: \" + l.sn + \" p: \" + l.part + \" level: \" + l.level + \" id: \" + l.id + \"\\n        discontinuity: \" + p + \"\\n        trackSwitch: \" + y + \"\\n        contiguous: \" + L + \"\\n        accurateTimeOffset: \" + o + \"\\n        timeOffset: \" + v + \"\\n        initSegmentChange: \" + A);\n            var D = new va(r, i, t, s, u);\n            this.configureTransmuxer(D);\n          }\n          if (this.frag = a, this.part = n, this.workerContext) this.workerContext.worker.postMessage({\n            cmd: \"demux\",\n            data: e,\n            decryptdata: g,\n            chunkMeta: l,\n            state: b\n          }, e instanceof ArrayBuffer ? [e] : []);else if (c) {\n            var _ = c.push(e, g, l, b);\n            ca(_) ? (c.async = !0, _.then(function (e) {\n              f.handleTransmuxComplete(e);\n            }).catch(function (e) {\n              f.transmuxerError(e, l, \"transmuxer-interface push error\");\n            })) : (c.async = !1, this.handleTransmuxComplete(_));\n          }\n        }, r.flush = function (e) {\n          var t = this;\n          e.transmuxing.start = self.performance.now();\n          var r = this.transmuxer;\n          if (this.workerContext) this.workerContext.worker.postMessage({\n            cmd: \"flush\",\n            chunkMeta: e\n          });else if (r) {\n            var i = r.flush(e);\n            ca(i) || r.async ? (ca(i) || (i = Promise.resolve(i)), i.then(function (r) {\n              t.handleFlushResult(r, e);\n            }).catch(function (r) {\n              t.transmuxerError(r, e, \"transmuxer-interface flush error\");\n            })) : this.handleFlushResult(i, e);\n          }\n        }, r.transmuxerError = function (e, t, r) {\n          this.hls && (this.error = e, this.hls.trigger(E.ERROR, {\n            type: T.MEDIA_ERROR,\n            details: S.FRAG_PARSING_ERROR,\n            chunkMeta: t,\n            fatal: !1,\n            error: e,\n            err: e,\n            reason: r\n          }));\n        }, r.handleFlushResult = function (e, t) {\n          var r = this;\n          e.forEach(function (e) {\n            r.handleTransmuxComplete(e);\n          }), this.onFlush(t);\n        }, r.onWorkerMessage = function (e) {\n          var t = e.data,\n            r = this.hls;\n          switch (t.event) {\n            case \"init\":\n              var i,\n                a = null == (i = this.workerContext) ? void 0 : i.objectURL;\n              a && self.URL.revokeObjectURL(a);\n              break;\n            case \"transmuxComplete\":\n              this.handleTransmuxComplete(t.data);\n              break;\n            case \"flush\":\n              this.onFlush(t.data);\n              break;\n            case \"workerLog\":\n              k[t.data.logType] && k[t.data.logType](t.data.message);\n              break;\n            default:\n              t.data = t.data || {}, t.data.frag = this.frag, t.data.id = this.id, r.trigger(t.event, t.data);\n          }\n        }, r.configureTransmuxer = function (e) {\n          var t = this.transmuxer;\n          this.workerContext ? this.workerContext.worker.postMessage({\n            cmd: \"configure\",\n            config: e\n          }) : t && t.configure(e);\n        }, r.handleTransmuxComplete = function (e) {\n          e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e);\n        }, t;\n      }(),\n      La = function () {\n        function e(e, t, r, i) {\n          this.config = void 0, this.media = null, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = e, this.media = t, this.fragmentTracker = r, this.hls = i;\n        }\n        var t = e.prototype;\n        return t.destroy = function () {\n          this.media = null, this.hls = this.fragmentTracker = null;\n        }, t.poll = function (e, t) {\n          var r = this.config,\n            i = this.media,\n            a = this.stalled;\n          if (null !== i) {\n            var n = i.currentTime,\n              s = i.seeking,\n              o = this.seeking && !s,\n              l = !this.seeking && s;\n            if (this.seeking = s, n === e) {\n              if (l || o) this.stalled = null;else if (i.paused && !s || i.ended || 0 === i.playbackRate || !or.getBuffered(i).length) this.nudgeRetry = 0;else {\n                var u = or.bufferInfo(i, n, 0),\n                  d = u.nextStart || 0;\n                if (s) {\n                  var h = u.len > 2,\n                    f = !d || t && t.start <= n || d - n > 2 && !this.fragmentTracker.getPartialFragment(n);\n                  if (h || f) return;\n                  this.moved = !1;\n                }\n                if (!this.moved && null !== this.stalled) {\n                  var c;\n                  if (!(u.len > 0 || d)) return;\n                  var v = Math.max(d, u.start || 0) - n,\n                    g = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null,\n                    m = (null == g || null == (c = g.details) ? void 0 : c.live) ? 2 * g.details.targetduration : 2,\n                    p = this.fragmentTracker.getPartialFragment(n);\n                  if (v > 0 && (v <= m || p)) return void (i.paused || this._trySkipBufferHole(p));\n                }\n                var y = self.performance.now();\n                if (null !== a) {\n                  var E = y - a;\n                  if (s || !(E >= 250) || (this._reportStall(u), this.media)) {\n                    var T = or.bufferInfo(i, n, r.maxBufferHole);\n                    this._tryFixBufferStall(T, E);\n                  }\n                } else this.stalled = y;\n              }\n            } else if (this.moved = !0, s || (this.nudgeRetry = 0), null !== a) {\n              if (this.stallReported) {\n                var S = self.performance.now() - a;\n                k.warn(\"playback not stuck anymore @\" + n + \", after \" + Math.round(S) + \"ms\"), this.stallReported = !1;\n              }\n              this.stalled = null;\n            }\n          }\n        }, t._tryFixBufferStall = function (e, t) {\n          var r = this.config,\n            i = this.fragmentTracker,\n            a = this.media;\n          if (null !== a) {\n            var n = a.currentTime,\n              s = i.getPartialFragment(n);\n            if (s && (this._trySkipBufferHole(s) || !this.media)) return;\n            (e.len > r.maxBufferHole || e.nextStart && e.nextStart - n < r.maxBufferHole) && t > 1e3 * r.highBufferWatchdogPeriod && (k.warn(\"Trying to nudge playhead over buffer-hole\"), this.stalled = null, this._tryNudgeBuffer());\n          }\n        }, t._reportStall = function (e) {\n          var t = this.hls,\n            r = this.media;\n          if (!this.stallReported && r) {\n            this.stallReported = !0;\n            var i = new Error(\"Playback stalling at @\" + r.currentTime + \" due to low buffer (\" + JSON.stringify(e) + \")\");\n            k.warn(i.message), t.trigger(E.ERROR, {\n              type: T.MEDIA_ERROR,\n              details: S.BUFFER_STALLED_ERROR,\n              fatal: !1,\n              error: i,\n              buffer: e.len\n            });\n          }\n        }, t._trySkipBufferHole = function (e) {\n          var t = this.config,\n            r = this.hls,\n            i = this.media;\n          if (null === i) return 0;\n          var a = i.currentTime,\n            n = or.bufferInfo(i, a, 0),\n            s = a < n.start ? n.start : n.nextStart;\n          if (s) {\n            var o = n.len <= t.maxBufferHole,\n              l = n.len > 0 && n.len < 1 && i.readyState < 3,\n              u = s - a;\n            if (u > 0 && (o || l)) {\n              if (u > t.maxBufferHole) {\n                var d = this.fragmentTracker,\n                  h = !1;\n                if (0 === a) {\n                  var f = d.getAppendedFrag(0, nt);\n                  f && s < f.end && (h = !0);\n                }\n                if (!h) {\n                  var c = e || d.getAppendedFrag(a, nt);\n                  if (c) {\n                    for (var v = !1, g = c.end; g < s;) {\n                      var m = d.getPartialFragment(g);\n                      if (!m) {\n                        v = !0;\n                        break;\n                      }\n                      g += m.duration;\n                    }\n                    if (v) return 0;\n                  }\n                }\n              }\n              var p = Math.max(s + .05, a + .1);\n              if (k.warn(\"skipping hole, adjusting currentTime from \" + a + \" to \" + p), this.moved = !0, this.stalled = null, i.currentTime = p, e && !e.gap) {\n                var y = new Error(\"fragment loaded with buffer holes, seeking from \" + a + \" to \" + p);\n                r.trigger(E.ERROR, {\n                  type: T.MEDIA_ERROR,\n                  details: S.BUFFER_SEEK_OVER_HOLE,\n                  fatal: !1,\n                  error: y,\n                  reason: y.message,\n                  frag: e\n                });\n              }\n              return p;\n            }\n          }\n          return 0;\n        }, t._tryNudgeBuffer = function () {\n          var e = this.config,\n            t = this.hls,\n            r = this.media,\n            i = this.nudgeRetry;\n          if (null !== r) {\n            var a = r.currentTime;\n            if (this.nudgeRetry++, i < e.nudgeMaxRetry) {\n              var n = a + (i + 1) * e.nudgeOffset,\n                s = new Error(\"Nudging 'currentTime' from \" + a + \" to \" + n);\n              k.warn(s.message), r.currentTime = n, t.trigger(E.ERROR, {\n                type: T.MEDIA_ERROR,\n                details: S.BUFFER_NUDGE_ON_STALL,\n                error: s,\n                fatal: !1\n              });\n            } else {\n              var o = new Error(\"Playhead still not moving while enough data buffered @\" + a + \" after \" + e.nudgeMaxRetry + \" nudges\");\n              k.error(o.message), t.trigger(E.ERROR, {\n                type: T.MEDIA_ERROR,\n                details: S.BUFFER_STALLED_ERROR,\n                error: o,\n                fatal: !0\n              });\n            }\n          }\n        }, e;\n      }(),\n      Ra = function (e) {\n        function t(t, r, i) {\n          var a;\n          return (a = e.call(this, t, r, i, \"[stream-controller]\", nt) || this).audioCodecSwap = !1, a.gapController = null, a.level = -1, a._forceStartLoad = !1, a.altAudio = !1, a.audioOnly = !1, a.fragPlaying = null, a.onvplaying = null, a.onvseeked = null, a.fragLastKbps = 0, a.couldBacktrack = !1, a.backtrackFragment = null, a.audioCodecSwitch = !1, a.videoBuffer = null, a._registerListeners(), a;\n        }\n        l(t, e);\n        var r = t.prototype;\n        return r._registerListeners = function () {\n          var e = this.hls;\n          e.on(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(E.MANIFEST_LOADING, this.onManifestLoading, this), e.on(E.MANIFEST_PARSED, this.onManifestParsed, this), e.on(E.LEVEL_LOADING, this.onLevelLoading, this), e.on(E.LEVEL_LOADED, this.onLevelLoaded, this), e.on(E.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(E.ERROR, this.onError, this), e.on(E.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(E.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(E.BUFFER_CREATED, this.onBufferCreated, this), e.on(E.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(E.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(E.FRAG_BUFFERED, this.onFragBuffered, this);\n        }, r._unregisterListeners = function () {\n          var e = this.hls;\n          e.off(E.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(E.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(E.MANIFEST_LOADING, this.onManifestLoading, this), e.off(E.MANIFEST_PARSED, this.onManifestParsed, this), e.off(E.LEVEL_LOADED, this.onLevelLoaded, this), e.off(E.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(E.ERROR, this.onError, this), e.off(E.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(E.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(E.BUFFER_CREATED, this.onBufferCreated, this), e.off(E.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(E.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(E.FRAG_BUFFERED, this.onFragBuffered, this);\n        }, r.onHandlerDestroying = function () {\n          this._unregisterListeners(), e.prototype.onHandlerDestroying.call(this);\n        }, r.startLoad = function (e) {\n          if (this.levels) {\n            var t = this.lastCurrentTime,\n              r = this.hls;\n            if (this.stopLoad(), this.setInterval(100), this.level = -1, !this.startFragRequested) {\n              var i = r.startLevel;\n              -1 === i && (r.config.testBandwidth && this.levels.length > 1 ? (i = 0, this.bitrateTest = !0) : i = r.firstAutoLevel), r.nextLoadLevel = i, this.level = r.loadLevel, this.loadedmetadata = !1;\n            }\n            t > 0 && -1 === e && (this.log(\"Override startPosition with lastCurrentTime @\" + t.toFixed(3)), e = t), this.state = ti, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick();\n          } else this._forceStartLoad = !0, this.state = ei;\n        }, r.stopLoad = function () {\n          this._forceStartLoad = !1, e.prototype.stopLoad.call(this);\n        }, r.doTick = function () {\n          switch (this.state) {\n            case ui:\n              var e = this.levels,\n                t = this.level,\n                r = null == e ? void 0 : e[t],\n                i = null == r ? void 0 : r.details;\n              if (i && (!i.live || this.levelLastLoaded === r)) {\n                if (this.waitForCdnTuneIn(i)) break;\n                this.state = ti;\n                break;\n              }\n              if (this.hls.nextLoadLevel !== this.level) {\n                this.state = ti;\n                break;\n              }\n              break;\n            case ai:\n              var a,\n                n = self.performance.now(),\n                s = this.retryDate;\n              if (!s || n >= s || null != (a = this.media) && a.seeking) {\n                var o = this.levels,\n                  l = this.level,\n                  u = null == o ? void 0 : o[l];\n                this.resetStartWhenNotLoaded(u || null), this.state = ti;\n              }\n          }\n          this.state === ti && this.doTickIdle(), this.onTickEnd();\n        }, r.onTickEnd = function () {\n          e.prototype.onTickEnd.call(this), this.checkBuffer(), this.checkFragmentChanged();\n        }, r.doTickIdle = function () {\n          var e = this.hls,\n            t = this.levelLastLoaded,\n            r = this.levels,\n            i = this.media,\n            a = e.config,\n            n = e.nextLoadLevel;\n          if (null !== t && (i || !this.startFragRequested && a.startFragPrefetch) && (!this.altAudio || !this.audioOnly) && null != r && r[n]) {\n            var s = r[n],\n              o = this.getMainFwdBufferInfo();\n            if (null !== o) {\n              var l = this.getLevelDetails();\n              if (l && this._streamEnded(o, l)) {\n                var u = {};\n                return this.altAudio && (u.type = \"video\"), this.hls.trigger(E.BUFFER_EOS, u), void (this.state = oi);\n              }\n              e.loadLevel !== n && -1 === e.manualLevel && this.log(\"Adapting to level \" + n + \" from level \" + this.level), this.level = e.nextLoadLevel = n;\n              var d = s.details;\n              if (!d || this.state === ui || d.live && this.levelLastLoaded !== s) return this.level = n, void (this.state = ui);\n              var h = o.len,\n                f = this.getMaxBufferLength(s.maxBitrate);\n              if (!(h >= f)) {\n                this.backtrackFragment && this.backtrackFragment.start > o.end && (this.backtrackFragment = null);\n                var c = this.backtrackFragment ? this.backtrackFragment.start : o.end,\n                  v = this.getNextFragment(c, d);\n                if (this.couldBacktrack && !this.fragPrevious && v && \"initSegment\" !== v.sn && this.fragmentTracker.getState(v) !== Pr) {\n                  var g,\n                    m = (null != (g = this.backtrackFragment) ? g : v).sn - d.startSN,\n                    p = d.fragments[m - 1];\n                  p && v.cc === p.cc && (v = p, this.fragmentTracker.removeFragment(p));\n                } else this.backtrackFragment && o.len && (this.backtrackFragment = null);\n                if (v && this.isLoopLoading(v, c)) {\n                  if (!v.gap) {\n                    var y = this.audioOnly && !this.altAudio ? F : O,\n                      T = (y === O ? this.videoBuffer : this.mediaBuffer) || this.media;\n                    T && this.afterBufferFlushed(T, y, nt);\n                  }\n                  v = this.getNextFragmentLoopLoading(v, d, o, nt, f);\n                }\n                v && (!v.initSegment || v.initSegment.data || this.bitrateTest || (v = v.initSegment), this.loadFragment(v, s, c));\n              }\n            }\n          }\n        }, r.loadFragment = function (t, r, i) {\n          var a = this.fragmentTracker.getState(t);\n          this.fragCurrent = t, a === wr || a === Ir ? \"initSegment\" === t.sn ? this._loadInitSegment(t, r) : this.bitrateTest ? (this.log(\"Fragment \" + t.sn + \" of level \" + t.level + \" is being downloaded to test bitrate and will not be buffered\"), this._loadBitrateTestFrag(t, r)) : (this.startFragRequested = !0, e.prototype.loadFragment.call(this, t, r, i)) : this.clearTrackerIfNeeded(t);\n        }, r.getBufferedFrag = function (e) {\n          return this.fragmentTracker.getBufferedFrag(e, nt);\n        }, r.followingBufferedFrag = function (e) {\n          return e ? this.getBufferedFrag(e.end + .5) : null;\n        }, r.immediateLevelSwitch = function () {\n          this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n        }, r.nextLevelSwitch = function () {\n          var e = this.levels,\n            t = this.media;\n          if (null != t && t.readyState) {\n            var r,\n              i = this.getAppendedFrag(t.currentTime);\n            i && i.start > 1 && this.flushMainBuffer(0, i.start - 1);\n            var a = this.getLevelDetails();\n            if (null != a && a.live) {\n              var n = this.getMainFwdBufferInfo();\n              if (!n || n.len < 2 * a.targetduration) return;\n            }\n            if (!t.paused && e) {\n              var s = e[this.hls.nextLoadLevel],\n                o = this.fragLastKbps;\n              r = o && this.fragCurrent ? this.fragCurrent.duration * s.maxBitrate / (1e3 * o) + 1 : 0;\n            } else r = 0;\n            var l = this.getBufferedFrag(t.currentTime + r);\n            if (l) {\n              var u = this.followingBufferedFrag(l);\n              if (u) {\n                this.abortCurrentFrag();\n                var d = u.maxStartPTS ? u.maxStartPTS : u.start,\n                  h = u.duration,\n                  f = Math.max(l.end, d + Math.min(Math.max(h - this.config.maxFragLookUpTolerance, h * (this.couldBacktrack ? .5 : .125)), h * (this.couldBacktrack ? .75 : .25)));\n                this.flushMainBuffer(f, Number.POSITIVE_INFINITY);\n              }\n            }\n          }\n        }, r.abortCurrentFrag = function () {\n          var e = this.fragCurrent;\n          switch (this.fragCurrent = null, this.backtrackFragment = null, e && (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.state) {\n            case ri:\n            case ii:\n            case ai:\n            case ni:\n            case si:\n              this.state = ti;\n          }\n          this.nextLoadPosition = this.getLoadPosition();\n        }, r.flushMainBuffer = function (t, r) {\n          e.prototype.flushMainBuffer.call(this, t, r, this.altAudio ? \"video\" : null);\n        }, r.onMediaAttached = function (t, r) {\n          e.prototype.onMediaAttached.call(this, t, r);\n          var i = r.media;\n          this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), i.addEventListener(\"playing\", this.onvplaying), i.addEventListener(\"seeked\", this.onvseeked), this.gapController = new La(this.config, i, this.fragmentTracker, this.hls);\n        }, r.onMediaDetaching = function () {\n          var t = this.media;\n          t && this.onvplaying && this.onvseeked && (t.removeEventListener(\"playing\", this.onvplaying), t.removeEventListener(\"seeked\", this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), e.prototype.onMediaDetaching.call(this);\n        }, r.onMediaPlaying = function () {\n          this.tick();\n        }, r.onMediaSeeked = function () {\n          var e = this.media,\n            t = e ? e.currentTime : null;\n          m(t) && this.log(\"Media seeked to \" + t.toFixed(3));\n          var r = this.getMainFwdBufferInfo();\n          null !== r && 0 !== r.len ? this.tick() : this.warn('Main forward buffer length on \"seeked\" event ' + (r ? r.len : \"empty\") + \")\");\n        }, r.onManifestLoading = function () {\n          this.log(\"Trigger BUFFER_RESET\"), this.hls.trigger(E.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = !1, this.startPosition = this.lastCurrentTime = this.fragLastKbps = 0, this.levels = this.fragPlaying = this.backtrackFragment = this.levelLastLoaded = null, this.altAudio = this.audioOnly = this.startFragRequested = !1;\n        }, r.onManifestParsed = function (e, t) {\n          var r,\n            i,\n            a = !1,\n            n = !1;\n          t.levels.forEach(function (e) {\n            var t = e.audioCodec;\n            t && (a = a || -1 !== t.indexOf(\"mp4a.40.2\"), n = n || -1 !== t.indexOf(\"mp4a.40.5\"));\n          }), this.audioCodecSwitch = a && n && !(\"function\" == typeof (null == (i = hi()) || null == (r = i.prototype) ? void 0 : r.changeType)), this.audioCodecSwitch && this.log(\"Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC\"), this.levels = t.levels, this.startFragRequested = !1;\n        }, r.onLevelLoading = function (e, t) {\n          var r = this.levels;\n          if (r && this.state === ti) {\n            var i = r[t.level];\n            (!i.details || i.details.live && this.levelLastLoaded !== i || this.waitForCdnTuneIn(i.details)) && (this.state = ui);\n          }\n        }, r.onLevelLoaded = function (e, t) {\n          var r,\n            i = this.levels,\n            a = t.level,\n            n = t.details,\n            s = n.totalduration;\n          if (i) {\n            this.log(\"Level \" + a + \" loaded [\" + n.startSN + \",\" + n.endSN + \"]\" + (n.lastPartSn ? \"[part-\" + n.lastPartSn + \"-\" + n.lastPartIndex + \"]\" : \"\") + \", cc [\" + n.startCC + \", \" + n.endCC + \"] duration:\" + s);\n            var o = i[a],\n              l = this.fragCurrent;\n            !l || this.state !== ii && this.state !== ai || l.level !== t.level && l.loader && this.abortCurrentFrag();\n            var u = 0;\n            if (n.live || null != (r = o.details) && r.live) {\n              var d;\n              if (this.checkLiveUpdate(n), n.deltaUpdateFailed) return;\n              u = this.alignPlaylists(n, o.details, null == (d = this.levelLastLoaded) ? void 0 : d.details);\n            }\n            if (o.details = n, this.levelLastLoaded = o, this.hls.trigger(E.LEVEL_UPDATED, {\n              details: n,\n              level: a\n            }), this.state === ui) {\n              if (this.waitForCdnTuneIn(n)) return;\n              this.state = ti;\n            }\n            this.startFragRequested ? n.live && this.synchronizeToLiveEdge(n) : this.setStartPosition(n, u), this.tick();\n          } else this.warn(\"Levels were reset while loading level \" + a);\n        }, r._handleFragmentLoadProgress = function (e) {\n          var t,\n            r = e.frag,\n            i = e.part,\n            a = e.payload,\n            n = this.levels;\n          if (n) {\n            var s = n[r.level],\n              o = s.details;\n            if (!o) return this.warn(\"Dropping fragment \" + r.sn + \" of level \" + r.level + \" after level details were reset\"), void this.fragmentTracker.removeFragment(r);\n            var l = s.videoCodec,\n              u = o.PTSKnown || !o.live,\n              d = null == (t = r.initSegment) ? void 0 : t.data,\n              h = this._getAudioCodec(s),\n              f = this.transmuxer = this.transmuxer || new Sa(this.hls, nt, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)),\n              c = i ? i.index : -1,\n              v = -1 !== c,\n              g = new jr(r.level, r.sn, r.stats.chunkCount, a.byteLength, c, v),\n              m = this.initPTS[r.cc];\n            f.push(a, d, h, l, r, i, o.totalduration, u, g, m);\n          } else this.warn(\"Levels were reset while fragment load was in progress. Fragment \" + r.sn + \" of level \" + r.level + \" will not be buffered\");\n        }, r.onAudioTrackSwitching = function (e, t) {\n          var r = this.altAudio;\n          if (!t.url) {\n            if (this.mediaBuffer !== this.media) {\n              this.log(\"Switching on main audio, use media.buffered to schedule main fragment loading\"), this.mediaBuffer = this.media;\n              var i = this.fragCurrent;\n              i && (this.log(\"Switching to main audio track, cancel main fragment load\"), i.abortRequests(), this.fragmentTracker.removeFragment(i)), this.resetTransmuxer(), this.resetLoadingState();\n            } else this.audioOnly && this.resetTransmuxer();\n            var a = this.hls;\n            r && (a.trigger(E.BUFFER_FLUSHING, {\n              startOffset: 0,\n              endOffset: Number.POSITIVE_INFINITY,\n              type: null\n            }), this.fragmentTracker.removeAllFragments()), a.trigger(E.AUDIO_TRACK_SWITCHED, t);\n          }\n        }, r.onAudioTrackSwitched = function (e, t) {\n          var r = t.id,\n            i = !!this.hls.audioTracks[r].url;\n          if (i) {\n            var a = this.videoBuffer;\n            a && this.mediaBuffer !== a && (this.log(\"Switching on alternate audio, use video.buffered to schedule main fragment loading\"), this.mediaBuffer = a);\n          }\n          this.altAudio = i, this.tick();\n        }, r.onBufferCreated = function (e, t) {\n          var r,\n            i,\n            a = t.tracks,\n            n = !1;\n          for (var s in a) {\n            var o = a[s];\n            if (\"main\" === o.id) {\n              if (i = s, r = o, \"video\" === s) {\n                var l = a[s];\n                l && (this.videoBuffer = l.buffer);\n              }\n            } else n = !0;\n          }\n          n && r ? (this.log(\"Alternate track found, use \" + i + \".buffered to schedule main fragment loading\"), this.mediaBuffer = r.buffer) : this.mediaBuffer = this.media;\n        }, r.onFragBuffered = function (e, t) {\n          var r = t.frag,\n            i = t.part;\n          if (!r || r.type === nt) {\n            if (this.fragContextChanged(r)) return this.warn(\"Fragment \" + r.sn + (i ? \" p: \" + i.index : \"\") + \" of level \" + r.level + \" finished buffering, but was aborted. state: \" + this.state), void (this.state === si && (this.state = ti));\n            var a = i ? i.stats : r.stats;\n            this.fragLastKbps = Math.round(8 * a.total / (a.buffering.end - a.loading.first)), \"initSegment\" !== r.sn && (this.fragPrevious = r), this.fragBufferedComplete(r, i);\n          }\n        }, r.onError = function (e, t) {\n          var r;\n          if (t.fatal) this.state = li;else switch (t.details) {\n            case S.FRAG_GAP:\n            case S.FRAG_PARSING_ERROR:\n            case S.FRAG_DECRYPT_ERROR:\n            case S.FRAG_LOAD_ERROR:\n            case S.FRAG_LOAD_TIMEOUT:\n            case S.KEY_LOAD_ERROR:\n            case S.KEY_LOAD_TIMEOUT:\n              this.onFragmentOrKeyLoadError(nt, t);\n              break;\n            case S.LEVEL_LOAD_ERROR:\n            case S.LEVEL_LOAD_TIMEOUT:\n            case S.LEVEL_PARSING_ERROR:\n              t.levelRetry || this.state !== ui || (null == (r = t.context) ? void 0 : r.type) !== rt || (this.state = ti);\n              break;\n            case S.BUFFER_APPEND_ERROR:\n            case S.BUFFER_FULL_ERROR:\n              if (!t.parent || \"main\" !== t.parent) return;\n              if (t.details === S.BUFFER_APPEND_ERROR) return void this.resetLoadingState();\n              this.reduceLengthAndFlushBuffer(t) && this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n              break;\n            case S.INTERNAL_EXCEPTION:\n              this.recoverWorkerError(t);\n          }\n        }, r.checkBuffer = function () {\n          var e = this.media,\n            t = this.gapController;\n          if (e && t && e.readyState) {\n            if (this.loadedmetadata || !or.getBuffered(e).length) {\n              var r = this.state !== ti ? this.fragCurrent : null;\n              t.poll(this.lastCurrentTime, r);\n            }\n            this.lastCurrentTime = e.currentTime;\n          }\n        }, r.onFragLoadEmergencyAborted = function () {\n          this.state = ti, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tickImmediate();\n        }, r.onBufferFlushed = function (e, t) {\n          var r = t.type;\n          if (r !== F || this.audioOnly && !this.altAudio) {\n            var i = (r === O ? this.videoBuffer : this.mediaBuffer) || this.media;\n            this.afterBufferFlushed(i, r, nt), this.tick();\n          }\n        }, r.onLevelsUpdated = function (e, t) {\n          this.level > -1 && this.fragCurrent && (this.level = this.fragCurrent.level), this.levels = t.levels;\n        }, r.swapAudioCodec = function () {\n          this.audioCodecSwap = !this.audioCodecSwap;\n        }, r.seekToStartPos = function () {\n          var e = this.media;\n          if (e) {\n            var t = e.currentTime,\n              r = this.startPosition;\n            if (r >= 0 && t < r) {\n              if (e.seeking) return void this.log(\"could not seek to \" + r + \", already seeking at \" + t);\n              var i = or.getBuffered(e),\n                a = (i.length ? i.start(0) : 0) - r;\n              a > 0 && (a < this.config.maxBufferHole || a < this.config.maxFragLookUpTolerance) && (this.log(\"adjusting start position by \" + a + \" to match buffer start\"), r += a, this.startPosition = r), this.log(\"seek to target start position \" + r + \" from current time \" + t), e.currentTime = r;\n            }\n          }\n        }, r._getAudioCodec = function (e) {\n          var t = this.config.defaultAudioCodec || e.audioCodec;\n          return this.audioCodecSwap && t && (this.log(\"Swapping audio codec\"), t = -1 !== t.indexOf(\"mp4a.40.5\") ? \"mp4a.40.2\" : \"mp4a.40.5\"), t;\n        }, r._loadBitrateTestFrag = function (e, t) {\n          var r = this;\n          e.bitrateTest = !0, this._doFragLoad(e, t).then(function (i) {\n            var a = r.hls;\n            if (i && !r.fragContextChanged(e)) {\n              t.fragmentError = 0, r.state = ti, r.startFragRequested = !1, r.bitrateTest = !1;\n              var n = e.stats;\n              n.parsing.start = n.parsing.end = n.buffering.start = n.buffering.end = self.performance.now(), a.trigger(E.FRAG_LOADED, i), e.bitrateTest = !1;\n            }\n          });\n        }, r._handleTransmuxComplete = function (e) {\n          var t,\n            r = \"main\",\n            i = this.hls,\n            a = e.remuxResult,\n            n = e.chunkMeta,\n            s = this.getCurrentContext(n);\n          if (s) {\n            var o = s.frag,\n              l = s.part,\n              u = s.level,\n              d = a.video,\n              h = a.text,\n              f = a.id3,\n              c = a.initSegment,\n              v = u.details,\n              g = this.altAudio ? void 0 : a.audio;\n            if (this.fragContextChanged(o)) this.fragmentTracker.removeFragment(o);else {\n              if (this.state = ni, c) {\n                if (null != c && c.tracks) {\n                  var p = o.initSegment || o;\n                  this._bufferInitSegment(u, c.tracks, p, n), i.trigger(E.FRAG_PARSING_INIT_SEGMENT, {\n                    frag: p,\n                    id: r,\n                    tracks: c.tracks\n                  });\n                }\n                var y = c.initPTS,\n                  T = c.timescale;\n                m(y) && (this.initPTS[o.cc] = {\n                  baseTime: y,\n                  timescale: T\n                }, i.trigger(E.INIT_PTS_FOUND, {\n                  frag: o,\n                  id: r,\n                  initPTS: y,\n                  timescale: T\n                }));\n              }\n              if (d && v && \"initSegment\" !== o.sn) {\n                var S = v.fragments[o.sn - 1 - v.startSN],\n                  L = o.sn === v.startSN,\n                  R = !S || o.cc > S.cc;\n                if (!1 !== a.independent) {\n                  var A = d.startPTS,\n                    b = d.endPTS,\n                    D = d.startDTS,\n                    k = d.endDTS;\n                  if (l) l.elementaryStreams[d.type] = {\n                    startPTS: A,\n                    endPTS: b,\n                    startDTS: D,\n                    endDTS: k\n                  };else if (d.firstKeyFrame && d.independent && 1 === n.id && !R && (this.couldBacktrack = !0), d.dropped && d.independent) {\n                    var _ = this.getMainFwdBufferInfo(),\n                      x = (_ ? _.end : this.getLoadPosition()) + this.config.maxBufferHole,\n                      w = d.firstKeyFramePTS ? d.firstKeyFramePTS : A;\n                    if (!L && x < w - this.config.maxBufferHole && !R) return void this.backtrack(o);\n                    R && (o.gap = !0), o.setElementaryStreamInfo(d.type, o.start, b, o.start, k, !0);\n                  } else L && A > 2 && (o.gap = !0);\n                  o.setElementaryStreamInfo(d.type, A, b, D, k), this.backtrackFragment && (this.backtrackFragment = o), this.bufferFragmentData(d, o, l, n, L || R);\n                } else {\n                  if (!L && !R) return void this.backtrack(o);\n                  o.gap = !0;\n                }\n              }\n              if (g) {\n                var C = g.startPTS,\n                  I = g.endPTS,\n                  P = g.startDTS,\n                  O = g.endDTS;\n                l && (l.elementaryStreams[F] = {\n                  startPTS: C,\n                  endPTS: I,\n                  startDTS: P,\n                  endDTS: O\n                }), o.setElementaryStreamInfo(F, C, I, P, O), this.bufferFragmentData(g, o, l, n);\n              }\n              if (v && null != f && null != (t = f.samples) && t.length) {\n                var M = {\n                  id: r,\n                  frag: o,\n                  details: v,\n                  samples: f.samples\n                };\n                i.trigger(E.FRAG_PARSING_METADATA, M);\n              }\n              if (v && h) {\n                var N = {\n                  id: r,\n                  frag: o,\n                  details: v,\n                  samples: h.samples\n                };\n                i.trigger(E.FRAG_PARSING_USERDATA, N);\n              }\n            }\n          } else this.resetWhenMissingContext(n);\n        }, r._bufferInitSegment = function (e, t, r, i) {\n          var a = this;\n          if (this.state === ni) {\n            this.audioOnly = !!t.audio && !t.video, this.altAudio && !this.audioOnly && delete t.audio;\n            var n = t.audio,\n              s = t.video,\n              o = t.audiovideo;\n            if (n) {\n              var l = e.audioCodec,\n                u = navigator.userAgent.toLowerCase();\n              this.audioCodecSwitch && (l && (l = -1 !== l.indexOf(\"mp4a.40.5\") ? \"mp4a.40.2\" : \"mp4a.40.5\"), 1 !== n.metadata.channelCount && -1 === u.indexOf(\"firefox\") && (l = \"mp4a.40.5\")), l && -1 !== l.indexOf(\"mp4a.40.5\") && -1 !== u.indexOf(\"android\") && \"audio/mpeg\" !== n.container && (l = \"mp4a.40.2\", this.log(\"Android: force audio codec to \" + l)), e.audioCodec && e.audioCodec !== l && this.log('Swapping manifest audio codec \"' + e.audioCodec + '\" for \"' + l + '\"'), n.levelCodec = l, n.id = \"main\", this.log(\"Init audio buffer, container:\" + n.container + \", codecs[selected/level/parsed]=[\" + (l || \"\") + \"/\" + (e.audioCodec || \"\") + \"/\" + n.codec + \"]\");\n            }\n            s && (s.levelCodec = e.videoCodec, s.id = \"main\", this.log(\"Init video buffer, container:\" + s.container + \", codecs[level/parsed]=[\" + (e.videoCodec || \"\") + \"/\" + s.codec + \"]\")), o && this.log(\"Init audiovideo buffer, container:\" + o.container + \", codecs[level/parsed]=[\" + e.codecs + \"/\" + o.codec + \"]\"), this.hls.trigger(E.BUFFER_CODECS, t), Object.keys(t).forEach(function (e) {\n              var n = t[e].initSegment;\n              null != n && n.byteLength && a.hls.trigger(E.BUFFER_APPENDING, {\n                type: e,\n                data: n,\n                frag: r,\n                part: null,\n                chunkMeta: i,\n                parent: r.type\n              });\n            }), this.tickImmediate();\n          }\n        }, r.getMainFwdBufferInfo = function () {\n          return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, nt);\n        }, r.backtrack = function (e) {\n          this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = ti;\n        }, r.checkFragmentChanged = function () {\n          var e = this.media,\n            t = null;\n          if (e && e.readyState > 1 && !1 === e.seeking) {\n            var r = e.currentTime;\n            if (or.isBuffered(e, r) ? t = this.getAppendedFrag(r) : or.isBuffered(e, r + .1) && (t = this.getAppendedFrag(r + .1)), t) {\n              this.backtrackFragment = null;\n              var i = this.fragPlaying,\n                a = t.level;\n              i && t.sn === i.sn && i.level === a || (this.fragPlaying = t, this.hls.trigger(E.FRAG_CHANGED, {\n                frag: t\n              }), i && i.level === a || this.hls.trigger(E.LEVEL_SWITCHED, {\n                level: a\n              }));\n            }\n          }\n        }, s(t, [{\n          key: \"nextLevel\",\n          get: function () {\n            var e = this.nextBufferedFrag;\n            return e ? e.level : -1;\n          }\n        }, {\n          key: \"currentFrag\",\n          get: function () {\n            var e = this.media;\n            return e ? this.fragPlaying || this.getAppendedFrag(e.currentTime) : null;\n          }\n        }, {\n          key: \"currentProgramDateTime\",\n          get: function () {\n            var e = this.media;\n            if (e) {\n              var t = e.currentTime,\n                r = this.currentFrag;\n              if (r && m(t) && m(r.programDateTime)) {\n                var i = r.programDateTime + 1e3 * (t - r.start);\n                return new Date(i);\n              }\n            }\n            return null;\n          }\n        }, {\n          key: \"currentLevel\",\n          get: function () {\n            var e = this.currentFrag;\n            return e ? e.level : -1;\n          }\n        }, {\n          key: \"nextBufferedFrag\",\n          get: function () {\n            var e = this.currentFrag;\n            return e ? this.followingBufferedFrag(e) : null;\n          }\n        }, {\n          key: \"forceStartLoad\",\n          get: function () {\n            return this._forceStartLoad;\n          }\n        }]), t;\n      }(di),\n      Aa = function () {\n        function e(t) {\n          void 0 === t && (t = {}), this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this.started = !1, this._emitter = new pa(), this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null, this.triggeringException = void 0, D(t.debug || !1, \"Hls instance\");\n          var r = this.config = function (e, t) {\n            if ((t.liveSyncDurationCount || t.liveMaxLatencyDurationCount) && (t.liveSyncDuration || t.liveMaxLatencyDuration)) throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n            if (void 0 !== t.liveMaxLatencyDurationCount && (void 0 === t.liveSyncDurationCount || t.liveMaxLatencyDurationCount <= t.liveSyncDurationCount)) throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n            if (void 0 !== t.liveMaxLatencyDuration && (void 0 === t.liveSyncDuration || t.liveMaxLatencyDuration <= t.liveSyncDuration)) throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n            var r = Dr(e),\n              a = [\"TimeOut\", \"MaxRetry\", \"RetryDelay\", \"MaxRetryTimeout\"];\n            return [\"manifest\", \"level\", \"frag\"].forEach(function (e) {\n              var i = (\"level\" === e ? \"playlist\" : e) + \"LoadPolicy\",\n                n = void 0 === t[i],\n                s = [];\n              a.forEach(function (a) {\n                var o = e + \"Loading\" + a,\n                  l = t[o];\n                if (void 0 !== l && n) {\n                  s.push(o);\n                  var u = r[i].default;\n                  switch (t[i] = {\n                    default: u\n                  }, a) {\n                    case \"TimeOut\":\n                      u.maxLoadTimeMs = l, u.maxTimeToFirstByteMs = l;\n                      break;\n                    case \"MaxRetry\":\n                      u.errorRetry.maxNumRetry = l, u.timeoutRetry.maxNumRetry = l;\n                      break;\n                    case \"RetryDelay\":\n                      u.errorRetry.retryDelayMs = l, u.timeoutRetry.retryDelayMs = l;\n                      break;\n                    case \"MaxRetryTimeout\":\n                      u.errorRetry.maxRetryDelayMs = l, u.timeoutRetry.maxRetryDelayMs = l;\n                  }\n                }\n              }), s.length && k.warn('hls.js config: \"' + s.join('\", \"') + '\" setting(s) are deprecated, use \"' + i + '\": ' + JSON.stringify(t[i]));\n            }), i(i({}, r), t);\n          }(e.DefaultConfig, t);\n          this.userConfig = t, r.progressive && kr(r);\n          var a = r.abrController,\n            n = r.bufferController,\n            s = r.capLevelController,\n            o = r.errorController,\n            l = r.fpsController,\n            u = new o(this),\n            d = this.abrController = new a(this),\n            h = this.bufferController = new n(this),\n            f = this.capLevelController = new s(this),\n            c = new l(this),\n            v = new dt(this),\n            g = new Tt(this),\n            m = r.contentSteeringController,\n            p = m ? new m(this) : null,\n            y = this.levelController = new _r(this, p),\n            T = new Fr(this),\n            S = new Vr(this.config),\n            L = this.streamController = new Ra(this, T, S);\n          f.setStreamController(L), c.setStreamController(L);\n          var R = [v, y, L];\n          p && R.splice(1, 0, p), this.networkControllers = R;\n          var A = [d, h, f, c, g, T];\n          this.audioTrackController = this.createController(r.audioTrackController, R);\n          var b = r.audioStreamController;\n          b && R.push(new b(this, T, S)), this.subtitleTrackController = this.createController(r.subtitleTrackController, R);\n          var _ = r.subtitleStreamController;\n          _ && R.push(new _(this, T, S)), this.createController(r.timelineController, A), S.emeController = this.emeController = this.createController(r.emeController, A), this.cmcdController = this.createController(r.cmcdController, A), this.latencyController = this.createController(St, A), this.coreComponents = A, R.push(u);\n          var x = u.onErrorOut;\n          \"function\" == typeof x && this.on(E.ERROR, x, u);\n        }\n        e.isMSESupported = function () {\n          return fi();\n        }, e.isSupported = function () {\n          return function () {\n            if (!fi()) return !1;\n            var e = Ce();\n            return \"function\" == typeof (null == e ? void 0 : e.isTypeSupported) && ([\"avc1.42E01E,mp4a.40.2\", \"av01.0.01M.08\", \"vp09.00.50.08\"].some(function (t) {\n              return e.isTypeSupported(Oe(t, \"video\"));\n            }) || [\"mp4a.40.2\", \"fLaC\"].some(function (t) {\n              return e.isTypeSupported(Oe(t, \"audio\"));\n            }));\n          }();\n        }, e.getMediaSource = function () {\n          return Ce();\n        };\n        var t = e.prototype;\n        return t.createController = function (e, t) {\n          if (e) {\n            var r = new e(this);\n            return t && t.push(r), r;\n          }\n          return null;\n        }, t.on = function (e, t, r) {\n          void 0 === r && (r = this), this._emitter.on(e, t, r);\n        }, t.once = function (e, t, r) {\n          void 0 === r && (r = this), this._emitter.once(e, t, r);\n        }, t.removeAllListeners = function (e) {\n          this._emitter.removeAllListeners(e);\n        }, t.off = function (e, t, r, i) {\n          void 0 === r && (r = this), this._emitter.off(e, t, r, i);\n        }, t.listeners = function (e) {\n          return this._emitter.listeners(e);\n        }, t.emit = function (e, t, r) {\n          return this._emitter.emit(e, t, r);\n        }, t.trigger = function (e, t) {\n          if (this.config.debug) return this.emit(e, e, t);\n          try {\n            return this.emit(e, e, t);\n          } catch (t) {\n            if (k.error(\"An internal error happened while handling event \" + e + '. Error message: \"' + t.message + '\". Here is a stacktrace:', t), !this.triggeringException) {\n              this.triggeringException = !0;\n              var r = e === E.ERROR;\n              this.trigger(E.ERROR, {\n                type: T.OTHER_ERROR,\n                details: S.INTERNAL_EXCEPTION,\n                fatal: r,\n                event: e,\n                error: t\n              }), this.triggeringException = !1;\n            }\n          }\n          return !1;\n        }, t.listenerCount = function (e) {\n          return this._emitter.listenerCount(e);\n        }, t.destroy = function () {\n          k.log(\"destroy\"), this.trigger(E.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach(function (e) {\n            return e.destroy();\n          }), this.networkControllers.length = 0, this.coreComponents.forEach(function (e) {\n            return e.destroy();\n          }), this.coreComponents.length = 0;\n          var e = this.config;\n          e.xhrSetup = e.fetchSetup = void 0, this.userConfig = null;\n        }, t.attachMedia = function (e) {\n          k.log(\"attachMedia\"), this._media = e, this.trigger(E.MEDIA_ATTACHING, {\n            media: e\n          });\n        }, t.detachMedia = function () {\n          k.log(\"detachMedia\"), this.trigger(E.MEDIA_DETACHING, void 0), this._media = null;\n        }, t.loadSource = function (e) {\n          this.stopLoad();\n          var t = this.media,\n            r = this.url,\n            i = this.url = g.buildAbsoluteURL(self.location.href, e, {\n              alwaysNormalize: !0\n            });\n          this._autoLevelCapping = -1, this._maxHdcpLevel = null, k.log(\"loadSource:\" + i), t && r && (r !== i || this.bufferController.hasSourceTypes()) && (this.detachMedia(), this.attachMedia(t)), this.trigger(E.MANIFEST_LOADING, {\n            url: e\n          });\n        }, t.startLoad = function (e) {\n          void 0 === e && (e = -1), k.log(\"startLoad(\" + e + \")\"), this.started = !0, this.networkControllers.forEach(function (t) {\n            t.startLoad(e);\n          });\n        }, t.stopLoad = function () {\n          k.log(\"stopLoad\"), this.started = !1, this.networkControllers.forEach(function (e) {\n            e.stopLoad();\n          });\n        }, t.resumeBuffering = function () {\n          this.started && this.networkControllers.forEach(function (e) {\n            \"fragmentLoader\" in e && e.startLoad(-1);\n          });\n        }, t.pauseBuffering = function () {\n          this.networkControllers.forEach(function (e) {\n            \"fragmentLoader\" in e && e.stopLoad();\n          });\n        }, t.swapAudioCodec = function () {\n          k.log(\"swapAudioCodec\"), this.streamController.swapAudioCodec();\n        }, t.recoverMediaError = function () {\n          k.log(\"recoverMediaError\");\n          var e = this._media;\n          this.detachMedia(), e && this.attachMedia(e);\n        }, t.removeLevel = function (e) {\n          this.levelController.removeLevel(e);\n        }, t.setAudioOption = function (e) {\n          var t;\n          return null == (t = this.audioTrackController) ? void 0 : t.setAudioOption(e);\n        }, t.setSubtitleOption = function (e) {\n          var t;\n          return null == (t = this.subtitleTrackController) || t.setSubtitleOption(e), null;\n        }, s(e, [{\n          key: \"levels\",\n          get: function () {\n            var e = this.levelController.levels;\n            return e || [];\n          }\n        }, {\n          key: \"currentLevel\",\n          get: function () {\n            return this.streamController.currentLevel;\n          },\n          set: function (e) {\n            k.log(\"set currentLevel:\" + e), this.levelController.manualLevel = e, this.streamController.immediateLevelSwitch();\n          }\n        }, {\n          key: \"nextLevel\",\n          get: function () {\n            return this.streamController.nextLevel;\n          },\n          set: function (e) {\n            k.log(\"set nextLevel:\" + e), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch();\n          }\n        }, {\n          key: \"loadLevel\",\n          get: function () {\n            return this.levelController.level;\n          },\n          set: function (e) {\n            k.log(\"set loadLevel:\" + e), this.levelController.manualLevel = e;\n          }\n        }, {\n          key: \"nextLoadLevel\",\n          get: function () {\n            return this.levelController.nextLoadLevel;\n          },\n          set: function (e) {\n            this.levelController.nextLoadLevel = e;\n          }\n        }, {\n          key: \"firstLevel\",\n          get: function () {\n            return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n          },\n          set: function (e) {\n            k.log(\"set firstLevel:\" + e), this.levelController.firstLevel = e;\n          }\n        }, {\n          key: \"startLevel\",\n          get: function () {\n            var e = this.levelController.startLevel;\n            return -1 === e && this.abrController.forcedAutoLevel > -1 ? this.abrController.forcedAutoLevel : e;\n          },\n          set: function (e) {\n            k.log(\"set startLevel:\" + e), -1 !== e && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e;\n          }\n        }, {\n          key: \"capLevelToPlayerSize\",\n          get: function () {\n            return this.config.capLevelToPlayerSize;\n          },\n          set: function (e) {\n            var t = !!e;\n            t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t);\n          }\n        }, {\n          key: \"autoLevelCapping\",\n          get: function () {\n            return this._autoLevelCapping;\n          },\n          set: function (e) {\n            this._autoLevelCapping !== e && (k.log(\"set autoLevelCapping:\" + e), this._autoLevelCapping = e, this.levelController.checkMaxAutoUpdated());\n          }\n        }, {\n          key: \"bandwidthEstimate\",\n          get: function () {\n            var e = this.abrController.bwEstimator;\n            return e ? e.getEstimate() : NaN;\n          },\n          set: function (e) {\n            this.abrController.resetEstimator(e);\n          }\n        }, {\n          key: \"ttfbEstimate\",\n          get: function () {\n            var e = this.abrController.bwEstimator;\n            return e ? e.getEstimateTTFB() : NaN;\n          }\n        }, {\n          key: \"maxHdcpLevel\",\n          get: function () {\n            return this._maxHdcpLevel;\n          },\n          set: function (e) {\n            (function (e) {\n              return Lt.indexOf(e) > -1;\n            })(e) && this._maxHdcpLevel !== e && (this._maxHdcpLevel = e, this.levelController.checkMaxAutoUpdated());\n          }\n        }, {\n          key: \"autoLevelEnabled\",\n          get: function () {\n            return -1 === this.levelController.manualLevel;\n          }\n        }, {\n          key: \"manualLevel\",\n          get: function () {\n            return this.levelController.manualLevel;\n          }\n        }, {\n          key: \"minAutoLevel\",\n          get: function () {\n            var e = this.levels,\n              t = this.config.minAutoBitrate;\n            if (!e) return 0;\n            for (var r = e.length, i = 0; i < r; i++) if (e[i].maxBitrate >= t) return i;\n            return 0;\n          }\n        }, {\n          key: \"maxAutoLevel\",\n          get: function () {\n            var e,\n              t = this.levels,\n              r = this.autoLevelCapping,\n              i = this.maxHdcpLevel;\n            if (e = -1 === r && null != t && t.length ? t.length - 1 : r, i) for (var a = e; a--;) {\n              var n = t[a].attrs[\"HDCP-LEVEL\"];\n              if (n && n <= i) return a;\n            }\n            return e;\n          }\n        }, {\n          key: \"firstAutoLevel\",\n          get: function () {\n            return this.abrController.firstAutoLevel;\n          }\n        }, {\n          key: \"nextAutoLevel\",\n          get: function () {\n            return this.abrController.nextAutoLevel;\n          },\n          set: function (e) {\n            this.abrController.nextAutoLevel = e;\n          }\n        }, {\n          key: \"playingDate\",\n          get: function () {\n            return this.streamController.currentProgramDateTime;\n          }\n        }, {\n          key: \"mainForwardBufferInfo\",\n          get: function () {\n            return this.streamController.getMainFwdBufferInfo();\n          }\n        }, {\n          key: \"allAudioTracks\",\n          get: function () {\n            var e = this.audioTrackController;\n            return e ? e.allAudioTracks : [];\n          }\n        }, {\n          key: \"audioTracks\",\n          get: function () {\n            var e = this.audioTrackController;\n            return e ? e.audioTracks : [];\n          }\n        }, {\n          key: \"audioTrack\",\n          get: function () {\n            var e = this.audioTrackController;\n            return e ? e.audioTrack : -1;\n          },\n          set: function (e) {\n            var t = this.audioTrackController;\n            t && (t.audioTrack = e);\n          }\n        }, {\n          key: \"allSubtitleTracks\",\n          get: function () {\n            var e = this.subtitleTrackController;\n            return e ? e.allSubtitleTracks : [];\n          }\n        }, {\n          key: \"subtitleTracks\",\n          get: function () {\n            var e = this.subtitleTrackController;\n            return e ? e.subtitleTracks : [];\n          }\n        }, {\n          key: \"subtitleTrack\",\n          get: function () {\n            var e = this.subtitleTrackController;\n            return e ? e.subtitleTrack : -1;\n          },\n          set: function (e) {\n            var t = this.subtitleTrackController;\n            t && (t.subtitleTrack = e);\n          }\n        }, {\n          key: \"media\",\n          get: function () {\n            return this._media;\n          }\n        }, {\n          key: \"subtitleDisplay\",\n          get: function () {\n            var e = this.subtitleTrackController;\n            return !!e && e.subtitleDisplay;\n          },\n          set: function (e) {\n            var t = this.subtitleTrackController;\n            t && (t.subtitleDisplay = e);\n          }\n        }, {\n          key: \"lowLatencyMode\",\n          get: function () {\n            return this.config.lowLatencyMode;\n          },\n          set: function (e) {\n            this.config.lowLatencyMode = e;\n          }\n        }, {\n          key: \"liveSyncPosition\",\n          get: function () {\n            return this.latencyController.liveSyncPosition;\n          }\n        }, {\n          key: \"latency\",\n          get: function () {\n            return this.latencyController.latency;\n          }\n        }, {\n          key: \"maxLatency\",\n          get: function () {\n            return this.latencyController.maxLatency;\n          }\n        }, {\n          key: \"targetLatency\",\n          get: function () {\n            return this.latencyController.targetLatency;\n          }\n        }, {\n          key: \"drift\",\n          get: function () {\n            return this.latencyController.drift;\n          }\n        }, {\n          key: \"forceStartLoad\",\n          get: function () {\n            return this.streamController.forceStartLoad;\n          }\n        }], [{\n          key: \"version\",\n          get: function () {\n            return \"1.5.4\";\n          }\n        }, {\n          key: \"Events\",\n          get: function () {\n            return E;\n          }\n        }, {\n          key: \"ErrorTypes\",\n          get: function () {\n            return T;\n          }\n        }, {\n          key: \"ErrorDetails\",\n          get: function () {\n            return S;\n          }\n        }, {\n          key: \"DefaultConfig\",\n          get: function () {\n            return e.defaultConfig ? e.defaultConfig : br;\n          },\n          set: function (t) {\n            e.defaultConfig = t;\n          }\n        }]), e;\n      }();\n    return Aa.defaultConfig = void 0, Aa;\n  },  true ? module.exports = i() : 0;\n}(!1);\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/hls.js/dist/hls.light.min.js?");

/***/ }),

/***/ "./node_modules/sdp/sdp.js":
/*!*********************************!*\
  !*** ./node_modules/sdp/sdp.js ***!
  \*********************************/
/***/ ((module) => {

"use strict";
eval("/* eslint-env node */\n\n\n// SDP helpers.\nconst SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function () {\n  return Math.random().toString(36).substring(2, 12);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function (blob) {\n  return blob.trim().split('\\n').map(line => line.trim());\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function (blob) {\n  const parts = blob.split('\\nm=');\n  return parts.map((part, index) => (index > 0 ? 'm=' + part : part).trim() + '\\r\\n');\n};\n\n// Returns the session description.\nSDPUtils.getDescription = function (blob) {\n  const sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// Returns the individual media sections.\nSDPUtils.getMediaSections = function (blob) {\n  const sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function (blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\n// Input can be prefixed with a=.\nSDPUtils.parseCandidate = function (line) {\n  let parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n  const candidate = {\n    foundation: parts[0],\n    component: {\n      1: 'rtp',\n      2: 'rtcp'\n    }[parts[1]] || parts[1],\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    address: parts[4],\n    // address is an alias for ip.\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7]\n  };\n  for (let i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compatibility.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default:\n        // extension handling, in particular ufrag. Don't overwrite.\n        if (candidate[parts[i]] === undefined) {\n          candidate[parts[i]] = parts[i + 1];\n        }\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\n// This does not include the a= prefix!\nSDPUtils.writeCandidate = function (candidate) {\n  const sdp = [];\n  sdp.push(candidate.foundation);\n  const component = candidate.component;\n  if (component === 'rtp') {\n    sdp.push(1);\n  } else if (component === 'rtcp') {\n    sdp.push(2);\n  } else {\n    sdp.push(component);\n  }\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.address || candidate.ip);\n  sdp.push(candidate.port);\n  const type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// Sample input:\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function (line) {\n  return line.substring(14).split(' ');\n};\n\n// Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function (line) {\n  let parts = line.substring(9).split(' ');\n  const parsed = {\n    payloadType: parseInt(parts.shift(), 10) // was: id\n  };\n  parts = parts[0].split('/');\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  // legacy alias, got renamed back to channels in ORTC.\n  parsed.numChannels = parsed.channels;\n  return parsed;\n};\n\n// Generates a rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function (codec) {\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  const channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n};\n\n// Parses a extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function (line) {\n  const parts = line.substring(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1],\n    attributes: parts.slice(2).join(' ')\n  };\n};\n\n// Generates an extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function (headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + (headerExtension.attributes ? ' ' + headerExtension.attributes : '') + '\\r\\n';\n};\n\n// Parses a fmtp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function (line) {\n  const parsed = {};\n  let kv;\n  const parts = line.substring(line.indexOf(' ') + 1).split(';');\n  for (let j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function (codec) {\n  let line = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    const params = [];\n    Object.keys(codec.parameters).forEach(param => {\n      if (codec.parameters[param] !== undefined) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function (line) {\n  const parts = line.substring(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' ')\n  };\n};\n\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function (codec) {\n  let lines = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(fb => {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses a RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function (line) {\n  const sp = line.indexOf(' ');\n  const parts = {\n    ssrc: parseInt(line.substring(7, sp), 10)\n  };\n  const colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substring(sp + 1, colon);\n    parts.value = line.substring(colon + 1);\n  } else {\n    parts.attribute = line.substring(sp + 1);\n  }\n  return parts;\n};\n\n// Parse a ssrc-group line (see RFC 5576). Sample input:\n// a=ssrc-group:semantics 12 34\nSDPUtils.parseSsrcGroup = function (line) {\n  const parts = line.substring(13).split(' ');\n  return {\n    semantics: parts.shift(),\n    ssrcs: parts.map(ssrc => parseInt(ssrc, 10))\n  };\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// Returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function (mediaSection) {\n  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substring(6);\n  }\n};\n\n// Parses a fingerprint line for DTLS-SRTP.\nSDPUtils.parseFingerprint = function (line) {\n  const parts = line.substring(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(),\n    // algorithm is case-sensitive in Edge.\n    value: parts[1].toUpperCase() // the definition is upper-case in RFC 4572.\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint)\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function (params, setupType) {\n  let sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(fp => {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n\n// Parses a=crypto lines into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\nSDPUtils.parseCryptoLine = function (line) {\n  const parts = line.substring(9).split(' ');\n  return {\n    tag: parseInt(parts[0], 10),\n    cryptoSuite: parts[1],\n    keyParams: parts[2],\n    sessionParams: parts.slice(3)\n  };\n};\nSDPUtils.writeCryptoLine = function (parameters) {\n  return 'a=crypto:' + parameters.tag + ' ' + parameters.cryptoSuite + ' ' + (typeof parameters.keyParams === 'object' ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') + '\\r\\n';\n};\n\n// Parses the crypto key parameters into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\nSDPUtils.parseCryptoKeyParams = function (keyParams) {\n  if (keyParams.indexOf('inline:') !== 0) {\n    return null;\n  }\n  const parts = keyParams.substring(7).split('|');\n  return {\n    keyMethod: 'inline',\n    keySalt: parts[0],\n    lifeTime: parts[1],\n    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined\n  };\n};\nSDPUtils.writeCryptoKeyParams = function (keyParams) {\n  return keyParams.keyMethod + ':' + keyParams.keySalt + (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') + (keyParams.mkiValue && keyParams.mkiLength ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength : '');\n};\n\n// Extracts all SDES parameters.\nSDPUtils.getCryptoParameters = function (mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=crypto:');\n  return lines.map(SDPUtils.parseCryptoLine);\n};\n\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function (mediaSection, sessionpart) {\n  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-ufrag:')[0];\n  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=ice-pwd:')[0];\n  if (!(ufrag && pwd)) {\n    return null;\n  }\n  return {\n    usernameFragment: ufrag.substring(12),\n    password: pwd.substring(10)\n  };\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function (params) {\n  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' + 'a=ice-pwd:' + params.password + '\\r\\n';\n  if (params.iceLite) {\n    sdp += 'a=ice-lite\\r\\n';\n  }\n  return sdp;\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function (mediaSection) {\n  const description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: []\n  };\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  description.profile = mline[2];\n  for (let i = 3; i < mline.length; i++) {\n    // find all codecs from mline[3..]\n    const pt = mline[i];\n    const rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      const codec = SDPUtils.parseRtpMap(rtpmapline);\n      const fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default:\n          // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:* ').map(SDPUtils.parseRtcpFb);\n  description.codecs.forEach(codec => {\n    wildcardRtcpFb.forEach(fb => {\n      const duplicate = codec.rtcpFeedback.find(existingFeedback => {\n        return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;\n      });\n      if (!duplicate) {\n        codec.rtcpFeedback.push(fb);\n      }\n    });\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function (kind, caps) {\n  let sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' ' + (caps.profile || 'UDP/TLS/RTP/SAVPF') + ' ';\n  sdp += caps.codecs.map(codec => {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(codec => {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  let maxptime = 0;\n  caps.codecs.forEach(codec => {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(extension => {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  }\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function (mediaSection) {\n  const encodingParameters = [];\n  const description = SDPUtils.parseRtpParameters(mediaSection);\n  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(parts => parts.attribute === 'cname');\n  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  let secondarySsrc;\n  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map(line => {\n    const parts = line.substring(17).split(' ');\n    return parts.map(part => parseInt(part, 10));\n  });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n  description.codecs.forEach(codec => {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      let encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10)\n      };\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {\n          ssrc: secondarySsrc\n        };\n      }\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: primarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substring(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(params => {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function (mediaSection) {\n  const rtcpParameters = {};\n\n  // Gets the first SSRC. Note that with RTX there might be multiple\n  // SSRCs.\n  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(obj => obj.attribute === 'cname')[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrbute.\n  // Note that Edge does not support unmuxed RTCP.\n  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n  return rtcpParameters;\n};\nSDPUtils.writeRtcpParameters = function (rtcpParameters) {\n  let sdp = '';\n  if (rtcpParameters.reducedSize) {\n    sdp += 'a=rtcp-rsize\\r\\n';\n  }\n  if (rtcpParameters.mux) {\n    sdp += 'a=rtcp-mux\\r\\n';\n  }\n  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n    sdp += 'a=ssrc:' + rtcpParameters.ssrc + ' cname:' + rtcpParameters.cname + '\\r\\n';\n  }\n  return sdp;\n};\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function (mediaSection) {\n  let parts;\n  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substring(7).split(' ');\n    return {\n      stream: parts[0],\n      track: parts[1]\n    };\n  }\n  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(line => SDPUtils.parseSsrcMedia(line)).filter(msidParts => msidParts.attribute === 'msid');\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {\n      stream: parts[0],\n      track: parts[1]\n    };\n  }\n};\n\n// SCTP\n// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n// to draft-ietf-mmusic-sctp-sdp-05\nSDPUtils.parseSctpDescription = function (mediaSection) {\n  const mline = SDPUtils.parseMLine(mediaSection);\n  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n  let maxMessageSize;\n  if (maxSizeLine.length > 0) {\n    maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\n  }\n  if (isNaN(maxMessageSize)) {\n    maxMessageSize = 65536;\n  }\n  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n  if (sctpPort.length > 0) {\n    return {\n      port: parseInt(sctpPort[0].substring(12), 10),\n      protocol: mline.fmt,\n      maxMessageSize\n    };\n  }\n  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n  if (sctpMapLines.length > 0) {\n    const parts = sctpMapLines[0].substring(10).split(' ');\n    return {\n      port: parseInt(parts[0], 10),\n      protocol: parts[1],\n      maxMessageSize\n    };\n  }\n};\n\n// SCTP\n// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n// support by now receiving in this format, unless we originally parsed\n// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n// protocol of DTLS/SCTP -- without UDP/ or TCP/)\nSDPUtils.writeSctpDescription = function (media, sctp) {\n  let output = [];\n  if (media.protocol !== 'DTLS/SCTP') {\n    output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctp-port:' + sctp.port + '\\r\\n'];\n  } else {\n    output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n', 'c=IN IP4 0.0.0.0\\r\\n', 'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n'];\n  }\n  if (sctp.maxMessageSize !== undefined) {\n    output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n  }\n  return output.join('');\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function () {\n  return Math.random().toString().substr(2, 22);\n};\n\n// Write boiler plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\n// sessUser is optional and defaults to 'thisisadapterortc'\nSDPUtils.writeSessionBoilerplate = function (sessId, sessVer, sessUser) {\n  let sessionId;\n  const version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  const user = sessUser || 'thisisadapterortc';\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' + 'o=' + user + ' ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\\r\\n' + 's=-\\r\\n' + 't=0 0\\r\\n';\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function (mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  const lines = SDPUtils.splitLines(mediaSection);\n  for (let i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substring(2);\n      default:\n      // FIXME: What should happen here?\n    }\n  }\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\nSDPUtils.getKind = function (mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  return mline[0].substring(2);\n};\nSDPUtils.isRejected = function (mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\nSDPUtils.parseMLine = function (mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const parts = lines[0].substring(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' ')\n  };\n};\nSDPUtils.parseOLine = function (mediaSection) {\n  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  const parts = line.substring(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5]\n  };\n};\n\n// a very naive interpretation of a valid SDP.\nSDPUtils.isValidSDP = function (blob) {\n  if (typeof blob !== 'string' || blob.length === 0) {\n    return false;\n  }\n  const lines = SDPUtils.splitLines(blob);\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n      return false;\n    }\n    // TODO: check the modifier a bit more.\n  }\n  return true;\n};\n\n// Expose public methods.\nif (true) {\n  module.exports = SDPUtils;\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/sdp/sdp.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/adapter_core.js":
/*!************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/adapter_core.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _adapter_factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapter_factory.js */ \"./node_modules/webrtc-adapter/src/js/adapter_factory.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\nconst adapter = (0,_adapter_factory_js__WEBPACK_IMPORTED_MODULE_0__.adapterFactory)({\n  window: typeof window === 'undefined' ? undefined : window\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (adapter);\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/adapter_core.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/adapter_factory.js":
/*!***************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/adapter_factory.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adapterFactory: () => (/* binding */ adapterFactory)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/* harmony import */ var _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chrome/chrome_shim */ \"./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js\");\n/* harmony import */ var _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./firefox/firefox_shim */ \"./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js\");\n/* harmony import */ var _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./safari/safari_shim */ \"./node_modules/webrtc-adapter/src/js/safari/safari_shim.js\");\n/* harmony import */ var _common_shim__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./common_shim */ \"./node_modules/webrtc-adapter/src/js/common_shim.js\");\n/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! sdp */ \"./node_modules/sdp/sdp.js\");\n/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(sdp__WEBPACK_IMPORTED_MODULE_5__);\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n\n// Browser shims.\n\n\n\n\n\n\n// Shimming starts here.\nfunction adapterFactory() {\n  let {\n    window\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    shimChrome: true,\n    shimFirefox: true,\n    shimSafari: true\n  };\n  // Utils.\n  const logging = _utils__WEBPACK_IMPORTED_MODULE_0__.log;\n  const browserDetails = _utils__WEBPACK_IMPORTED_MODULE_0__.detectBrowser(window);\n  const adapter = {\n    browserDetails,\n    commonShim: _common_shim__WEBPACK_IMPORTED_MODULE_4__,\n    extractVersion: _utils__WEBPACK_IMPORTED_MODULE_0__.extractVersion,\n    disableLog: _utils__WEBPACK_IMPORTED_MODULE_0__.disableLog,\n    disableWarnings: _utils__WEBPACK_IMPORTED_MODULE_0__.disableWarnings,\n    // Expose sdp as a convenience. For production apps include directly.\n    sdp: sdp__WEBPACK_IMPORTED_MODULE_5__\n  };\n\n  // Shim browser if found.\n  switch (browserDetails.browser) {\n    case 'chrome':\n      if (!_chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__ || !_chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimPeerConnection || !options.shimChrome) {\n        logging('Chrome shim is not included in this adapter release.');\n        return adapter;\n      }\n      if (browserDetails.version === null) {\n        logging('Chrome shim can not determine version, not shimming.');\n        return adapter;\n      }\n      logging('adapter.js shimming chrome.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__;\n\n      // Must be called before shimPeerConnection.\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimMediaStream(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimPeerConnection(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimOnTrack(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimAddTrackRemoveTrack(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimGetSendersWithDtmf(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimGetStats(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimSenderReceiverGetStats(window, browserDetails);\n      _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.fixNegotiationNeeded(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidateRelayProtocol(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimConnectionState(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.removeExtmapAllowMixed(window, browserDetails);\n      break;\n    case 'firefox':\n      if (!_firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__ || !_firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimPeerConnection || !options.shimFirefox) {\n        logging('Firefox shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming firefox.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__;\n\n      // Must be called before shimPeerConnection.\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimGetUserMedia(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimPeerConnection(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimOnTrack(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimRemoveStream(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimSenderGetStats(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimReceiverGetStats(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimRTCDataChannel(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimAddTransceiver(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimGetParameters(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimCreateOffer(window, browserDetails);\n      _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimCreateAnswer(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimConnectionState(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);\n      break;\n    case 'safari':\n      if (!_safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__ || !options.shimSafari) {\n        logging('Safari shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming safari.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__;\n\n      // Must be called before shimCallbackAPI.\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimRTCIceServerUrls(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimCreateOfferLegacy(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimCallbacksAPI(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimLocalStreamsAPI(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimRemoteStreamsAPI(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimTrackEventTransceiver(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimGetUserMedia(window, browserDetails);\n      _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimAudioContext(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidateRelayProtocol(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);\n      _common_shim__WEBPACK_IMPORTED_MODULE_4__.removeExtmapAllowMixed(window, browserDetails);\n      break;\n    default:\n      logging('Unsupported browser!');\n      break;\n  }\n  return adapter;\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/adapter_factory.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fixNegotiationNeeded: () => (/* binding */ fixNegotiationNeeded),\n/* harmony export */   shimAddTrackRemoveTrack: () => (/* binding */ shimAddTrackRemoveTrack),\n/* harmony export */   shimAddTrackRemoveTrackWithNative: () => (/* binding */ shimAddTrackRemoveTrackWithNative),\n/* harmony export */   shimGetDisplayMedia: () => (/* reexport safe */ _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__.shimGetDisplayMedia),\n/* harmony export */   shimGetSendersWithDtmf: () => (/* binding */ shimGetSendersWithDtmf),\n/* harmony export */   shimGetStats: () => (/* binding */ shimGetStats),\n/* harmony export */   shimGetUserMedia: () => (/* reexport safe */ _getusermedia__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia),\n/* harmony export */   shimMediaStream: () => (/* binding */ shimMediaStream),\n/* harmony export */   shimOnTrack: () => (/* binding */ shimOnTrack),\n/* harmony export */   shimPeerConnection: () => (/* binding */ shimPeerConnection),\n/* harmony export */   shimSenderReceiverGetStats: () => (/* binding */ shimSenderReceiverGetStats)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/* harmony import */ var _getusermedia__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getusermedia */ \"./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js\");\n/* harmony import */ var _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getdisplaymedia */ \"./node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\n\nfunction shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\nfunction shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n        this.addEventListener('track', this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      if (!this._ontrackpoly) {\n        this._ontrackpoly = e => {\n          // onaddstream does not fire when a track is added to an existing\n          // stream. But stream.onaddtrack is implemented so we use that.\n          e.stream.addEventListener('addtrack', te => {\n            let receiver;\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find(r => r.track && r.track.id === te.track.id);\n            } else {\n              receiver = {\n                track: te.track\n              };\n            }\n            const event = new Event('track');\n            event.track = te.track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n          e.stream.getTracks().forEach(track => {\n            let receiver;\n            if (window.RTCPeerConnection.prototype.getReceivers) {\n              receiver = this.getReceivers().find(r => r.track && r.track.id === track.id);\n            } else {\n              receiver = {\n                track\n              };\n            }\n            const event = new Event('track');\n            event.track = track;\n            event.receiver = receiver;\n            event.transceiver = {\n              receiver\n            };\n            event.streams = [e.stream];\n            this.dispatchEvent(event);\n          });\n        };\n        this.addEventListener('addstream', this._ontrackpoly);\n      }\n      return origSetRemoteDescription.apply(this, arguments);\n    };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver', {\n          value: {\n            receiver: e.receiver\n          }\n        });\n      }\n      return e;\n    });\n  }\n}\nfunction shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function (pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n\n    // augment addTrack when getSenders is not available.\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        let sender = origAddTrack.apply(this, arguments);\n        if (!sender) {\n          sender = shimSenderWithDtmf(this, track);\n          this._senders.push(sender);\n        }\n        return sender;\n      };\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n      window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        origRemoveTrack.apply(this, arguments);\n        const idx = this._senders.indexOf(sender);\n        if (idx !== -1) {\n          this._senders.splice(idx, 1);\n        }\n      };\n    }\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      this._senders = this._senders || [];\n      origRemoveStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        const sender = this._senders.find(s => s.track === track);\n        if (sender) {\n          // remove sender\n          this._senders.splice(this._senders.indexOf(sender), 1);\n        }\n      });\n    };\n  } else if (typeof window === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\nfunction shimGetStats(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n\n    // If selector is a function then we are in the old style stats so just\n    // pass back the original getStats format to avoid breaking old users.\n    if (arguments.length > 0 && typeof selector === 'function') {\n      return origGetStats.apply(this, arguments);\n    }\n\n    // When spec-style getStats is supported, return those when called with\n    // either no arguments or the selector argument is null.\n    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {\n      return origGetStats.apply(this, []);\n    }\n    const fixChromeStats_ = function (response) {\n      const standardReport = {};\n      const reports = response.result();\n      reports.forEach(report => {\n        const standardStats = {\n          id: report.id,\n          timestamp: report.timestamp,\n          type: {\n            localcandidate: 'local-candidate',\n            remotecandidate: 'remote-candidate'\n          }[report.type] || report.type\n        };\n        report.names().forEach(name => {\n          standardStats[name] = report.stat(name);\n        });\n        standardReport[standardStats.id] = standardStats;\n      });\n      return standardReport;\n    };\n\n    // shim getStats with maplike support\n    const makeMapStats = function (stats) {\n      return new Map(Object.keys(stats).map(key => [key, stats[key]]));\n    };\n    if (arguments.length >= 2) {\n      const successCallbackWrapper_ = function (response) {\n        onSucc(makeMapStats(fixChromeStats_(response)));\n      };\n      return origGetStats.apply(this, [successCallbackWrapper_, selector]);\n    }\n\n    // promise-support\n    return new Promise((resolve, reject) => {\n      origGetStats.apply(this, [function (response) {\n        resolve(makeMapStats(fixChromeStats_(response)));\n      }, reject]);\n    }).then(onSucc, onErr);\n  };\n}\nfunction shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  }\n\n  // shim sender stats.\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n      /* Note: this will include stats of all senders that\n       *   send a track with the same id as sender.track as\n       *   it is not possible to identify the RTCRtpSender.\n       */\n      _utils_js__WEBPACK_IMPORTED_MODULE_0__.filterStats(result, sender.track, true));\n    };\n  }\n\n  // shim receiver stats.\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n        const receivers = origGetReceivers.apply(this, []);\n        receivers.forEach(receiver => receiver._pc = this);\n        return receivers;\n      };\n    }\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result => _utils_js__WEBPACK_IMPORTED_MODULE_0__.filterStats(result, receiver.track, false));\n    };\n  }\n  if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  }\n\n  // shim RTCPeerConnection.getStats(track).\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n        return r.track === track;\n      });\n      if (err || sender && receiver) {\n        return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\nfunction shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    return Object.keys(this._shimmedLocalStreams).map(streamId => this._shimmedLocalStreams[streamId][0]);\n  };\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (!stream) {\n      return origAddTrack.apply(this, arguments);\n    }\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    const sender = origAddTrack.apply(this, arguments);\n    if (!this._shimmedLocalStreams[stream.id]) {\n      this._shimmedLocalStreams[stream.id] = [stream, sender];\n    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n      this._shimmedLocalStreams[stream.id].push(sender);\n    }\n    return sender;\n  };\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders().filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    delete this._shimmedLocalStreams[stream.id];\n    return origRemoveStream.apply(this, arguments);\n  };\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n    if (sender) {\n      Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n        if (idx !== -1) {\n          this._shimmedLocalStreams[streamId].splice(idx, 1);\n        }\n        if (this._shimmedLocalStreams[streamId].length === 1) {\n          delete this._shimmedLocalStreams[streamId];\n        }\n      });\n    }\n    return origRemoveTrack.apply(this, arguments);\n  };\n}\nfunction shimAddTrackRemoveTrack(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // shim addTrack and removeTrack.\n  if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  }\n\n  // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n  const origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;\n  window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n    const nativeStreams = origGetLocalStreams.apply(this);\n    this._reverseStreams = this._reverseStreams || {};\n    return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n  };\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.', 'InvalidAccessError');\n      }\n    });\n    // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);\n    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n    delete this._streams[stream.id];\n  };\n  window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    }\n    const streams = [].slice.call(arguments, 1);\n    if (streams.length !== 1 || !streams[0].getTracks().find(t => t === track)) {\n      // this is not fully correct but all we can manage without\n      // [[associated MediaStreams]] internal slot.\n      throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');\n    }\n    const alreadyExists = this.getSenders().find(s => s.track === track);\n    if (alreadyExists) {\n      throw new DOMException('Track already exists.', 'InvalidAccessError');\n    }\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n    const oldStream = this._streams[stream.id];\n    if (oldStream) {\n      // this is using odd Chrome behaviour, use with caution:\n      // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n      // Note: we rely on the high-level addTrack/dtmf shim to\n      // create the sender with a dtmf sender.\n      oldStream.addTrack(track);\n\n      // Trigger ONN async.\n      Promise.resolve().then(() => {\n        this.dispatchEvent(new Event('negotiationneeded'));\n      });\n    } else {\n      const newStream = new window.MediaStream([track]);\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      this.addStream(newStream);\n    }\n    return this.getSenders().find(s => s.track === track);\n  };\n\n  // replace the internal stream id with the external one and\n  // vice versa.\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  ['createOffer', 'createAnswer'].forEach(function (method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {\n      [method]() {\n        const args = arguments;\n        const isLegacyCall = arguments.length && typeof arguments[0] === 'function';\n        if (isLegacyCall) {\n          return nativeMethod.apply(this, [description => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          }, err => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]]);\n        }\n        return nativeMethod.apply(this, arguments).then(description => replaceInternalStreamId(this, description));\n      }\n    };\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n  const origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\n  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    if (!arguments.length || !arguments[0].type) {\n      return origSetLocalDescription.apply(this, arguments);\n    }\n    arguments[0] = replaceExternalStreamId(this, arguments[0]);\n    return origSetLocalDescription.apply(this, arguments);\n  };\n\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {\n    get() {\n      const description = origLocalDescription.get.apply(this);\n      if (description.type === '') {\n        return description;\n      }\n      return replaceInternalStreamId(this, description);\n    }\n  });\n  window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n    if (this.signalingState === 'closed') {\n      throw new DOMException('The RTCPeerConnection\\'s signalingState is \\'closed\\'.', 'InvalidStateError');\n    }\n    // We can not yet check for sender instanceof RTCRtpSender\n    // since we shim RTPSender. So we check if sender._pc is set.\n    if (!sender._pc) {\n      throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');\n    }\n    const isLocal = sender._pc === this;\n    if (!isLocal) {\n      throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');\n    }\n\n    // Search for the native stream the senders track belongs to.\n    this._streams = this._streams || {};\n    let stream;\n    Object.keys(this._streams).forEach(streamid => {\n      const hasTrack = this._streams[streamid].getTracks().find(track => sender.track === track);\n      if (hasTrack) {\n        stream = this._streams[streamid];\n      }\n    });\n    if (stream) {\n      if (stream.getTracks().length === 1) {\n        // if this is the last track of the stream, remove the stream. This\n        // takes care of any shimmed _senders.\n        this.removeStream(this._reverseStreams[stream.id]);\n      } else {\n        // relying on the same odd chrome behaviour as above.\n        stream.removeTrack(sender.track);\n      }\n      this.dispatchEvent(new Event('negotiationneeded'));\n    }\n  };\n}\nfunction shimPeerConnection(window, browserDetails) {\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n      const nativeMethod = window.RTCPeerConnection.prototype[method];\n      const methodObj = {\n        [method]() {\n          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }\n      };\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n}\n\n// Attempt to fix ONN in plan-b mode.\nfunction fixNegotiationNeeded(window, browserDetails) {\n  _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === 'plan-b') {\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n    }\n    return e;\n  });\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js":
/*!**********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shimGetDisplayMedia: () => (/* binding */ shimGetDisplayMedia)\n/* harmony export */ });\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nfunction shimGetDisplayMedia(window, getSourceId) {\n  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  if (!window.navigator.mediaDevices) {\n    return;\n  }\n  // getSourceId is a function that returns a promise resolving with\n  // the sourceId of the screen/window/tab to be shared.\n  if (typeof getSourceId !== 'function') {\n    console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n    return getSourceId(constraints).then(sourceId => {\n      const widthSpecified = constraints.video && constraints.video.width;\n      const heightSpecified = constraints.video && constraints.video.height;\n      const frameRateSpecified = constraints.video && constraints.video.frameRate;\n      constraints.video = {\n        mandatory: {\n          chromeMediaSource: 'desktop',\n          chromeMediaSourceId: sourceId,\n          maxFrameRate: frameRateSpecified || 3\n        }\n      };\n      if (widthSpecified) {\n        constraints.video.mandatory.maxWidth = widthSpecified;\n      }\n      if (heightSpecified) {\n        constraints.video.mandatory.maxHeight = heightSpecified;\n      }\n      return window.navigator.mediaDevices.getUserMedia(constraints);\n    });\n  };\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shimGetUserMedia: () => (/* binding */ shimGetUserMedia)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\nconst logging = _utils_js__WEBPACK_IMPORTED_MODULE_0__.log;\nfunction shimGetUserMedia(window, browserDetails) {\n  const navigator = window && window.navigator;\n  if (!navigator.mediaDevices) {\n    return;\n  }\n  const constraintsToChrome_ = function (c) {\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\n      return c;\n    }\n    const cc = {};\n    Object.keys(c).forEach(key => {\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n        return;\n      }\n      const r = typeof c[key] === 'object' ? c[key] : {\n        ideal: c[key]\n      };\n      if (r.exact !== undefined && typeof r.exact === 'number') {\n        r.min = r.max = r.exact;\n      }\n      const oldname_ = function (prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n        return name === 'deviceId' ? 'sourceId' : name;\n      };\n      if (r.ideal !== undefined) {\n        cc.optional = cc.optional || [];\n        let oc = {};\n        if (typeof r.ideal === 'number') {\n          oc[oldname_('min', key)] = r.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_('max', key)] = r.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_('', key)] = r.ideal;\n          cc.optional.push(oc);\n        }\n      }\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_('', key)] = r.exact;\n      } else {\n        ['min', 'max'].forEach(mix => {\n          if (r[mix] !== undefined) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r[mix];\n          }\n        });\n      }\n    });\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n    return cc;\n  };\n  const shimConstraints_ = function (constraints, func) {\n    if (browserDetails.version >= 61) {\n      return func(constraints);\n    }\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (constraints && typeof constraints.audio === 'object') {\n      const remap = function (obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n    if (constraints && typeof constraints.video === 'object') {\n      // Shim facingMode for mobile & surface pro.\n      let face = constraints.video.facingMode;\n      face = face && (typeof face === 'object' ? face : {\n        ideal: face\n      });\n      const getSupportedFacingModeLies = browserDetails.version < 66;\n      if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        let matches;\n        if (face.exact === 'environment' || face.ideal === 'environment') {\n          matches = ['back', 'rear'];\n        } else if (face.exact === 'user' || face.ideal === 'user') {\n          matches = ['front'];\n        }\n        if (matches) {\n          // Look for matches in label, or use last cam for back (typical).\n          return navigator.mediaDevices.enumerateDevices().then(devices => {\n            devices = devices.filter(d => d.kind === 'videoinput');\n            let dev = devices.find(d => matches.some(match => d.label.toLowerCase().includes(match)));\n            if (!dev && devices.length && matches.includes('back')) {\n              dev = devices[devices.length - 1]; // more likely the back cam\n            }\n            if (dev) {\n              constraints.video.deviceId = face.exact ? {\n                exact: dev.deviceId\n              } : {\n                ideal: dev.deviceId\n              };\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n            logging('chrome: ' + JSON.stringify(constraints));\n            return func(constraints);\n          });\n        }\n      }\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n    logging('chrome: ' + JSON.stringify(constraints));\n    return func(constraints);\n  };\n  const shimError_ = function (e) {\n    if (browserDetails.version >= 64) {\n      return e;\n    }\n    return {\n      name: {\n        PermissionDeniedError: 'NotAllowedError',\n        PermissionDismissedError: 'NotAllowedError',\n        InvalidStateError: 'NotAllowedError',\n        DevicesNotFoundError: 'NotFoundError',\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\n        TrackStartError: 'NotReadableError',\n        MediaDeviceFailedDueToShutdown: 'NotAllowedError',\n        MediaDeviceKillSwitchOn: 'NotAllowedError',\n        TabCaptureError: 'AbortError',\n        ScreenCaptureError: 'AbortError',\n        DeviceCaptureError: 'AbortError'\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint || e.constraintName,\n      toString() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n  const getUserMedia_ = function (constraints, onSuccess, onError) {\n    shimConstraints_(constraints, c => {\n      navigator.webkitGetUserMedia(c, onSuccess, e => {\n        if (onError) {\n          onError(shimError_(e));\n        }\n      });\n    });\n  };\n  navigator.getUserMedia = getUserMedia_.bind(navigator);\n\n  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n  // function which returns a Promise, it does not accept spec-style\n  // constraints.\n  if (navigator.mediaDevices.getUserMedia) {\n    const origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function (cs) {\n      return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {\n        if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\n          stream.getTracks().forEach(track => {\n            track.stop();\n          });\n          throw new DOMException('', 'NotFoundError');\n        }\n        return stream;\n      }, e => Promise.reject(shimError_(e))));\n    };\n  }\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/common_shim.js":
/*!***********************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/common_shim.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   removeExtmapAllowMixed: () => (/* binding */ removeExtmapAllowMixed),\n/* harmony export */   shimAddIceCandidateNullOrEmpty: () => (/* binding */ shimAddIceCandidateNullOrEmpty),\n/* harmony export */   shimConnectionState: () => (/* binding */ shimConnectionState),\n/* harmony export */   shimMaxMessageSize: () => (/* binding */ shimMaxMessageSize),\n/* harmony export */   shimParameterlessSetLocalDescription: () => (/* binding */ shimParameterlessSetLocalDescription),\n/* harmony export */   shimRTCIceCandidate: () => (/* binding */ shimRTCIceCandidate),\n/* harmony export */   shimRTCIceCandidateRelayProtocol: () => (/* binding */ shimRTCIceCandidateRelayProtocol),\n/* harmony export */   shimSendThrowTypeError: () => (/* binding */ shimSendThrowTypeError)\n/* harmony export */ });\n/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sdp */ \"./node_modules/sdp/sdp.js\");\n/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sdp__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\nfunction shimRTCIceCandidate(window) {\n  // foundation is arbitrarily chosen as an indicator for full support for\n  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {\n    return;\n  }\n  const NativeRTCIceCandidate = window.RTCIceCandidate;\n  window.RTCIceCandidate = function RTCIceCandidate(args) {\n    // Remove the a= which shouldn't be part of the candidate string.\n    if (typeof args === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {\n      args = JSON.parse(JSON.stringify(args));\n      args.candidate = args.candidate.substring(2);\n    }\n    if (args.candidate && args.candidate.length) {\n      // Augment the native candidate with the parsed fields.\n      const nativeCandidate = new NativeRTCIceCandidate(args);\n      const parsedCandidate = sdp__WEBPACK_IMPORTED_MODULE_0___default().parseCandidate(args.candidate);\n      for (const key in parsedCandidate) {\n        if (!(key in nativeCandidate)) {\n          Object.defineProperty(nativeCandidate, key, {\n            value: parsedCandidate[key]\n          });\n        }\n      }\n\n      // Override serializer to not serialize the extra attributes.\n      nativeCandidate.toJSON = function toJSON() {\n        return {\n          candidate: nativeCandidate.candidate,\n          sdpMid: nativeCandidate.sdpMid,\n          sdpMLineIndex: nativeCandidate.sdpMLineIndex,\n          usernameFragment: nativeCandidate.usernameFragment\n        };\n      };\n      return nativeCandidate;\n    }\n    return new NativeRTCIceCandidate(args);\n  };\n  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n\n  // Hook up the augmented candidate in onicecandidate and\n  // addEventListener('icecandidate', ...)\n  _utils__WEBPACK_IMPORTED_MODULE_1__.wrapPeerConnectionEvent(window, 'icecandidate', e => {\n    if (e.candidate) {\n      Object.defineProperty(e, 'candidate', {\n        value: new window.RTCIceCandidate(e.candidate),\n        writable: 'false'\n      });\n    }\n    return e;\n  });\n}\nfunction shimRTCIceCandidateRelayProtocol(window) {\n  if (!window.RTCIceCandidate || window.RTCIceCandidate && 'relayProtocol' in window.RTCIceCandidate.prototype) {\n    return;\n  }\n\n  // Hook up the augmented candidate in onicecandidate and\n  // addEventListener('icecandidate', ...)\n  _utils__WEBPACK_IMPORTED_MODULE_1__.wrapPeerConnectionEvent(window, 'icecandidate', e => {\n    if (e.candidate) {\n      const parsedCandidate = sdp__WEBPACK_IMPORTED_MODULE_0___default().parseCandidate(e.candidate.candidate);\n      if (parsedCandidate.type === 'relay') {\n        // This is a libwebrtc-specific mapping of local type preference\n        // to relayProtocol.\n        e.candidate.relayProtocol = {\n          0: 'tls',\n          1: 'tcp',\n          2: 'udp'\n        }[parsedCandidate.priority >> 24];\n      }\n    }\n    return e;\n  });\n}\nfunction shimMaxMessageSize(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  if (!('sctp' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {\n      get() {\n        return typeof this._sctp === 'undefined' ? null : this._sctp;\n      }\n    });\n  }\n  const sctpInDescription = function (description) {\n    if (!description || !description.sdp) {\n      return false;\n    }\n    const sections = sdp__WEBPACK_IMPORTED_MODULE_0___default().splitSections(description.sdp);\n    sections.shift();\n    return sections.some(mediaSection => {\n      const mLine = sdp__WEBPACK_IMPORTED_MODULE_0___default().parseMLine(mediaSection);\n      return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;\n    });\n  };\n  const getRemoteFirefoxVersion = function (description) {\n    // TODO: Is there a better solution for detecting Firefox?\n    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n    if (match === null || match.length < 2) {\n      return -1;\n    }\n    const version = parseInt(match[1], 10);\n    // Test for NaN (yes, this is ugly)\n    return version !== version ? -1 : version;\n  };\n  const getCanSendMaxMessageSize = function (remoteIsFirefox) {\n    // Every implementation we know can send at least 64 KiB.\n    // Note: Although Chrome is technically able to send up to 256 KiB, the\n    //       data does not reach the other peer reliably.\n    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n    let canSendMaxMessageSize = 65536;\n    if (browserDetails.browser === 'firefox') {\n      if (browserDetails.version < 57) {\n        if (remoteIsFirefox === -1) {\n          // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n          // fragmentation.\n          canSendMaxMessageSize = 16384;\n        } else {\n          // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n          // messages. Thus, supporting ~2 GiB when sending.\n          canSendMaxMessageSize = 2147483637;\n        }\n      } else if (browserDetails.version < 60) {\n        // Currently, all FF >= 57 will reset the remote maximum message size\n        // to the default value when a data channel is created at a later\n        // stage. :(\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\n      } else {\n        // FF >= 60 supports sending ~2 GiB\n        canSendMaxMessageSize = 2147483637;\n      }\n    }\n    return canSendMaxMessageSize;\n  };\n  const getMaxMessageSize = function (description, remoteIsFirefox) {\n    // Note: 65536 bytes is the default value from the SDP spec. Also,\n    //       every implementation we know supports receiving 65536 bytes.\n    let maxMessageSize = 65536;\n\n    // FF 57 has a slightly incorrect default remote max message size, so\n    // we need to adjust it here to avoid a failure when sending.\n    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n    if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {\n      maxMessageSize = 65535;\n    }\n    const match = sdp__WEBPACK_IMPORTED_MODULE_0___default().matchPrefix(description.sdp, 'a=max-message-size:');\n    if (match.length > 0) {\n      maxMessageSize = parseInt(match[0].substring(19), 10);\n    } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {\n      // If the maximum message size is not present in the remote SDP and\n      // both local and remote are Firefox, the remote peer can receive\n      // ~2 GiB.\n      maxMessageSize = 2147483637;\n    }\n    return maxMessageSize;\n  };\n  const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n    this._sctp = null;\n    // Chrome decided to not expose .sctp in plan-b mode.\n    // As usual, adapter.js has to do an 'ugly worakaround'\n    // to cover up the mess.\n    if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {\n      const {\n        sdpSemantics\n      } = this.getConfiguration();\n      if (sdpSemantics === 'plan-b') {\n        Object.defineProperty(this, 'sctp', {\n          get() {\n            return typeof this._sctp === 'undefined' ? null : this._sctp;\n          },\n          enumerable: true,\n          configurable: true\n        });\n      }\n    }\n    if (sctpInDescription(arguments[0])) {\n      // Check if the remote is FF.\n      const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n\n      // Get the maximum message size the local peer is capable of sending\n      const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n\n      // Get the maximum message size of the remote peer.\n      const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n\n      // Determine final maximum message size\n      let maxMessageSize;\n      if (canSendMMS === 0 && remoteMMS === 0) {\n        maxMessageSize = Number.POSITIVE_INFINITY;\n      } else if (canSendMMS === 0 || remoteMMS === 0) {\n        maxMessageSize = Math.max(canSendMMS, remoteMMS);\n      } else {\n        maxMessageSize = Math.min(canSendMMS, remoteMMS);\n      }\n\n      // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n      // attribute.\n      const sctp = {};\n      Object.defineProperty(sctp, 'maxMessageSize', {\n        get() {\n          return maxMessageSize;\n        }\n      });\n      this._sctp = sctp;\n    }\n    return origSetRemoteDescription.apply(this, arguments);\n  };\n}\nfunction shimSendThrowTypeError(window) {\n  if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {\n    return;\n  }\n\n  // Note: Although Firefox >= 57 has a native implementation, the maximum\n  //       message size can be reset for all data channels at a later stage.\n  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n\n  function wrapDcSend(dc, pc) {\n    const origDataChannelSend = dc.send;\n    dc.send = function send() {\n      const data = arguments[0];\n      const length = data.length || data.size || data.byteLength;\n      if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {\n        throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');\n      }\n      return origDataChannelSend.apply(dc, arguments);\n    };\n  }\n  const origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;\n  window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {\n    const dataChannel = origCreateDataChannel.apply(this, arguments);\n    wrapDcSend(dataChannel, this);\n    return dataChannel;\n  };\n  _utils__WEBPACK_IMPORTED_MODULE_1__.wrapPeerConnectionEvent(window, 'datachannel', e => {\n    wrapDcSend(e.channel, e.target);\n    return e;\n  });\n}\n\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */\nfunction shimConnectionState(window) {\n  if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  const proto = window.RTCPeerConnection.prototype;\n  Object.defineProperty(proto, 'connectionState', {\n    get() {\n      return {\n        completed: 'connected',\n        checking: 'connecting'\n      }[this.iceConnectionState] || this.iceConnectionState;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(proto, 'onconnectionstatechange', {\n    get() {\n      return this._onconnectionstatechange || null;\n    },\n    set(cb) {\n      if (this._onconnectionstatechange) {\n        this.removeEventListener('connectionstatechange', this._onconnectionstatechange);\n        delete this._onconnectionstatechange;\n      }\n      if (cb) {\n        this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  ['setLocalDescription', 'setRemoteDescription'].forEach(method => {\n    const origMethod = proto[method];\n    proto[method] = function () {\n      if (!this._connectionstatechangepoly) {\n        this._connectionstatechangepoly = e => {\n          const pc = e.target;\n          if (pc._lastConnectionState !== pc.connectionState) {\n            pc._lastConnectionState = pc.connectionState;\n            const newEvent = new Event('connectionstatechange', e);\n            pc.dispatchEvent(newEvent);\n          }\n          return e;\n        };\n        this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);\n      }\n      return origMethod.apply(this, arguments);\n    };\n  });\n}\nfunction removeExtmapAllowMixed(window, browserDetails) {\n  /* remove a=extmap-allow-mixed for webrtc.org < M71 */\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {\n    return;\n  }\n  if (browserDetails.browser === 'safari' && browserDetails.version >= 605) {\n    return;\n  }\n  const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {\n    if (desc && desc.sdp && desc.sdp.indexOf('\\na=extmap-allow-mixed') !== -1) {\n      const sdp = desc.sdp.split('\\n').filter(line => {\n        return line.trim() !== 'a=extmap-allow-mixed';\n      }).join('\\n');\n      // Safari enforces read-only-ness of RTCSessionDescription fields.\n      if (window.RTCSessionDescription && desc instanceof window.RTCSessionDescription) {\n        arguments[0] = new window.RTCSessionDescription({\n          type: desc.type,\n          sdp\n        });\n      } else {\n        desc.sdp = sdp;\n      }\n    }\n    return nativeSRD.apply(this, arguments);\n  };\n}\nfunction shimAddIceCandidateNullOrEmpty(window, browserDetails) {\n  // Support for addIceCandidate(null or undefined)\n  // as well as addIceCandidate({candidate: \"\", ...})\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n  // Note: must be called before other polyfills which change the signature.\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\n    return;\n  }\n  const nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;\n  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\n    if (!arguments[0]) {\n      if (arguments[1]) {\n        arguments[1].apply(null);\n      }\n      return Promise.resolve();\n    }\n    // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n    // in older versions.\n    // Native support for ignoring exists for Chrome M77+.\n    // Safari ignores as well, exact version unknown but works in the same\n    // version that also ignores addIceCandidate(null).\n    if ((browserDetails.browser === 'chrome' && browserDetails.version < 78 || browserDetails.browser === 'firefox' && browserDetails.version < 68 || browserDetails.browser === 'safari') && arguments[0] && arguments[0].candidate === '') {\n      return Promise.resolve();\n    }\n    return nativeAddIceCandidate.apply(this, arguments);\n  };\n}\n\n// Note: Make sure to call this ahead of APIs that modify\n// setLocalDescription.length\nfunction shimParameterlessSetLocalDescription(window, browserDetails) {\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\n    return;\n  }\n  const nativeSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;\n  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n    let desc = arguments[0] || {};\n    if (typeof desc !== 'object' || desc.type && desc.sdp) {\n      return nativeSetLocalDescription.apply(this, arguments);\n    }\n    // The remaining steps should technically happen when SLD comes off the\n    // RTCPeerConnection's operations chain (not ahead of going on it), but\n    // this is too difficult to shim. Instead, this shim only covers the\n    // common case where the operations chain is empty. This is imperfect, but\n    // should cover many cases. Rationale: Even if we can't reduce the glare\n    // window to zero on imperfect implementations, there's value in tapping\n    // into the perfect negotiation pattern that several browsers support.\n    desc = {\n      type: desc.type,\n      sdp: desc.sdp\n    };\n    if (!desc.type) {\n      switch (this.signalingState) {\n        case 'stable':\n        case 'have-local-offer':\n        case 'have-remote-pranswer':\n          desc.type = 'offer';\n          break;\n        default:\n          desc.type = 'answer';\n          break;\n      }\n    }\n    if (desc.sdp || desc.type !== 'offer' && desc.type !== 'answer') {\n      return nativeSetLocalDescription.apply(this, [desc]);\n    }\n    const func = desc.type === 'offer' ? this.createOffer : this.createAnswer;\n    return func.apply(this).then(d => nativeSetLocalDescription.apply(this, [d]));\n  };\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/common_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js":
/*!********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shimAddTransceiver: () => (/* binding */ shimAddTransceiver),\n/* harmony export */   shimCreateAnswer: () => (/* binding */ shimCreateAnswer),\n/* harmony export */   shimCreateOffer: () => (/* binding */ shimCreateOffer),\n/* harmony export */   shimGetDisplayMedia: () => (/* reexport safe */ _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__.shimGetDisplayMedia),\n/* harmony export */   shimGetParameters: () => (/* binding */ shimGetParameters),\n/* harmony export */   shimGetUserMedia: () => (/* reexport safe */ _getusermedia__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia),\n/* harmony export */   shimOnTrack: () => (/* binding */ shimOnTrack),\n/* harmony export */   shimPeerConnection: () => (/* binding */ shimPeerConnection),\n/* harmony export */   shimRTCDataChannel: () => (/* binding */ shimRTCDataChannel),\n/* harmony export */   shimReceiverGetStats: () => (/* binding */ shimReceiverGetStats),\n/* harmony export */   shimRemoveStream: () => (/* binding */ shimRemoveStream),\n/* harmony export */   shimSenderGetStats: () => (/* binding */ shimSenderGetStats)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/* harmony import */ var _getusermedia__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getusermedia */ \"./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js\");\n/* harmony import */ var _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getdisplaymedia */ \"./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\n\n\nfunction shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n    });\n  }\n}\nfunction shimPeerConnection(window, browserDetails) {\n  if (typeof window !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {\n    return; // probably media.peerconnection.enabled=false in about:config\n  }\n  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.mozRTCPeerConnection;\n  }\n  if (browserDetails.version < 53) {\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {\n      const nativeMethod = window.RTCPeerConnection.prototype[method];\n      const methodObj = {\n        [method]() {\n          arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);\n          return nativeMethod.apply(this, arguments);\n        }\n      };\n      window.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n  }\n  const modernStatsTypes = {\n    inboundrtp: 'inbound-rtp',\n    outboundrtp: 'outbound-rtp',\n    candidatepair: 'candidate-pair',\n    localcandidate: 'local-candidate',\n    remotecandidate: 'remote-candidate'\n  };\n  const nativeGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n    return nativeGetStats.apply(this, [selector || null]).then(stats => {\n      if (browserDetails.version < 53 && !onSucc) {\n        // Shim only promise getStats with spec-hyphens in type names\n        // Leave callback version alone; misc old uses of forEach before Map\n        try {\n          stats.forEach(stat => {\n            stat.type = modernStatsTypes[stat.type] || stat.type;\n          });\n        } catch (e) {\n          if (e.name !== 'TypeError') {\n            throw e;\n          }\n          // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n          stats.forEach((stat, i) => {\n            stats.set(i, Object.assign({}, stat, {\n              type: modernStatsTypes[stat.type] || stat.type\n            }));\n          });\n        }\n      }\n      return stats;\n    }).then(onSucc, onErr);\n  };\n}\nfunction shimSenderGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {\n    return;\n  }\n  const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n  if (origGetSenders) {\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n  }\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  if (origAddTrack) {\n    window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n      const sender = origAddTrack.apply(this, arguments);\n      sender._pc = this;\n      return sender;\n    };\n  }\n  window.RTCRtpSender.prototype.getStats = function getStats() {\n    return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());\n  };\n}\nfunction shimReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {\n    return;\n  }\n  const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n  if (origGetReceivers) {\n    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n      const receivers = origGetReceivers.apply(this, []);\n      receivers.forEach(receiver => receiver._pc = this);\n      return receivers;\n    };\n  }\n  _utils__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {\n    e.receiver._pc = e.srcElement;\n    return e;\n  });\n  window.RTCRtpReceiver.prototype.getStats = function getStats() {\n    return this._pc.getStats(this.track);\n  };\n}\nfunction shimRemoveStream(window) {\n  if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n    _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('removeStream', 'removeTrack');\n    this.getSenders().forEach(sender => {\n      if (sender.track && stream.getTracks().includes(sender.track)) {\n        this.removeTrack(sender);\n      }\n    });\n  };\n}\nfunction shimRTCDataChannel(window) {\n  // rename DataChannel to RTCDataChannel (native fix in FF60):\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n  if (window.DataChannel && !window.RTCDataChannel) {\n    window.RTCDataChannel = window.DataChannel;\n  }\n}\nfunction shimAddTransceiver(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;\n  if (origAddTransceiver) {\n    window.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\n      this.setParametersPromises = [];\n      // WebIDL input coercion and validation\n      let sendEncodings = arguments[1] && arguments[1].sendEncodings;\n      if (sendEncodings === undefined) {\n        sendEncodings = [];\n      }\n      sendEncodings = [...sendEncodings];\n      const shouldPerformCheck = sendEncodings.length > 0;\n      if (shouldPerformCheck) {\n        // If sendEncodings params are provided, validate grammar\n        sendEncodings.forEach(encodingParam => {\n          if ('rid' in encodingParam) {\n            const ridRegex = /^[a-z0-9]{0,16}$/i;\n            if (!ridRegex.test(encodingParam.rid)) {\n              throw new TypeError('Invalid RID value provided.');\n            }\n          }\n          if ('scaleResolutionDownBy' in encodingParam) {\n            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\n              throw new RangeError('scale_resolution_down_by must be >= 1.0');\n            }\n          }\n          if ('maxFramerate' in encodingParam) {\n            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n              throw new RangeError('max_framerate must be >= 0.0');\n            }\n          }\n        });\n      }\n      const transceiver = origAddTransceiver.apply(this, arguments);\n      if (shouldPerformCheck) {\n        // Check if the init options were applied. If not we do this in an\n        // asynchronous way and save the promise reference in a global object.\n        // This is an ugly hack, but at the same time is way more robust than\n        // checking the sender parameters before and after the createOffer\n        // Also note that after the createoffer we are not 100% sure that\n        // the params were asynchronously applied so we might miss the\n        // opportunity to recreate offer.\n        const {\n          sender\n        } = transceiver;\n        const params = sender.getParameters();\n        if (!('encodings' in params) ||\n        // Avoid being fooled by patched getParameters() below.\n        params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {\n          params.encodings = sendEncodings;\n          sender.sendEncodings = sendEncodings;\n          this.setParametersPromises.push(sender.setParameters(params).then(() => {\n            delete sender.sendEncodings;\n          }).catch(() => {\n            delete sender.sendEncodings;\n          }));\n        }\n      }\n      return transceiver;\n    };\n  }\n}\nfunction shimGetParameters(window) {\n  if (!(typeof window === 'object' && window.RTCRtpSender)) {\n    return;\n  }\n  const origGetParameters = window.RTCRtpSender.prototype.getParameters;\n  if (origGetParameters) {\n    window.RTCRtpSender.prototype.getParameters = function getParameters() {\n      const params = origGetParameters.apply(this, arguments);\n      if (!('encodings' in params)) {\n        params.encodings = [].concat(this.sendEncodings || [{}]);\n      }\n      return params;\n    };\n  }\n}\nfunction shimCreateOffer(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n  window.RTCPeerConnection.prototype.createOffer = function createOffer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises).then(() => {\n        return origCreateOffer.apply(this, arguments);\n      }).finally(() => {\n        this.setParametersPromises = [];\n      });\n    }\n    return origCreateOffer.apply(this, arguments);\n  };\n}\nfunction shimCreateAnswer(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;\n  window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises).then(() => {\n        return origCreateAnswer.apply(this, arguments);\n      }).finally(() => {\n        this.setParametersPromises = [];\n      });\n    }\n    return origCreateAnswer.apply(this, arguments);\n  };\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js":
/*!***********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shimGetDisplayMedia: () => (/* binding */ shimGetDisplayMedia)\n/* harmony export */ });\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nfunction shimGetDisplayMedia(window, preferredMediaSource) {\n  if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  if (!window.navigator.mediaDevices) {\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n    if (!(constraints && constraints.video)) {\n      const err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');\n      err.name = 'NotFoundError';\n      // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n      err.code = 8;\n      return Promise.reject(err);\n    }\n    if (constraints.video === true) {\n      constraints.video = {\n        mediaSource: preferredMediaSource\n      };\n    } else {\n      constraints.video.mediaSource = preferredMediaSource;\n    }\n    return window.navigator.mediaDevices.getUserMedia(constraints);\n  };\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js":
/*!********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shimGetUserMedia: () => (/* binding */ shimGetUserMedia)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\n\nfunction shimGetUserMedia(window, browserDetails) {\n  const navigator = window && window.navigator;\n  const MediaStreamTrack = window && window.MediaStreamTrack;\n  navigator.getUserMedia = function (constraints, onSuccess, onError) {\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\n    _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n  };\n  if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\n    const remap = function (obj, a, b) {\n      if (a in obj && !(b in obj)) {\n        obj[b] = obj[a];\n        delete obj[a];\n      }\n    };\n    const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function (c) {\n      if (typeof c === 'object' && typeof c.audio === 'object') {\n        c = JSON.parse(JSON.stringify(c));\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\n      }\n      return nativeGetUserMedia(c);\n    };\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\n      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;\n      MediaStreamTrack.prototype.getSettings = function () {\n        const obj = nativeGetSettings.apply(this, arguments);\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\n        return obj;\n      };\n    }\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\n      const nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;\n      MediaStreamTrack.prototype.applyConstraints = function (c) {\n        if (this.kind === 'audio' && typeof c === 'object') {\n          c = JSON.parse(JSON.stringify(c));\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\n        }\n        return nativeApplyConstraints.apply(this, [c]);\n      };\n    }\n  }\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/safari/safari_shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/safari/safari_shim.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shimAudioContext: () => (/* binding */ shimAudioContext),\n/* harmony export */   shimCallbacksAPI: () => (/* binding */ shimCallbacksAPI),\n/* harmony export */   shimConstraints: () => (/* binding */ shimConstraints),\n/* harmony export */   shimCreateOfferLegacy: () => (/* binding */ shimCreateOfferLegacy),\n/* harmony export */   shimGetUserMedia: () => (/* binding */ shimGetUserMedia),\n/* harmony export */   shimLocalStreamsAPI: () => (/* binding */ shimLocalStreamsAPI),\n/* harmony export */   shimRTCIceServerUrls: () => (/* binding */ shimRTCIceServerUrls),\n/* harmony export */   shimRemoteStreamsAPI: () => (/* binding */ shimRemoteStreamsAPI),\n/* harmony export */   shimTrackEventTransceiver: () => (/* binding */ shimTrackEventTransceiver)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\n\n\nfunction shimLocalStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      return this._localStreams;\n    };\n  }\n  if (!('addStream' in window.RTCPeerConnection.prototype)) {\n    const _addTrack = window.RTCPeerConnection.prototype.addTrack;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      if (!this._localStreams.includes(stream)) {\n        this._localStreams.push(stream);\n      }\n      // Try to emulate Chrome's behaviour of adding in audio-video order.\n      // Safari orders by track id.\n      stream.getAudioTracks().forEach(track => _addTrack.call(this, track, stream));\n      stream.getVideoTracks().forEach(track => _addTrack.call(this, track, stream));\n    };\n    window.RTCPeerConnection.prototype.addTrack = function addTrack(track) {\n      for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        streams[_key - 1] = arguments[_key];\n      }\n      if (streams) {\n        streams.forEach(stream => {\n          if (!this._localStreams) {\n            this._localStreams = [stream];\n          } else if (!this._localStreams.includes(stream)) {\n            this._localStreams.push(stream);\n          }\n        });\n      }\n      return _addTrack.apply(this, arguments);\n    };\n  }\n  if (!('removeStream' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      const index = this._localStreams.indexOf(stream);\n      if (index === -1) {\n        return;\n      }\n      this._localStreams.splice(index, 1);\n      const tracks = stream.getTracks();\n      this.getSenders().forEach(sender => {\n        if (tracks.includes(sender.track)) {\n          this.removeTrack(sender);\n        }\n      });\n    };\n  }\n}\nfunction shimRemoteStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {\n      return this._remoteStreams ? this._remoteStreams : [];\n    };\n  }\n  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\n      get() {\n        return this._onaddstream;\n      },\n      set(f) {\n        if (this._onaddstream) {\n          this.removeEventListener('addstream', this._onaddstream);\n          this.removeEventListener('track', this._onaddstreampoly);\n        }\n        this.addEventListener('addstream', this._onaddstream = f);\n        this.addEventListener('track', this._onaddstreampoly = e => {\n          e.streams.forEach(stream => {\n            if (!this._remoteStreams) {\n              this._remoteStreams = [];\n            }\n            if (this._remoteStreams.includes(stream)) {\n              return;\n            }\n            this._remoteStreams.push(stream);\n            const event = new Event('addstream');\n            event.stream = stream;\n            this.dispatchEvent(event);\n          });\n        });\n      }\n    });\n    const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n      const pc = this;\n      if (!this._onaddstreampoly) {\n        this.addEventListener('track', this._onaddstreampoly = function (e) {\n          e.streams.forEach(stream => {\n            if (!pc._remoteStreams) {\n              pc._remoteStreams = [];\n            }\n            if (pc._remoteStreams.indexOf(stream) >= 0) {\n              return;\n            }\n            pc._remoteStreams.push(stream);\n            const event = new Event('addstream');\n            event.stream = stream;\n            pc.dispatchEvent(event);\n          });\n        });\n      }\n      return origSetRemoteDescription.apply(pc, arguments);\n    };\n  }\n}\nfunction shimCallbacksAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  const prototype = window.RTCPeerConnection.prototype;\n  const origCreateOffer = prototype.createOffer;\n  const origCreateAnswer = prototype.createAnswer;\n  const setLocalDescription = prototype.setLocalDescription;\n  const setRemoteDescription = prototype.setRemoteDescription;\n  const addIceCandidate = prototype.addIceCandidate;\n  prototype.createOffer = function createOffer(successCallback, failureCallback) {\n    const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n    const promise = origCreateOffer.apply(this, [options]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {\n    const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n    const promise = origCreateAnswer.apply(this, [options]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  let withCallback = function (description, successCallback, failureCallback) {\n    const promise = setLocalDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setLocalDescription = withCallback;\n  withCallback = function (description, successCallback, failureCallback) {\n    const promise = setRemoteDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setRemoteDescription = withCallback;\n  withCallback = function (candidate, successCallback, failureCallback) {\n    const promise = addIceCandidate.apply(this, [candidate]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.addIceCandidate = withCallback;\n}\nfunction shimGetUserMedia(window) {\n  const navigator = window && window.navigator;\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    // shim not needed in Safari 12.1\n    const mediaDevices = navigator.mediaDevices;\n    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n    navigator.mediaDevices.getUserMedia = constraints => {\n      return _getUserMedia(shimConstraints(constraints));\n    };\n  }\n  if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {\n      navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);\n    }.bind(navigator);\n  }\n}\nfunction shimConstraints(constraints) {\n  if (constraints && constraints.video !== undefined) {\n    return Object.assign({}, constraints, {\n      video: _utils__WEBPACK_IMPORTED_MODULE_0__.compactObject(constraints.video)\n    });\n  }\n  return constraints;\n}\nfunction shimRTCIceServerUrls(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n  const OrigPeerConnection = window.RTCPeerConnection;\n  window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {\n    if (pcConfig && pcConfig.iceServers) {\n      const newIceServers = [];\n      for (let i = 0; i < pcConfig.iceServers.length; i++) {\n        let server = pcConfig.iceServers[i];\n        if (server.urls === undefined && server.url) {\n          _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n          server = JSON.parse(JSON.stringify(server));\n          server.urls = server.url;\n          delete server.url;\n          newIceServers.push(server);\n        } else {\n          newIceServers.push(pcConfig.iceServers[i]);\n        }\n      }\n      pcConfig.iceServers = newIceServers;\n    }\n    return new OrigPeerConnection(pcConfig, pcConstraints);\n  };\n  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n  // wrap static methods. Currently just generateCertificate.\n  if ('generateCertificate' in OrigPeerConnection) {\n    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n      get() {\n        return OrigPeerConnection.generateCertificate;\n      }\n    });\n  }\n}\nfunction shimTrackEventTransceiver(window) {\n  // Add event.transceiver member over deprecated event.receiver\n  if (typeof window === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n    });\n  }\n}\nfunction shimCreateOfferLegacy(window) {\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n  window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {\n    if (offerOptions) {\n      if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n        // support bit values\n        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n      }\n      const audioTransceiver = this.getTransceivers().find(transceiver => transceiver.receiver.track.kind === 'audio');\n      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n        if (audioTransceiver.direction === 'sendrecv') {\n          if (audioTransceiver.setDirection) {\n            audioTransceiver.setDirection('sendonly');\n          } else {\n            audioTransceiver.direction = 'sendonly';\n          }\n        } else if (audioTransceiver.direction === 'recvonly') {\n          if (audioTransceiver.setDirection) {\n            audioTransceiver.setDirection('inactive');\n          } else {\n            audioTransceiver.direction = 'inactive';\n          }\n        }\n      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\n        this.addTransceiver('audio', {\n          direction: 'recvonly'\n        });\n      }\n      if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {\n        // support bit values\n        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n      }\n      const videoTransceiver = this.getTransceivers().find(transceiver => transceiver.receiver.track.kind === 'video');\n      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n        if (videoTransceiver.direction === 'sendrecv') {\n          if (videoTransceiver.setDirection) {\n            videoTransceiver.setDirection('sendonly');\n          } else {\n            videoTransceiver.direction = 'sendonly';\n          }\n        } else if (videoTransceiver.direction === 'recvonly') {\n          if (videoTransceiver.setDirection) {\n            videoTransceiver.setDirection('inactive');\n          } else {\n            videoTransceiver.direction = 'inactive';\n          }\n        }\n      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\n        this.addTransceiver('video', {\n          direction: 'recvonly'\n        });\n      }\n    }\n    return origCreateOffer.apply(this, arguments);\n  };\n}\nfunction shimAudioContext(window) {\n  if (typeof window !== 'object' || window.AudioContext) {\n    return;\n  }\n  window.AudioContext = window.webkitAudioContext;\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/safari/safari_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compactObject: () => (/* binding */ compactObject),\n/* harmony export */   deprecated: () => (/* binding */ deprecated),\n/* harmony export */   detectBrowser: () => (/* binding */ detectBrowser),\n/* harmony export */   disableLog: () => (/* binding */ disableLog),\n/* harmony export */   disableWarnings: () => (/* binding */ disableWarnings),\n/* harmony export */   extractVersion: () => (/* binding */ extractVersion),\n/* harmony export */   filterStats: () => (/* binding */ filterStats),\n/* harmony export */   log: () => (/* binding */ log),\n/* harmony export */   walkStats: () => (/* binding */ walkStats),\n/* harmony export */   wrapPeerConnectionEvent: () => (/* binding */ wrapPeerConnectionEvent)\n/* harmony export */ });\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n\nlet logDisabled_ = true;\nlet deprecationWarnings_ = true;\n\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */\nfunction extractVersion(uastring, expr, pos) {\n  const match = uastring.match(expr);\n  return match && match.length >= pos && parseInt(match[pos], 10);\n}\n\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nfunction wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  const proto = window.RTCPeerConnection.prototype;\n  const nativeAddEventListener = proto.addEventListener;\n  proto.addEventListener = function (nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap) {\n      return nativeAddEventListener.apply(this, arguments);\n    }\n    const wrappedCallback = e => {\n      const modifiedEvent = wrapper(e);\n      if (modifiedEvent) {\n        if (cb.handleEvent) {\n          cb.handleEvent(modifiedEvent);\n        } else {\n          cb(modifiedEvent);\n        }\n      }\n    };\n    this._eventMap = this._eventMap || {};\n    if (!this._eventMap[eventNameToWrap]) {\n      this._eventMap[eventNameToWrap] = new Map();\n    }\n    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);\n  };\n  const nativeRemoveEventListener = proto.removeEventListener;\n  proto.removeEventListener = function (nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    if (!this._eventMap[eventNameToWrap].has(cb)) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n    this._eventMap[eventNameToWrap].delete(cb);\n    if (this._eventMap[eventNameToWrap].size === 0) {\n      delete this._eventMap[eventNameToWrap];\n    }\n    if (Object.keys(this._eventMap).length === 0) {\n      delete this._eventMap;\n    }\n    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);\n  };\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\n    get() {\n      return this['_on' + eventNameToWrap];\n    },\n    set(cb) {\n      if (this['_on' + eventNameToWrap]) {\n        this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);\n        delete this['_on' + eventNameToWrap];\n      }\n      if (cb) {\n        this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction disableLog(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\n  }\n  logDisabled_ = bool;\n  return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';\n}\n\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */\nfunction disableWarnings(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool + '. Please use a boolean.');\n  }\n  deprecationWarnings_ = !bool;\n  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n}\nfunction log() {\n  if (typeof window === 'object') {\n    if (logDisabled_) {\n      return;\n    }\n    if (typeof console !== 'undefined' && typeof console.log === 'function') {\n      console.log.apply(console, arguments);\n    }\n  }\n}\n\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */\nfunction deprecated(oldMethod, newMethod) {\n  if (!deprecationWarnings_) {\n    return;\n  }\n  console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');\n}\n\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */\nfunction detectBrowser(window) {\n  // Returned result object.\n  const result = {\n    browser: null,\n    version: null\n  };\n\n  // Fail early if it's not a browser\n  if (typeof window === 'undefined' || !window.navigator || !window.navigator.userAgent) {\n    result.browser = 'Not a browser.';\n    return result;\n  }\n  const {\n    navigator\n  } = window;\n  if (navigator.mozGetUserMedia) {\n    // Firefox.\n    result.browser = 'firefox';\n    result.version = extractVersion(navigator.userAgent, /Firefox\\/(\\d+)\\./, 1);\n  } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection) {\n    // Chrome, Chromium, Webview, Opera.\n    // Version matches Chrome/WebRTC version.\n    // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n    // more complicated fallback to webkitRTCPeerConnection.\n    result.browser = 'chrome';\n    result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n  } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n    // Safari.\n    result.browser = 'safari';\n    result.version = extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n    result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;\n  } else {\n    // Default fallthrough: not supported.\n    result.browser = 'Not a supported browser.';\n    return result;\n  }\n  return result;\n}\n\n/**\n * Checks if something is an object.\n *\n * @param {*} val The something you want to check.\n * @return true if val is an object, false otherwise.\n */\nfunction isObject(val) {\n  return Object.prototype.toString.call(val) === '[object Object]';\n}\n\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash's `compact`.\n */\nfunction compactObject(data) {\n  if (!isObject(data)) {\n    return data;\n  }\n  return Object.keys(data).reduce(function (accumulator, key) {\n    const isObj = isObject(data[key]);\n    const value = isObj ? compactObject(data[key]) : data[key];\n    const isEmptyObject = isObj && !Object.keys(value).length;\n    if (value === undefined || isEmptyObject) {\n      return accumulator;\n    }\n    return Object.assign(accumulator, {\n      [key]: value\n    });\n  }, {});\n}\n\n/* iterates the stats graph recursively. */\nfunction walkStats(stats, base, resultSet) {\n  if (!base || resultSet.has(base.id)) {\n    return;\n  }\n  resultSet.set(base.id, base);\n  Object.keys(base).forEach(name => {\n    if (name.endsWith('Id')) {\n      walkStats(stats, stats.get(base[name]), resultSet);\n    } else if (name.endsWith('Ids')) {\n      base[name].forEach(id => {\n        walkStats(stats, stats.get(id), resultSet);\n      });\n    }\n  });\n}\n\n/* filter getStats for a sender/receiver track. */\nfunction filterStats(result, track, outbound) {\n  const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\n  const filteredResult = new Map();\n  if (track === null) {\n    return filteredResult;\n  }\n  const trackStats = [];\n  result.forEach(value => {\n    if (value.type === 'track' && value.trackIdentifier === track.id) {\n      trackStats.push(value);\n    }\n  });\n  trackStats.forEach(trackStat => {\n    result.forEach(stats => {\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n        walkStats(result, stats, filteredResult);\n      }\n    });\n  });\n  return filteredResult;\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/webrtc-adapter/src/js/utils.js?");

/***/ }),

/***/ "./src/rtsp-to-web-player.js":
/*!***********************************!*\
  !*** ./src/rtsp-to-web-player.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RTSPtoWEBPlayer)\n/* harmony export */ });\n/* harmony import */ var webrtc_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webrtc-adapter */ \"./node_modules/webrtc-adapter/src/js/adapter_core.js\");\n/* harmony import */ var hls_js_dist_hls_light_min_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hls.js/dist/hls.light.min.js */ \"./node_modules/hls.js/dist/hls.light.min.js\");\n/* harmony import */ var hls_js_dist_hls_light_min_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(hls_js_dist_hls_light_min_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _rtsp_to_web_player_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rtsp-to-web-player.css */ \"./src/rtsp-to-web-player.css\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\nclass RTSPtoWEBPlayer {\n  constructor(options) {\n    var _this = this;\n    _defineProperty(this, \"MSE\", null);\n    _defineProperty(this, \"MSEStreamingStarted\", false);\n    _defineProperty(this, \"MSESourceBuffer\", null);\n    _defineProperty(this, \"turn\", []);\n    _defineProperty(this, \"codec\", null);\n    _defineProperty(this, \"webSocket\", null);\n    _defineProperty(this, \"webrtc\", null);\n    _defineProperty(this, \"webRtcSocket\", null);\n    _defineProperty(this, \"currentPlayerType\", null);\n    _defineProperty(this, \"hidden\", 'hidden');\n    _defineProperty(this, \"paused\", false);\n    _defineProperty(this, \"presets\", null);\n    _defineProperty(this, \"audio_tracks\", null);\n    _defineProperty(this, \"switchFlag\", false);\n    _defineProperty(this, \"user_state\", {\n      paused: false\n    });\n    _defineProperty(this, \"options\", {\n      parentElement: null,\n      source: null,\n      controls: true,\n      muted: true,\n      autoplay: true,\n      loop: false,\n      hlsjsconfig: {},\n      webrtcconfig: {\n        iceServers: [{\n          urls: ['stun:stun.l.google.com:19302']\n        }],\n        sdpSemantics: 'unified-plan',\n        bundlePolicy: 'max-compat'\n        //iceTransportPolicy: \"relay\",\n        // for option \"relay\" need use  turn server\n      },\n      debug: false,\n      getPresets: null,\n      onResolutionChange: null,\n      latency: null,\n      onWsClose: null\n    });\n    _defineProperty(this, \"createElements\", () => {\n      //video\n      this.video = document.createElement('video');\n      this.video.setAttribute('playsinline', '');\n      this.video.muted = this.options.muted ? true : false;\n      this.video.controls = this.options.controls ? true : false;\n      this.video.autoplay = this.options.autoplay ? true : false;\n      this.video.loop = this.options.loop ? true : false;\n      this.addVideoListeners();\n      //wrapper\n      this.player = document.createElement('div');\n      this.player.classList.add('RTSPtoWEBPlayer');\n      this.player.append(this.video);\n    });\n    _defineProperty(this, \"attachTo\", element => {\n      this.options.parentElement = element;\n      this.options.parentElement.innerHTML = '';\n      this.options.parentElement.append(this.player);\n      if (this.options.source) {\n        this.load(this.options.source);\n      }\n    });\n    _defineProperty(this, \"load\", source => {\n      this.options.source = source;\n      this.destroy();\n      const sourceType = new URL(this.options.source);\n      if (sourceType.protocol === 'http:' || sourceType.protocol === 'https:') {\n        if (this.options.source.indexOf('m3u8') !== -1) {\n          this.currentPlayerType = 'hls';\n          this.hlsPlayer();\n        } else if (this.options.source.indexOf('.mp4') !== -1) {\n          this.currentPlayerType = 'mp4';\n          this.mp4Player();\n        } else {\n          this.currentPlayerType = 'rtc';\n          this.webRtcPlayer();\n        }\n      } else if (sourceType.protocol === 'ws:' || sourceType.protocol === 'wss:') {\n        if (this.options.source.indexOf('webrtc') !== -1) {\n          this.currentPlayerType = 'ws-rtc';\n          this.webRtcOverSocket();\n        } else if (this.options.source.indexOf('on-air') !== -1 || this.options.source.indexOf('preview') !== -1) {\n          this.currentPlayerType = 'ws-new';\n          this.newMsePlayer();\n        } else {\n          this.currentPlayerType = 'ws';\n          this.msePlayer();\n        }\n      } else {\n        this.currentPlayerType = null;\n      }\n    });\n    _defineProperty(this, \"newMsePlayer\", () => {\n      this.webSocket = new WebSocket(this.options.source);\n      this.webSocket.onclose = e => {\n        if (typeof this.options.onWsClose === 'function') {\n          this.options.onWsClose(e.code, e.reason);\n        }\n        this.debugLogger(e);\n      };\n      this.webSocket.onmessage = _ref => {\n        let {\n          data\n        } = _ref;\n        this.messageHandlerMSE(data);\n      };\n    });\n    _defineProperty(this, \"webRtcOverSocket\", () => {\n      this.webRtcSocket = new WebSocket(this.options.source);\n      this.webRtcSocket.onopen = () => {\n        this.webRtcPlayer();\n      };\n      this.webRtcSocket.onclose = e => {\n        this.debugLogger(e);\n        this.webRtcSocket.onmessage = null;\n        if (typeof this.options.onWsClose === 'function') {\n          this.options.onWsClose(e.code, e.reason);\n        }\n      };\n      this.webRtcSocket.onerror = e => {\n        this.debugLogger(e);\n      };\n      this.webRtcSocket.onmessage = _ref2 => {\n        let {\n          data\n        } = _ref2;\n        this.webRtcSocketMessageHandler(data);\n      };\n    });\n    _defineProperty(this, \"webRtcSocketMessageHandler\", data => {\n      data = JSON.parse(data);\n      switch (data.method) {\n        case 'meta_response':\n          this.presets = data.payload.streams;\n          if (typeof this.options.getPresets === 'function') {\n            this.options.getPresets(this.presets, data.payload.audio_tracks);\n          }\n          const arr_video = data.payload.streams.filter(item => {\n            return item.default;\n          });\n          const arr_audio = data.payload.audio_tracks.filter(item => {\n            return item.default;\n          });\n          const default_video = arr_video.length > 0 ? arr_video[0].idx : data.payload.streams[0].idx;\n          const default_audio = arr_audio.length > 0 ? arr_audio[0].idx : data.payload.audio_tracks[0].idx;\n          this.user_state.video_track_id = default_video;\n          this.user_state.audio_track_id = default_audio;\n          //  \n          this.webRtcSocketOffer();\n          break;\n        case 'offer':\n          this.webrtc.setRemoteDescription(new RTCSessionDescription(data.payload));\n          break;\n        case 'ice_candidate':\n          this.webrtc.addIceCandidate(data.payload);\n          break;\n        case 'answer':\n          this.webrtc.setRemoteDescription(new RTCSessionDescription(data.payload));\n          break;\n        default:\n          console.warn('unsupported method', data.method);\n          return;\n      }\n    });\n    _defineProperty(this, \"webRtcSocketOffer\", async () => {\n      const offer = await this.webrtc.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: true\n      });\n      await this.webrtc.setLocalDescription(offer);\n    });\n    _defineProperty(this, \"messageHandlerMSE\", data => {\n      if (typeof data === 'string') {\n        try {\n          data = JSON.parse(data);\n          switch (data.method) {\n            case 'play_response':\n              break;\n            case 'meta_response':\n              this.presets = data.payload.streams;\n              if (typeof this.options.getPresets === 'function') {\n                this.options.getPresets(this.presets, data.payload.audio_tracks);\n              }\n              const arr_video = data.payload.streams.filter(item => {\n                return item.default;\n              });\n              const arr_audio = data.payload.audio_tracks.filter(item => {\n                return item.default;\n              });\n              const default_video = arr_video.length > 0 ? arr_video[0].idx : data.payload.streams[0].idx;\n              const default_audio = arr_audio.length > 0 ? arr_audio[0].idx : data.payload.audio_tracks[0].idx;\n              this.user_state.video_track_id = default_video;\n              this.user_state.audio_track_id = default_audio;\n              this.playPresetMSE(default_video, default_audio);\n              break;\n            default:\n              console.log(data.method);\n              return;\n          }\n          if (data.method === 'play_response') {} else {}\n        } catch (e) {\n          this.debugLogger(e);\n        }\n      } else if (typeof data === 'object') {\n        data.arrayBuffer().then(packet => {\n          this.readPacket(packet);\n        });\n        //\n      }\n    });\n    _defineProperty(this, \"getPresets\", () => {\n      return this.presets;\n    });\n    _defineProperty(this, \"playPresetMSE\", (videoIdx, audioIdx) => {\n      this.codec = this.presets.filter(item => item.idx === videoIdx)[0].codecs;\n      const answer = JSON.stringify({\n        method: 'user_state',\n        payload: this.user_state\n      });\n      this.MSE = new MediaSource();\n      this.video.src = window.URL.createObjectURL(this.MSE);\n      this.MSE.addEventListener('sourceopen', () => {\n        this.MSESourceBuffer = this.MSE.addSourceBuffer(\"video/mp4; codecs=\\\"\".concat(this.codec, \"\\\"\"));\n        this.MSESourceBuffer.mode = 'segments';\n        this.MSESourceBuffer.addEventListener('updateend', this.pushPacket);\n        this.webSocket.send(answer);\n      });\n    });\n    _defineProperty(this, \"switchStream\", index => {\n      this.codec = this.presets[index].codecs;\n      this.user_state.video_track_id = this.presets[index].idx;\n      if (this.webRtcSocket) {\n        this.webRtcSocket.send(JSON.stringify({\n          method: 'user_state',\n          payload: this.user_state\n        }));\n      } else {\n        this.switchFlag = true;\n        this.webSocket.send(JSON.stringify({\n          method: 'user_state',\n          payload: this.user_state\n        }));\n        this.MSESourceBuffer.timestampOffset = this.MSESourceBuffer.appendWindowStart = this.MSESourceBuffer.buffered.end(this.MSESourceBuffer.buffered.length - 1);\n      }\n    });\n    _defineProperty(this, \"switchAudio\", idx => {\n      this.user_state.audio_track_id = idx;\n      if (this.webRtcSocket) {\n        this.webRtcSocket.send(JSON.stringify({\n          method: 'user_state',\n          payload: this.user_state\n        }));\n      } else {\n        this.webSocket.send(JSON.stringify({\n          method: 'set_audio_track',\n          payload: {\n            audio_track_id: idx\n          }\n        }));\n        this.video.currentTime += 0.01;\n      }\n    });\n    _defineProperty(this, \"addMseListeners\", () => {\n      this.MSE.addEventListener('sourceopen', this.sourceOpenHandler);\n    });\n    _defineProperty(this, \"sourceOpenHandler\", () => {\n      this.websocketEvents();\n    });\n    _defineProperty(this, \"websocketEvents\", () => {\n      this.webSocket = new WebSocket(this.options.source);\n      this.webSocket.binaryType = 'arraybuffer';\n      this.webSocket.onclose = e => {\n        this.webSocket.onmessage = null;\n        if (typeof this.options.onWsClose === 'function') {\n          this.options.onWsClose(e.code, e.reason);\n        }\n      };\n      this.webSocket.onmessage = _ref3 => {\n        let {\n          data\n        } = _ref3;\n        if (typeof data === 'object') {\n          if (this.codec === null) {\n            this.codec = new TextDecoder('utf-8').decode(new Uint8Array(data).slice(1));\n            this.MSESourceBuffer = this.MSE.addSourceBuffer(\"video/mp4; codecs=\\\"\".concat(this.codec, \"\\\"\"));\n            this.MSESourceBuffer.mode = 'segments';\n            this.MSE.duration = Infinity;\n            this.MSESourceBuffer.addEventListener('updateend', this.pushPacket);\n          } else {\n            if (!this.paused) {\n              this.readPacket(data);\n            }\n          }\n        } else {\n          if (this.codec !== null) {\n            console.log(data);\n          } else {\n            this.codec = data;\n            this.MSESourceBuffer = this.MSE.addSourceBuffer(\"video/mp4; codecs=\\\"\".concat(this.codec, \"\\\"\"));\n            this.MSESourceBuffer.mode = 'segments';\n            this.MSE.duration = Infinity;\n            this.MSESourceBuffer.addEventListener('updateend', this.pushPacket);\n          }\n        }\n        if (document[this.hidden] && this.video.buffered.length) {\n          this.video.currentTime = this.video.buffered.end(this.video.buffered.length - 1) - 1;\n        }\n      };\n    });\n    _defineProperty(this, \"readPacket\", packet => {\n      if (this.video.buffered && this.video.currentTime > 0) {\n        if (typeof this.options.latency === 'function') {\n          this.options.latency(this.video.buffered.length, this.video.buffered.end(this.video.buffered.length - 1), this.video.currentTime);\n        }\n        if (this.video.currentTime < this.video.buffered.start(this.video.buffered.length - 1)) {\n          this.video.currentTime = this.video.buffered.end(this.video.buffered.length - 1);\n        }\n      }\n      if (!this.MSEStreamingStarted) {\n        try {\n          this.MSESourceBuffer.appendBuffer(packet);\n          this.MSEStreamingStarted = true;\n        } catch (e) {\n          this.debugLogger(e);\n        }\n        return;\n      }\n      this.turn.push(packet);\n      this.pushPacket();\n    });\n    _defineProperty(this, \"pushPacket\", () => {\n      if (!this.MSESourceBuffer.updating) {\n        if (this.turn.length > 0) {\n          const packet = this.turn.shift();\n          try {\n            this.MSESourceBuffer.appendBuffer(packet);\n          } catch (err) {\n            this.debugLogger(err);\n          }\n        } else {\n          this.MSEStreamingStarted = false;\n        }\n      }\n    });\n    _defineProperty(this, \"mp4Player\", () => {\n      this.video.src = this.options.source;\n    });\n    _defineProperty(this, \"msePlayer\", () => {\n      this.MSE = new MediaSource();\n      this.video.src = window.URL.createObjectURL(this.MSE);\n      this.addMseListeners();\n    });\n    _defineProperty(this, \"hlsPlayer\", () => {\n      if (this.video.canPlayType('application/vnd.apple.mpegurl')) {\n        this.video.src = this.options.source;\n      } else if (hls_js_dist_hls_light_min_js__WEBPACK_IMPORTED_MODULE_1___default().isSupported()) {\n        this.hls = new (hls_js_dist_hls_light_min_js__WEBPACK_IMPORTED_MODULE_1___default())(this.options.hlsjsconfig);\n        this.hls.loadSource(this.options.source);\n        this.hls.attachMedia(this.video);\n      } else {\n        console.warn('UNSUPPOERED MEDIA SOURCE');\n      }\n    });\n    _defineProperty(this, \"webRtcPlayer\", async () => {\n      this.mediaStream = new MediaStream();\n      this.video.srcObject = this.mediaStream;\n      this.webrtc = new RTCPeerConnection(this.options.webrtcconfig);\n      this.webrtc.onnegotiationneeded = this.handleNegotiationNeeded;\n      this.webrtc.onsignalingstatechange = this.signalingstatechange;\n      this.webrtc.onicegatheringstatechange = this.icegatheringstatechange;\n      this.webrtc.onicecandidate = this.icecandidate;\n      this.webrtc.onicecandidateerror = this.icecandidateerror;\n      this.webrtc.onconnectionstatechange = this.connectionstatechange;\n      this.webrtc.oniceconnectionstatechange = this.iceconnectionstatechange;\n      this.webrtc.ontrack = this.onTrack;\n      if (!this.webRtcSocket) {\n        /*\n         * for older schema initiate connection create local description\n         */\n        const offer = await this.webrtc.createOffer({\n          offerToReceiveAudio: false,\n          offerToReceiveVideo: true\n        });\n        await this.webrtc.setLocalDescription(offer);\n      }\n    });\n    _defineProperty(this, \"handleNegotiationNeeded\", async e => {\n      /*\n       * in this project this handler is not needed, but in another it can be useful\n       */\n      this.debugLogger('handleNegotiationNeeded');\n      if (this.webRtcSocket) {\n        const offer = await this.webrtc.createOffer({\n          offerToReceiveAudio: false,\n          offerToReceiveVideo: true\n        });\n        await this.webrtc.setLocalDescription(offer);\n      }\n    });\n    _defineProperty(this, \"signalingstatechange\", async () => {\n      switch (this.webrtc.signalingState) {\n        case 'have-remote-offer':\n          this.debugLogger('this.webrtc.signalingState====>[have-remote-offer]');\n          if (this.webRtcSocket) {\n            const answer = await this.webrtc.createAnswer();\n            await this.webrtc.setLocalDescription(answer);\n            this.webRtcSocket.send(JSON.stringify({\n              method: 'answer',\n              payload: {\n                sdp: answer,\n                user_state: this.user_state\n              }\n            }));\n          }\n          break;\n        case 'have-local-offer':\n          this.debugLogger('this.webrtc.signalingState====>[have-local-offer]');\n          if (!this.webRtcSocket) {\n            const suuid = new URL(this.options.source).pathname.split('/').slice(-1);\n            const formData = new FormData();\n            formData.append('data', btoa(this.webrtc.localDescription.sdp));\n            formData.append('suuid', suuid);\n            const response = await fetch(this.options.source, {\n              method: 'POST',\n              body: formData\n            });\n            if (response.ok) {\n              const remoteDescription = await response.text();\n              this.webrtc.setRemoteDescription(new RTCSessionDescription({\n                type: 'answer',\n                sdp: atob(remoteDescription)\n              }));\n            }\n          } else {\n            this.webRtcSocket.send(JSON.stringify({\n              method: 'offer',\n              payload: {\n                user_state: this.user_state,\n                sdp: this.webrtc.localDescription\n              }\n            }));\n          }\n          break;\n        case 'stable':\n          /*\n           * There is no ongoing exchange of offer and answer underway.\n           * This may mean that the RTCPeerConnection object is new, in which case both the localDescription and remoteDescription are null;\n           * it may also mean that negotiation is complete and a connection has been established.\n           */\n          this.debugLogger('this.webrtc.signalingState====>[stable]');\n          break;\n        case 'closed':\n          /*\n           * The RTCPeerConnection has been closed.\n           */\n          this.debugLogger('this.webrtc.signalingState====>[closed]');\n          this.destroy();\n          break;\n        default:\n          console.log(\"unhandled signalingState is \".concat(this.webrtc.signalingState));\n          break;\n      }\n    });\n    _defineProperty(this, \"icegatheringstatechange\", () => {\n      switch (this.webrtc.iceGatheringState) {\n        case 'gathering':\n          /* collection of candidates has begun */\n          this.debugLogger('collection of candidates has begun');\n          break;\n        case 'complete':\n          /* collection of candidates is finished */\n          this.debugLogger('collection of candidates is finished');\n          break;\n      }\n    });\n    _defineProperty(this, \"icecandidate\", event => {\n      this.debugLogger('icecandidate\\n', event);\n      if (this.webRtcSocket) {\n        if (event.candidate && event.candidate.candidate !== '') {\n          this.webRtcSocket.send(JSON.stringify({\n            method: 'ice_candidate',\n            payload: event.candidate\n          }));\n        }\n      }\n    });\n    _defineProperty(this, \"icecandidateerror\", event => {\n      this.debugLogger('icecandidateerror\\n', \"hostCandidate: \".concat(event.hostCandidate, \" CODE: \").concat(event.errorCode, \" TEXT: \").concat(event.errorText));\n    });\n    _defineProperty(this, \"connectionstatechange\", e => {\n      //console.log(e)\n      switch (this.webrtc.connectionState) {\n        case 'new':\n        case 'connected':\n          this.debugLogger('connected');\n          break;\n        case 'disconnected':\n          this.debugLogger('disconnected...');\n          break;\n        case 'closed':\n          this.debugLogger('Offline');\n          break;\n        case 'failed':\n          this.webrtc.restartIce();\n          this.debugLogger('Error');\n          break;\n        default:\n          this.debugLogger(\"Unhadled state: \".concat(this.webrtc.connectionState));\n          break;\n      }\n    });\n    _defineProperty(this, \"iceconnectionstatechange\", () => {\n      this.debugLogger('iceconnectionstatechange\\n', this.webrtc.iceConnectionState);\n    });\n    _defineProperty(this, \"onTrack\", event => {\n      this.debugLogger('onTrack\\n');\n      //make sure there is only one video track in  mediaStream\n      if (event.track.kind === 'video' && this.mediaStream.getVideoTracks().length > 0) {\n        this.mediaStream.removeTrack(this.mediaStream.getVideoTracks()[0]);\n      }\n      if (event.track.kind === 'audio' && this.mediaStream.getAudioTracks().length > 0) {\n        this.mediaStream.removeTrack(this.mediaStream.getAudioTracks()[0]);\n      }\n      this.mediaStream.addTrack(event.track);\n    });\n    _defineProperty(this, \"destroy\", () => {\n      this.codec = null;\n      this.presets = null;\n      this.audio_tracks = null;\n      if (this.currentPlayerType != null) {\n        switch (this.currentPlayerType) {\n          case 'hls':\n            if (this.hls != null) {\n              this.hls.destroy();\n            }\n            break;\n          case 'rtc':\n            if (this.webrtc != null) {\n              this.webrtc.close();\n              this.webrtc = null;\n              this.video.srcObject = null;\n              this.mediaStream = null;\n            }\n            break;\n          case 'ws':\n          case 'ws-new':\n            this.webSocket.onerror = null;\n            this.webSocket.onopen = null;\n            this.webSocket.onmessage = null;\n            this.webSocket.onclose = null;\n            this.webSocket.close(1000);\n            this.turn = [];\n            break;\n          case 'ws-rtc':\n            this.webRtcSocket.onerror = null;\n            this.webRtcSocket.onopen = null;\n            this.webRtcSocket.onmessage = null;\n            this.webRtcSocket.onclose = null;\n            this.webRtcSocket.close(1000);\n            this.turn = [];\n            if (this.webrtc != null) {\n              this.webrtc.close();\n              this.webrtc = null;\n              this.video.srcObject = null;\n              this.mediaStream = null;\n            }\n            break;\n          default:\n        }\n        this.video.pause();\n        this.video.removeAttribute('src'); // empty source\n        this.video.load();\n      }\n    });\n    _defineProperty(this, \"addVideoListeners\", () => {\n      this.video.addEventListener('error', e => {\n        this.debugLogger('[ video listener ]', e);\n        this.destroy();\n      });\n      this.video.addEventListener('play', () => {\n        this.paused = false;\n      });\n      this.video.addEventListener('pause', () => {\n        this.paused = true;\n      });\n      this.video.addEventListener('resize', () => {\n        if (typeof this.options.onResolutionChange === 'function') {\n          this.options.onResolutionChange(this.video.videoWidth, this.video.videoHeight);\n        }\n      });\n      this.video.addEventListener('progress', () => {\n        if (this.currentPlayerType === 'ws' && this.video.buffered.length > 0) {\n          if (this.video.currentTime < this.video.buffered.start(this.video.buffered.length - 1)) {\n            this.video.currentTime = this.video.buffered.end(this.video.buffered.length - 1) - 1;\n          }\n        }\n      });\n      this.video.addEventListener('canplay', () => {\n        if (this.currentPlayerType === 'ws') {\n          if (this.video.paused && this.video.autoplay) {\n            this.video.play();\n          }\n        }\n      });\n    });\n    _defineProperty(this, \"getImageBase64\", () => {\n      const canvas = document.createElement('canvas');\n      canvas.width = this.video.videoWidth;\n      canvas.height = this.video.videoHeight;\n      canvas.getContext('2d').drawImage(this.video, 0, 0, canvas.width, canvas.height);\n      const dataURL = canvas.toDataURL();\n      canvas.remove();\n      return dataURL;\n    });\n    _defineProperty(this, \"debugLogger\", function () {\n      if (_this.options.debug) {\n        for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {\n          arg[_key] = arguments[_key];\n        }\n        if (_this.options.debug === 'trace') {\n          console.trace(...arg);\n        } else {\n          const d = new Date();\n          console.log(d.toLocaleTimeString() + \".\".concat(d.getMilliseconds()), ...arg);\n        }\n      }\n    });\n    this.options = _objectSpread(_objectSpread({}, this.options), options);\n    this.createElements();\n    if (this.options.parentElement) {\n      this.attachTo(this.options.parentElement);\n    }\n    this.defDocumentHidden();\n  }\n  defDocumentHidden() {\n    if (typeof document.hidden !== 'undefined') {\n      this.hidden = 'hidden';\n    } else if (typeof document.msHidden !== 'undefined') {\n      this.hidden = 'msHidden';\n    } else if (typeof document.webkitHidden !== 'undefined') {\n      this.hidden = 'webkitHidden';\n    }\n  }\n}\n\n//# sourceURL=webpack://rtsptowebplayer/./src/rtsp-to-web-player.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/rtsp-to-web-player.css":
/*!**************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/rtsp-to-web-player.css ***!
  \**************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.RTSPtoWEBPlayer {\n\twidth: 100%;\n\theight: 100%;\n}\n\n.RTSPtoWEBPlayer video {\n\twidth: 100%;\n\theight: 100%;\n\tbackground: black;\n}\n`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://rtsptowebplayer/./src/rtsp-to-web-player.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./src/rtsp-to-web-player.css":
/*!************************************!*\
  !*** ./src/rtsp-to-web-player.css ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_rtsp_to_web_player_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./rtsp-to-web-player.css */ \"./node_modules/css-loader/dist/cjs.js!./src/rtsp-to-web-player.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_rtsp_to_web_player_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_rtsp_to_web_player_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_rtsp_to_web_player_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_rtsp_to_web_player_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://rtsptowebplayer/./src/rtsp-to-web-player.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://rtsptowebplayer/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/rtsp-to-web-player.js");
/******/ 	RTSPtoWEBPlayer = __webpack_exports__["default"];
/******/ 	
/******/ })()
;